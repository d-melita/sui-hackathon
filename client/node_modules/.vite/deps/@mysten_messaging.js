import {
  EncryptedObject,
  SessionKey
} from "./chunk-SAQHCM27.js";
import "./chunk-J4J2CIMO.js";
import "./chunk-ECHZFDKV.js";
import "./chunk-AAQ5BGIB.js";
import {
  Transaction,
  isArgument
} from "./chunk-KKUTONH5.js";
import {
  BcsStruct,
  BcsTuple,
  TypeTagSerializer,
  deriveDynamicFieldID,
  fromHex,
  isValidSuiObjectId,
  normalizeSuiAddress,
  suiBcs,
  toHex
} from "./chunk-YEPCDVTF.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@mysten/messaging/dist/esm/contracts/utils/index.js
var MOVE_STDLIB_ADDRESS = normalizeSuiAddress("0x1");
var SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress("0x2");
var SUI_SYSTEM_ADDRESS = normalizeSuiAddress("0x3");
function getPureBcsSchema(typeTag) {
  const parsedTag = typeof typeTag === "string" ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;
  if ("u8" in parsedTag) {
    return suiBcs.U8;
  } else if ("u16" in parsedTag) {
    return suiBcs.U16;
  } else if ("u32" in parsedTag) {
    return suiBcs.U32;
  } else if ("u64" in parsedTag) {
    return suiBcs.U64;
  } else if ("u128" in parsedTag) {
    return suiBcs.U128;
  } else if ("u256" in parsedTag) {
    return suiBcs.U256;
  } else if ("address" in parsedTag) {
    return suiBcs.Address;
  } else if ("bool" in parsedTag) {
    return suiBcs.Bool;
  } else if ("vector" in parsedTag) {
    const type = getPureBcsSchema(parsedTag.vector);
    return type ? suiBcs.vector(type) : null;
  } else if ("struct" in parsedTag) {
    const structTag = parsedTag.struct;
    const pkg = normalizeSuiAddress(parsedTag.struct.address);
    if (pkg === MOVE_STDLIB_ADDRESS) {
      if ((structTag.module === "ascii" || structTag.module === "string") && structTag.name === "String") {
        return suiBcs.String;
      }
      if (structTag.module === "option" && structTag.name === "Option") {
        const type = getPureBcsSchema(structTag.typeParams[0]);
        return type ? suiBcs.vector(type) : null;
      }
    }
    if (pkg === SUI_FRAMEWORK_ADDRESS && structTag.module === "Object" && structTag.name === "ID") {
      return suiBcs.Address;
    }
  }
  return null;
}
function normalizeMoveArguments(args, argTypes, parameterNames) {
  if (parameterNames && argTypes.length !== parameterNames.length) {
    throw new Error(
      `Invalid number of parameterNames, expected ${argTypes.length}, got ${parameterNames.length}`
    );
  }
  const normalizedArgs = [];
  let index = 0;
  for (const [i, argType] of argTypes.entries()) {
    if (argType === `${SUI_FRAMEWORK_ADDRESS}::deny_list::DenyList`) {
      normalizedArgs.push((tx) => tx.object.denyList());
      continue;
    }
    if (argType === `${SUI_FRAMEWORK_ADDRESS}::random::Random`) {
      normalizedArgs.push((tx) => tx.object.random());
      continue;
    }
    if (argType === `${SUI_FRAMEWORK_ADDRESS}::clock::Clock`) {
      normalizedArgs.push((tx) => tx.object.clock());
      continue;
    }
    if (argType === `${SUI_SYSTEM_ADDRESS}::sui_system::SuiSystemState`) {
      normalizedArgs.push((tx) => tx.object.system());
      continue;
    }
    let arg;
    if (Array.isArray(args)) {
      if (index >= args.length) {
        throw new Error(
          `Invalid number of arguments, expected at least ${index + 1}, got ${args.length}`
        );
      }
      arg = args[index];
    } else {
      if (!parameterNames) {
        throw new Error(`Expected arguments to be passed as an array`);
      }
      const name = parameterNames[index];
      arg = args[name];
      if (arg == null) {
        throw new Error(`Parameter ${name} is required`);
      }
    }
    index += 1;
    if (typeof arg === "function" || isArgument(arg)) {
      normalizedArgs.push(arg);
      continue;
    }
    const type = argTypes[i];
    const bcsType = getPureBcsSchema(type);
    if (bcsType) {
      const bytes = bcsType.serialize(arg);
      normalizedArgs.push((tx) => tx.pure(bytes));
      continue;
    } else if (typeof arg === "string") {
      normalizedArgs.push((tx) => tx.object(arg));
      continue;
    }
    throw new Error(`Invalid argument ${stringify(arg)} for type ${type}`);
  }
  return normalizedArgs;
}
var MoveStruct = class extends BcsStruct {
};
var MoveTuple = class extends BcsTuple {
};
function stringify(val) {
  if (typeof val === "object") {
    return JSON.stringify(val, (val2) => val2);
  }
  if (typeof val === "bigint") {
    return val.toString();
  }
  return val;
}

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/sui/object.js
var $moduleName = "0x2::object";
var UID = new MoveStruct({
  name: `${$moduleName}::UID`,
  fields: {
    id: suiBcs.Address
  }
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/sui/vec_map.js
var $moduleName2 = "0x2::vec_map";
function Entry(...typeParameters) {
  return new MoveStruct({
    name: `${$moduleName2}::Entry<${typeParameters[0].name}, ${typeParameters[1].name}>`,
    fields: {
      key: typeParameters[0],
      value: typeParameters[1]
    }
  });
}
function VecMap(...typeParameters) {
  return new MoveStruct({
    name: `${$moduleName2}::VecMap<${typeParameters[0].name}, ${typeParameters[1].name}>`,
    fields: {
      contents: suiBcs.vector(Entry(typeParameters[0], typeParameters[1]))
    }
  });
}

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/sui/vec_set.js
var $moduleName3 = "0x2::vec_set";
function VecSet(...typeParameters) {
  return new MoveStruct({
    name: `${$moduleName3}::VecSet<${typeParameters[0].name}>`,
    fields: {
      contents: suiBcs.vector(typeParameters[0])
    }
  });
}

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/std/type_name.js
var $moduleName4 = "std::type_name";
var TypeName = new MoveStruct({
  name: `${$moduleName4}::TypeName`,
  fields: {
    /**
     * String representation of the type. All types are represented using their source
     * syntax: "u8", "u64", "bool", "address", "vector", and so on for primitive types.
     * Struct types are represented as fully qualified type names; e.g.
     * `00000000000000000000000000000001::string::String` or
     * `0000000000000000000000000000000a::module_name1::type_name1<0000000000000000000000000000000a::module_name2::type_name2<u64>>`
     * Addresses are hex-encoded lowercase values of length ADDRESS_LENGTH (16, 20, or
     * 32 depending on the Move platform)
     */
    name: suiBcs.string()
  }
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/sui/versioned.js
var $moduleName5 = "0x2::versioned";
var Versioned = new MoveStruct({
  name: `${$moduleName5}::Versioned`,
  fields: {
    id: UID,
    version: suiBcs.u64()
  }
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/auth.js
var $moduleName6 = "@local-pkg/sui-stack-messaging::auth";
var Auth = new MoveStruct({
  name: `${$moduleName6}::Auth`,
  fields: {
    member_permissions: VecMap(suiBcs.Address, VecSet(TypeName)),
    config: Versioned
  }
});
var EditPermissions = new MoveTuple({
  name: `${$moduleName6}::EditPermissions`,
  fields: [suiBcs.bool()]
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/sui/table.js
var $moduleName7 = "0x2::table";
var Table = new MoveStruct({
  name: `${$moduleName7}::Table`,
  fields: {
    /** the ID of this table */
    id: UID,
    /** the number of key-value pairs in the table */
    size: suiBcs.u64()
  }
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/deps/sui/table_vec.js
var $moduleName8 = "0x2::table_vec";
var TableVec = new MoveStruct({
  name: `${$moduleName8}::TableVec`,
  fields: {
    /** The contents of the table vector. */
    contents: Table
  }
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/attachment.js
var $moduleName9 = "@local-pkg/sui-stack-messaging::attachment";
var Attachment = new MoveStruct({
  name: `${$moduleName9}::Attachment`,
  fields: {
    blob_ref: suiBcs.string(),
    encrypted_metadata: suiBcs.vector(suiBcs.u8()),
    data_nonce: suiBcs.vector(suiBcs.u8()),
    metadata_nonce: suiBcs.vector(suiBcs.u8()),
    key_version: suiBcs.u32()
  }
});
function _new(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    "0x0000000000000000000000000000000000000000000000000000000000000001::string::String",
    "vector<u8>",
    "vector<u8>",
    "vector<u8>",
    "u32"
  ];
  const parameterNames = [
    "blobRef",
    "encryptedMetadata",
    "dataNonce",
    "metadataNonce",
    "keyVersion"
  ];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "attachment",
    function: "new",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/message.js
var $moduleName10 = "@local-pkg/sui-stack-messaging::message";
var Message = new MoveStruct({
  name: `${$moduleName10}::Message`,
  fields: {
    /** The address of the sender of this message. TODO: should we encrypt this as well? */
    sender: suiBcs.Address,
    /** The message content, encrypted with a DEK(Data Encryption Key) */
    ciphertext: suiBcs.vector(suiBcs.u8()),
    /** The nonce used for the encryption of the content. */
    nonce: suiBcs.vector(suiBcs.u8()),
    /**
     * The version of the DEK(Data Encryption Key) that was used to encrypt this
     * Message
     */
    key_version: suiBcs.u32(),
    /** A vector of attachments associated with this message. */
    attachments: suiBcs.vector(Attachment),
    /** Timestamp in milliseconds when the message was created. */
    created_at_ms: suiBcs.u64()
  }
});
var MessageAddedEvent = new MoveStruct({
  name: `${$moduleName10}::MessageAddedEvent`,
  fields: {
    channel_id: suiBcs.Address,
    message_index: suiBcs.u64(),
    sender: suiBcs.Address,
    ciphertext: suiBcs.vector(suiBcs.u8()),
    nonce: suiBcs.vector(suiBcs.u8()),
    key_version: suiBcs.u32(),
    attachment_refs: suiBcs.vector(suiBcs.string()),
    attachment_nonces: suiBcs.vector(suiBcs.vector(suiBcs.u8())),
    created_at_ms: suiBcs.u64()
  }
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/encryption_key_history.js
var $moduleName11 = "@local-pkg/sui-stack-messaging::encryption_key_history";
var EncryptionKeyHistory = new MoveStruct({
  name: `${$moduleName11}::EncryptionKeyHistory`,
  fields: {
    latest: suiBcs.vector(suiBcs.u8()),
    latest_version: suiBcs.u32(),
    history: TableVec
  }
});
var EditEncryptionKey = new MoveTuple({
  name: `${$moduleName11}::EditEncryptionKey`,
  fields: [suiBcs.bool()]
});

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/channel.js
var $moduleName12 = "@local-pkg/sui-stack-messaging::channel";
var Channel = new MoveStruct({
  name: `${$moduleName12}::Channel`,
  fields: {
    id: UID,
    /** The version of this object, for handling updgrades. */
    version: suiBcs.u64(),
    /**
     * The Authorization struct, gating actions to member permissions. Note: It also,
     * practically, keeps tracks of the members (MemberCap ID -> Permissions)
     */
    auth: Auth,
    /**
     * The message history of the channel.
     *
     * Using `TableVec` to avoid the object size limit.
     */
    messages: TableVec,
    /**
     * The total number of messages, for efficiency, so that we don't have to make a
     * call to messages.length() (Maybe I am overthinking this, need to measure)
     */
    messages_count: suiBcs.u64(),
    /**
     * A duplicate of the last entry of the messages TableVec,
     *
     * Utilize this for efficient fetching e.g. list of conversations showing the
     * latest message and the user who sent it
     */
    last_message: suiBcs.option(Message),
    /** The timestamp (in milliseconds) when the channel was created. */
    created_at_ms: suiBcs.u64(),
    /**
     * The timestamp (in milliseconds) when the channel was last updated. (e.g. change
     * in metadata, members, admins, keys)
     */
    updated_at_ms: suiBcs.u64(),
    /**
     * History of Encryption keys
     *
     * Holds the latest key, the latest_version, and a TableVec of the historical keys
     */
    encryption_key_history: EncryptionKeyHistory
  }
});
var SimpleMessenger = new MoveTuple({
  name: `${$moduleName12}::SimpleMessenger`,
  fields: [suiBcs.bool()]
});
function _new2(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    `0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<${packageAddress}::config::Config>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["config", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "channel",
    function: "new",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function share(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    `${packageAddress}::channel::Channel`,
    `${packageAddress}::creator_cap::CreatorCap`
  ];
  const parameterNames = ["self", "creatorCap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "channel",
    function: "share",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function addEncryptedKey(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    `${packageAddress}::channel::Channel`,
    `${packageAddress}::member_cap::MemberCap`,
    "vector<u8>"
  ];
  const parameterNames = ["self", "memberCap", "newEncryptionKeyBytes"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "channel",
    function: "add_encrypted_key",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function addMembers(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    `${packageAddress}::channel::Channel`,
    `${packageAddress}::member_cap::MemberCap`,
    "u64",
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "memberCap", "n", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "channel",
    function: "add_members",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function sendMessage(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    `${packageAddress}::channel::Channel`,
    `${packageAddress}::member_cap::MemberCap`,
    "vector<u8>",
    "vector<u8>",
    `vector<${packageAddress}::attachment::Attachment>`,
    "0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock"
  ];
  const parameterNames = ["self", "memberCap", "ciphertext", "nonce", "attachments", "clock"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "channel",
    function: "send_message",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}

// node_modules/@mysten/messaging/dist/esm/constants.js
var FALLBACK_PACKAGE_ID = "0x984960ebddd75c15c6d38355ac462621db0ffc7d6647214c802cd3b685e1af3d";
var DEFAULT_SEAL_APPROVE_CONTRACT = {
  module: "seal_policies",
  functionName: "seal_approve"
};
var TESTNET_MESSAGING_PACKAGE_CONFIG = {
  packageId: FALLBACK_PACKAGE_ID
};
var MAINNET_MESSAGING_PACKAGE_CONFIG = {
  packageId: FALLBACK_PACKAGE_ID
};

// node_modules/@mysten/messaging/dist/esm/error.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _MessagingAPIError_static;
var generate_fn;
var MessagingClientError = class extends Error {
};
var UserError = class extends MessagingClientError {
};
var _MessagingAPIError = class _MessagingAPIError2 extends MessagingClientError {
  constructor(message, requestId, status) {
    super(message);
    this.requestId = requestId;
    this.status = status;
  }
  static async assertResponse(response, requestId) {
    var _a;
    if (response.ok) {
      return;
    }
    let errorInstance;
    try {
      const text = await response.text();
      const error = JSON.parse(text)["error"];
      const message = JSON.parse(text)["message"];
      errorInstance = __privateMethod(_a = _MessagingAPIError2, _MessagingAPIError_static, generate_fn).call(_a, error, message, requestId);
    } catch {
      errorInstance = new GeneralError(response.statusText, requestId, response.status);
    }
    throw errorInstance;
  }
};
_MessagingAPIError_static = /* @__PURE__ */ new WeakSet();
generate_fn = function(error, message, requestId, status) {
  switch (error) {
    case "NotImplementedFeature":
      return new ApiNotImplementedFeatureError(requestId);
    default:
      return new GeneralError(message, requestId, status);
  }
};
__privateAdd(_MessagingAPIError, _MessagingAPIError_static);
var MessagingAPIError = _MessagingAPIError;
var ApiNotImplementedFeatureError = class extends MessagingAPIError {
  constructor(requestId) {
    super("API: Not implemented yet", requestId);
  }
};
var GeneralError = class extends MessagingAPIError {
};
var NotImplementedFeatureError = class extends UserError {
  constructor() {
    super("SDK: Not implemented yet");
  }
};
function toMajorityError(errors) {
  let maxCount = 0;
  let majorityError = errors[0];
  const counts = /* @__PURE__ */ new Map();
  for (const error of errors) {
    const errorName = error.constructor.name;
    const newCount = (counts.get(errorName) || 0) + 1;
    counts.set(errorName, newCount);
    if (newCount > maxCount) {
      maxCount = newCount;
      majorityError = error;
    }
  }
  return majorityError;
}

// node_modules/@mysten/messaging/dist/esm/storage/adapters/walrus/walrus.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _WalrusStorageAdapter_instances;
var uploadQuilts_fn;
var downloadQuilts_fn;
var extractBlobId_fn;
var extractQuiltsPatchIds_fn;
var WalrusStorageAdapter = class {
  constructor(_client, config) {
    this._client = _client;
    this.config = config;
    __privateAdd2(this, _WalrusStorageAdapter_instances);
  }
  /**
   * Upload data to Walrus storage
   * @param data - Array of data to upload
   * @param _options - Storage options (currently unused)
   * @returns Upload result with blob IDs
   */
  async upload(data, _options) {
    return await __privateMethod2(this, _WalrusStorageAdapter_instances, uploadQuilts_fn).call(this, data);
  }
  /**
   * Download data from Walrus storage
   * @param ids - Array of blob IDs to download
   * @returns Array of downloaded data
   */
  async download(ids) {
    if (ids.length === 0) {
      return [];
    }
    return await __privateMethod2(this, _WalrusStorageAdapter_instances, downloadQuilts_fn).call(this, ids);
  }
};
_WalrusStorageAdapter_instances = /* @__PURE__ */ new WeakSet();
uploadQuilts_fn = async function(data) {
  const formData = new FormData();
  for (let i = 0; i < data.length; i++) {
    const identifier = `attachment${i}`;
    const blob = new Blob([new Uint8Array(data[i])]);
    formData.append(identifier, blob);
  }
  const response = await fetch(
    `${this.config.publisher}/v1/quilts?epochs=${this.config.epochs}`,
    {
      method: "PUT",
      body: formData
    }
  );
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Error response body:", errorText);
    throw new Error(
      `Walrus upload failed: ${response.status} ${response.statusText} - ${errorText}`
    );
  }
  const result = await response.json();
  return { ids: __privateMethod2(this, _WalrusStorageAdapter_instances, extractQuiltsPatchIds_fn).call(this, result) };
};
downloadQuilts_fn = async function(patchIds) {
  const response = await Promise.all(
    patchIds.map(
      async (id) => await fetch(`${this.config.aggregator}/v1/blobs/by-quilt-patch-id/${id}`)
    )
  );
  const data = await Promise.all(response.map(async (response2) => await response2.arrayBuffer()));
  return data.map((data2) => new Uint8Array(data2));
};
extractBlobId_fn = function(response) {
  if (response.newlyCreated?.blobObject?.blobId) {
    return response.newlyCreated.blobObject.blobId;
  }
  if (response.alreadyCertified?.blobId) {
    return response.alreadyCertified.blobId;
  }
  if (response.blobStoreResult?.newlyCreated?.blobObject?.blobId) {
    return response.blobStoreResult.newlyCreated.blobObject.blobId;
  }
  throw new Error("Unable to extract blob ID from response");
};
extractQuiltsPatchIds_fn = function(response) {
  if (response.storedQuiltBlobs) {
    return response.storedQuiltBlobs.map((quilt) => quilt.quiltPatchId);
  }
  throw new Error("Unable to extract quilt patch IDs from response");
};

// node_modules/@mysten/messaging/dist/esm/encryption/constants.js
var ENCRYPTION_PRIMITIVES_CONFIG = {
  keySize: 256,
  nonceSize: 12,
  dekAlgorithm: "AES-GCM"
};

// node_modules/@mysten/messaging/dist/esm/encryption/webCryptoPrimitives.js
var WebCryptoPrimitives = class _WebCryptoPrimitives {
  constructor(config) {
    this.config = config;
  }
  static getInstance(config) {
    if (!_WebCryptoPrimitives.instance) {
      _WebCryptoPrimitives.instance = new _WebCryptoPrimitives(
        config ?? ENCRYPTION_PRIMITIVES_CONFIG
      );
    }
    return _WebCryptoPrimitives.instance;
  }
  // ===== Key methods =====
  /**
   * Generate a cryptographically secure random Data Encryption Key
   * @param length - Optional key length
   * @returns Random DEK bytes
   */
  async generateDEK(length) {
    switch (this.config.dekAlgorithm) {
      case "AES-GCM": {
        const dek = await crypto.subtle.generateKey(
          { name: this.config.dekAlgorithm, length: length ?? this.config.keySize },
          true,
          ["encrypt", "decrypt"]
        );
        return await crypto.subtle.exportKey("raw", dek).then((dekData) => new Uint8Array(dekData));
      }
      default:
        throw new MessagingClientError("Unsupported Data Encryption Key algorithm");
    }
  }
  /**
   * Generate a cryptographically secure nonce
   * @param length - Optional nonce length
   * @returns Random nonce bytes
   */
  generateNonce(length) {
    return crypto.getRandomValues(new Uint8Array(length ?? this.config.nonceSize));
  }
  // ===== Encryption methods =====
  /**
   * Encrypt bytes using a Data Encryption Key and nonce
   * @param key - The encryption key
   * @param nonce - The encryption nonce
   * @param aad - Additional authenticated data
   * @param bytesToEncrypt - The bytes to encrypt
   * @returns Encrypted bytes
   */
  async encryptBytes(key, nonce, aad, bytesToEncrypt) {
    switch (this.config.dekAlgorithm) {
      case "AES-GCM": {
        const importedDEK = await crypto.subtle.importKey(
          "raw",
          key,
          { name: this.config.dekAlgorithm },
          false,
          ["encrypt"]
        );
        return await crypto.subtle.encrypt(
          {
            name: this.config.dekAlgorithm,
            iv: nonce,
            additionalData: aad
          },
          importedDEK,
          bytesToEncrypt
        ).then((encryptedData) => new Uint8Array(encryptedData));
      }
      default:
        throw new MessagingClientError("Unsupported encryption algorithm");
    }
  }
  /**
   * Decrypt bytes using a Data Encryption Key and nonce
   * @param key - The decryption key
   * @param nonce - The decryption nonce
   * @param aad - Additional authenticated data
   * @param encryptedBytes - The bytes to decrypt
   * @returns Decrypted bytes
   */
  async decryptBytes(key, nonce, aad, encryptedBytes) {
    switch (this.config.dekAlgorithm) {
      case "AES-GCM": {
        const importedDEK = await crypto.subtle.importKey(
          "raw",
          key,
          { name: this.config.dekAlgorithm },
          false,
          ["decrypt"]
        );
        return await crypto.subtle.decrypt(
          {
            name: this.config.dekAlgorithm,
            iv: nonce,
            additionalData: aad
          },
          importedDEK,
          encryptedBytes
        ).then((decryptedData) => new Uint8Array(decryptedData));
      }
      default:
        throw new MessagingClientError("Unsupported encryption algorithm");
    }
  }
};

// node_modules/@mysten/messaging/dist/esm/encryption/sessionKeyManager.js
var SessionKeyManager = class {
  constructor(sessionKey, sessionKeyConfig, suiClient, sealApproveContract) {
    this.sessionKey = sessionKey;
    this.sessionKeyConfig = sessionKeyConfig;
    this.suiClient = suiClient;
    this.sealApproveContract = sealApproveContract;
    if (!sessionKey && !sessionKeyConfig) {
      throw new Error("Either sessionKey or sessionKeyConfig must be provided");
    }
    if (sessionKey && sessionKeyConfig) {
      throw new Error("Cannot provide both sessionKey and sessionKeyConfig. Choose one.");
    }
  }
  /**
   * Get a valid SessionKey instance
   */
  async getSessionKey() {
    if (this.sessionKey) {
      if (this.sessionKey.isExpired()) {
        throw new Error(
          "The provided SessionKey has expired. Please provide a new SessionKey instance. When using an external SessionKey, lifecycle management is your responsibility."
        );
      }
      return this.sessionKey;
    }
    if (this.sessionKeyConfig) {
      if (this.managedSessionKey && !this.managedSessionKey.isExpired()) {
        return this.managedSessionKey;
      }
      this.managedSessionKey = await SessionKey.create({
        address: this.sessionKeyConfig.address,
        signer: this.sessionKeyConfig.signer,
        ttlMin: this.sessionKeyConfig.ttlMin,
        mvrName: this.sessionKeyConfig.mvrName,
        packageId: this.sealApproveContract.packageId,
        suiClient: this.suiClient
      });
      return this.managedSessionKey;
    }
    throw new Error("Invalid SessionKeyManager state");
  }
  /**
   * Update the external SessionKey instance
   */
  updateExternalSessionKey(newSessionKey) {
    if (!this.sessionKey) {
      throw new Error("Cannot update external SessionKey when using managed SessionKey");
    }
    this.sessionKey = newSessionKey;
  }
  /**
   * Force refresh the managed SessionKey
   */
  async refreshManagedSessionKey() {
    if (!this.sessionKeyConfig) {
      throw new Error("Cannot refresh managed SessionKey when using external SessionKey");
    }
    this.managedSessionKey = void 0;
    return this.getSessionKey();
  }
};

// node_modules/@mysten/messaging/dist/esm/encryption/envelopeEncryption.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _suiClient;
var _encryptionPrimitives;
var _sessionKeyManager;
var _sealApproveContract;
var _sealConfig;
var EnvelopeEncryption = class {
  constructor(config) {
    __privateAdd3(this, _suiClient);
    __privateAdd3(this, _encryptionPrimitives);
    __privateAdd3(this, _sessionKeyManager);
    __privateAdd3(this, _sealApproveContract);
    __privateAdd3(this, _sealConfig);
    __privateSet(this, _suiClient, config.suiClient);
    __privateSet(this, _sealApproveContract, config.sealApproveContract);
    __privateSet(this, _sealConfig, {
      threshold: config.sealConfig?.threshold ?? 2
    });
    __privateSet(this, _encryptionPrimitives, config.encryptionPrimitives ?? WebCryptoPrimitives.getInstance());
    __privateSet(this, _sessionKeyManager, new SessionKeyManager(
      config.sessionKey,
      config.sessionKeyConfig,
      __privateGet(this, _suiClient),
      __privateGet(this, _sealApproveContract)
    ));
  }
  /**
   * Update the external SessionKey instance (useful for React context updates)
   */
  updateSessionKey(newSessionKey) {
    __privateGet(this, _sessionKeyManager).updateExternalSessionKey(newSessionKey);
  }
  /**
   * Force refresh the managed SessionKey (useful for testing or manual refresh)
   */
  async refreshSessionKey() {
    return __privateGet(this, _sessionKeyManager).refreshManagedSessionKey();
  }
  // ===== Encryption methods =====
  /**
   * Generate encrypted channel data encryption key
   * @param channelId - The channel ID
   * @returns Encrypted DEK bytes
   */
  async generateEncryptedChannelDEK({
    channelId
  }) {
    if (!isValidSuiObjectId(channelId)) {
      throw new Error("The channelId provided is not a valid Sui Object ID");
    }
    const dek = await __privateGet(this, _encryptionPrimitives).generateDEK();
    const nonce = __privateGet(this, _encryptionPrimitives).generateNonce();
    const sealPolicyBytes = fromHex(channelId);
    const id = toHex(new Uint8Array([...sealPolicyBytes, ...nonce]));
    const { encryptedObject: encryptedDekBytes } = await __privateGet(this, _suiClient).seal.encrypt({
      threshold: __privateGet(this, _sealConfig).threshold,
      packageId: __privateGet(this, _sealApproveContract).packageId,
      id,
      data: dek
    });
    return new Uint8Array(encryptedDekBytes);
  }
  /**
   * Generate a random nonce
   * @returns Random nonce bytes
   */
  generateNonce() {
    return __privateGet(this, _encryptionPrimitives).generateNonce();
  }
  /**
   * Encrypt text message
   * @param text - The text to encrypt
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Encrypted payload with ciphertext and nonce
   */
  async encryptText({
    text,
    channelId,
    sender,
    encryptedKey,
    memberCapId
  }) {
    const nonce = __privateGet(this, _encryptionPrimitives).generateNonce();
    const dek = await this.decryptChannelDEK({
      encryptedKey,
      channelId,
      memberCapId
    });
    const ciphertext = await __privateGet(this, _encryptionPrimitives).encryptBytes(
      dek.bytes,
      nonce,
      this.encryptionAAD(channelId, dek.version, sender),
      new Uint8Array(new TextEncoder().encode(text))
    );
    return {
      encryptedBytes: ciphertext,
      nonce
    };
  }
  /**
   * Decrypt text message
   * @param encryptedBytes - The encrypted text bytes
   * @param nonce - The encryption nonce
   * @param channelId - The channel ID
   * @param encryptedKey - The encrypted symmetric key
   * @param sender - The sender address
   * @param memberCapId - The member cap ID
   * @returns Decrypted text string
   */
  async decryptText({
    encryptedBytes: ciphertext,
    nonce,
    channelId,
    encryptedKey,
    sender,
    memberCapId
  }) {
    const dek = await this.decryptChannelDEK({
      encryptedKey,
      channelId,
      memberCapId
    });
    const decryptedBytes = await __privateGet(this, _encryptionPrimitives).decryptBytes(
      dek.bytes,
      nonce,
      this.encryptionAAD(channelId, encryptedKey.version, sender),
      ciphertext
    );
    return new TextDecoder().decode(decryptedBytes);
  }
  /**
   * Encrypt attachment file and metadata
   * @param file - The file to encrypt
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Encrypted attachment payload with data and metadata
   */
  async encryptAttachment({
    file,
    channelId,
    sender,
    encryptedKey,
    memberCapId
  }) {
    const { encryptedBytes: encryptedData, nonce: dataNonce } = await this.encryptAttachmentData({
      file,
      channelId,
      sender,
      encryptedKey,
      memberCapId
    });
    const { encryptedBytes: encryptedMetadata, nonce: metadataNonce } = await this.encryptAttachmentMetadata({
      file,
      channelId,
      sender,
      encryptedKey,
      memberCapId
    });
    return {
      data: { encryptedBytes: encryptedData, nonce: dataNonce },
      metadata: { encryptedBytes: encryptedMetadata, nonce: metadataNonce }
    };
  }
  /**
   * Encrypt attachment file data
   * @param file - The file to encrypt
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Encrypted payload with data and nonce
   */
  async encryptAttachmentData({
    file,
    channelId,
    sender,
    encryptedKey,
    memberCapId
  }) {
    const dek = await this.decryptChannelDEK({
      encryptedKey,
      channelId,
      memberCapId
    });
    const nonce = this.generateNonce();
    const fileData = await file.arrayBuffer();
    const encryptedData = await __privateGet(this, _encryptionPrimitives).encryptBytes(
      dek.bytes,
      nonce,
      this.encryptionAAD(channelId, dek.version, sender),
      new Uint8Array(fileData)
    );
    return { encryptedBytes: encryptedData, nonce };
  }
  /**
   * Encrypt attachment metadata
   * @param file - The file to get metadata from
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Encrypted payload with metadata and nonce
   */
  async encryptAttachmentMetadata({
    channelId,
    sender,
    encryptedKey,
    memberCapId,
    file
  }) {
    const dek = await this.decryptChannelDEK({
      encryptedKey,
      channelId,
      memberCapId
    });
    const nonce = this.generateNonce();
    const metadata = {
      fileName: file.name,
      mimeType: file.type,
      fileSize: file.size
    };
    const metadataStr = JSON.stringify(metadata);
    const encryptedMetadata = await __privateGet(this, _encryptionPrimitives).encryptBytes(
      dek.bytes,
      nonce,
      this.encryptionAAD(channelId, dek.version, sender),
      new Uint8Array(new TextEncoder().encode(metadataStr))
    );
    return {
      encryptedBytes: encryptedMetadata,
      nonce
    };
  }
  /**
   * Decrypt attachment metadata
   * @param encryptedBytes - The encrypted metadata bytes
   * @param nonce - The encryption nonce
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Decrypted attachment metadata
   */
  async decryptAttachmentMetadata({
    channelId,
    sender,
    encryptedKey,
    memberCapId,
    encryptedBytes,
    nonce
  }) {
    const dek = await this.decryptChannelDEK({
      encryptedKey,
      channelId,
      memberCapId
    });
    const decryptedMetadataBytes = await __privateGet(this, _encryptionPrimitives).decryptBytes(
      dek.bytes,
      nonce,
      this.encryptionAAD(channelId, dek.version, sender),
      encryptedBytes
    );
    const metadataStr = new TextDecoder().decode(decryptedMetadataBytes);
    const { fileName, mimeType, fileSize } = JSON.parse(metadataStr);
    return {
      fileName,
      mimeType,
      fileSize
    };
  }
  /**
   * Decrypt attachment file data
   * @param encryptedBytes - The encrypted data bytes
   * @param nonce - The encryption nonce
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Decrypted attachment data
   */
  async decryptAttachmentData({
    channelId,
    sender,
    encryptedKey,
    memberCapId,
    encryptedBytes,
    nonce
  }) {
    const dek = await this.decryptChannelDEK({
      encryptedKey,
      channelId,
      memberCapId
    });
    const decryptedData = await __privateGet(this, _encryptionPrimitives).decryptBytes(
      dek.bytes,
      nonce,
      this.encryptionAAD(channelId, dek.version, sender),
      encryptedBytes
    );
    return { data: decryptedData };
  }
  /**
   * Decrypt attachment file and metadata
   * @param data - The encrypted data payload
   * @param metadata - The encrypted metadata payload
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Decrypted attachment with data and metadata
   */
  async decryptAttachment({
    channelId,
    sender,
    encryptedKey,
    memberCapId,
    data,
    metadata
  }) {
    const decryptedData = await this.decryptAttachmentData({
      channelId,
      sender,
      encryptedKey,
      memberCapId,
      encryptedBytes: data.encryptedBytes,
      nonce: data.nonce
    });
    const { fileName, mimeType, fileSize } = await this.decryptAttachmentMetadata({
      channelId,
      sender,
      encryptedKey,
      memberCapId,
      encryptedBytes: metadata.encryptedBytes,
      nonce: metadata.nonce
    });
    return {
      data: decryptedData.data,
      fileName,
      mimeType,
      fileSize
    };
  }
  /**
   * Encrypt message text and attachments
   * @param text - The message text
   * @param attachments - Optional file attachments
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Encrypted message payload
   */
  async encryptMessage({
    text,
    attachments,
    channelId,
    sender,
    encryptedKey,
    memberCapId
  }) {
    const { encryptedBytes: ciphertext, nonce } = await this.encryptText({
      text,
      channelId,
      sender,
      encryptedKey,
      memberCapId
    });
    if (!attachments || attachments.length === 0) {
      return { text: { encryptedBytes: ciphertext, nonce } };
    }
    const encryptedAttachments = await Promise.all(
      attachments.map(
        (file) => this.encryptAttachment({
          file,
          channelId,
          sender,
          encryptedKey,
          memberCapId
        })
      )
    );
    return {
      text: { encryptedBytes: ciphertext, nonce },
      attachments: encryptedAttachments
    };
  }
  /**
   * Decrypt message text and attachments
   * @param ciphertext - The encrypted text bytes
   * @param nonce - The encryption nonce
   * @param attachments - Optional encrypted attachments
   * @param channelId - The channel ID
   * @param sender - The sender address
   * @param encryptedKey - The encrypted symmetric key
   * @param memberCapId - The member cap ID
   * @returns Decrypted message with text and attachments
   */
  async decryptMessage({
    ciphertext,
    nonce,
    attachments,
    channelId,
    sender,
    encryptedKey,
    memberCapId
  }) {
    const text = await this.decryptText({
      encryptedBytes: ciphertext,
      nonce,
      channelId,
      sender,
      encryptedKey,
      memberCapId
    });
    if (!attachments || attachments.length === 0) {
      return { text };
    }
    const decryptedAttachments = await Promise.all(
      attachments.map(
        (attachment) => this.decryptAttachment({
          ...attachment,
          channelId,
          sender,
          encryptedKey,
          memberCapId
        })
      )
    );
    return {
      text,
      attachments: decryptedAttachments
    };
  }
  /**
   * Decrypt encrypted channel data encryption key using Seal
   * @param encryptedKey - The encrypted symmetric key
   * @param channelId - The channel ID
   * @param memberCapId - The member cap ID
   * @returns Decrypted symmetric key
   */
  async decryptChannelDEK({
    encryptedKey,
    channelId,
    memberCapId
  }) {
    if (!isValidSuiObjectId(channelId)) {
      throw new Error("The channelId provided is not a valid Sui Object ID");
    }
    if (!isValidSuiObjectId(memberCapId)) {
      throw new Error("The memberCapId provided is not a valid Sui Object ID");
    }
    const channelIdBytes = EncryptedObject.parse(encryptedKey.encryptedBytes).id;
    const tx = new Transaction();
    tx.moveCall({
      target: `${__privateGet(this, _sealApproveContract).packageId}::${__privateGet(this, _sealApproveContract).module}::${__privateGet(this, _sealApproveContract).functionName}`,
      arguments: [
        // Seal Identity Bytes: Channel object ID
        // key form: [packageId][channelId][random nonce]
        tx.pure.vector("u8", fromHex(channelIdBytes)),
        // Channel Object
        tx.object(channelId),
        // Member Cap Object
        tx.object(memberCapId)
      ]
    });
    const txBytes = await tx.build({ client: __privateGet(this, _suiClient), onlyTransactionKind: true });
    let dekBytes;
    try {
      dekBytes = await __privateGet(this, _suiClient).seal.decrypt({
        data: encryptedKey.encryptedBytes,
        sessionKey: await __privateGet(this, _sessionKeyManager).getSessionKey(),
        txBytes
      });
    } catch (error) {
      console.error("Error decrypting channel DEK", error);
      throw error;
    }
    return {
      $kind: "Unencrypted",
      bytes: new Uint8Array(dekBytes || new Uint8Array()),
      version: encryptedKey.version
    };
  }
  // ===== Private methods =====
  /**
   * Get Additional Authenticated Data for encryption/decryption
   * @param channelId - The channel ID
   * @param keyVersion - The key version
   * @param sender - The sender address
   * @returns AAD bytes
   */
  encryptionAAD(channelId, keyVersion, sender) {
    return new Uint8Array(new TextEncoder().encode(channelId + keyVersion.toString() + sender));
  }
};
_suiClient = /* @__PURE__ */ new WeakMap();
_encryptionPrimitives = /* @__PURE__ */ new WeakMap();
_sessionKeyManager = /* @__PURE__ */ new WeakMap();
_sealApproveContract = /* @__PURE__ */ new WeakMap();
_sealConfig = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/creator_cap.js
var $moduleName13 = "@local-pkg/sui-stack-messaging::creator_cap";
var CreatorCap = new MoveStruct({
  name: `${$moduleName13}::CreatorCap`,
  fields: {
    id: UID,
    channel_id: suiBcs.Address
  }
});
function transferToSender(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [`${packageAddress}::creator_cap::CreatorCap`];
  const parameterNames = ["self"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "creator_cap",
    function: "transfer_to_sender",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/member_cap.js
var $moduleName14 = "@local-pkg/sui-stack-messaging::member_cap";
var MemberCap = new MoveStruct({
  name: `${$moduleName14}::MemberCap`,
  fields: {
    id: UID,
    channel_id: suiBcs.Address
  }
});
function transferToRecipient(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    `${packageAddress}::member_cap::MemberCap`,
    `${packageAddress}::creator_cap::CreatorCap`,
    "address"
  ];
  const parameterNames = ["cap", "creatorCap", "recipient"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "member_cap",
    function: "transfer_to_recipient",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}
function transferMemberCaps(options) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  const argumentsTypes = [
    "vector<address>",
    `vector<${packageAddress}::member_cap::MemberCap>`,
    `${packageAddress}::creator_cap::CreatorCap`
  ];
  const parameterNames = ["memberAddresses", "memberCaps", "creatorCap"];
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "member_cap",
    function: "transfer_member_caps",
    arguments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames)
  });
}

// node_modules/@mysten/messaging/dist/esm/contracts/sui_stack_messaging/config.js
var $moduleName15 = "@local-pkg/sui-stack-messaging::config";
var EditConfig = new MoveTuple({
  name: `${$moduleName15}::EditConfig`,
  fields: [suiBcs.bool()]
});
var Config = new MoveStruct({
  name: `${$moduleName15}::Config`,
  fields: {
    max_channel_members: suiBcs.u64(),
    max_channel_roles: suiBcs.u64(),
    max_message_text_chars: suiBcs.u64(),
    max_message_attachments: suiBcs.u64(),
    require_invitation: suiBcs.bool(),
    require_request: suiBcs.bool(),
    emit_events: suiBcs.bool()
  }
});
function none(options = {}) {
  const packageAddress = options.package ?? "@local-pkg/sui-stack-messaging";
  return (tx) => tx.moveCall({
    package: packageAddress,
    module: "config",
    function: "none"
  });
}

// node_modules/@mysten/messaging/dist/esm/client.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
var _suiClient2;
var _packageConfig;
var _storage;
var _envelopeEncryption;
var _sealConfig2;
var _SuiStackMessagingClient_instances;
var getUserMemberCapId_fn;
var getEncryptionKeyFromChannel_fn;
var decryptMessage_fn;
var createAttachmentsVec_fn;
var executeTransaction_fn;
var getGeneratedCaps_fn;
var deriveMessageIDsFromRange_fn;
var parseMessageObjects_fn;
var createLazyAttachmentDataPromise_fn;
var calculateFetchRange_fn;
var fetchMessagesInRange_fn;
var determineNextPagination_fn;
var createEmptyMessagesResponse_fn;
var getObjectContents_fn;
var _SuiStackMessagingClient = class _SuiStackMessagingClient2 {
  // TODO: Leave the responsibility of caching to the caller
  // #encryptedChannelDEKCache: Map<string, EncryptedSymmetricKey> = new Map(); // channelId --> EncryptedSymmetricKey
  // #channelMessagesTableIdCache: Map<string, string> = new Map<string, string>(); // channelId --> messagesTableId
  constructor(options) {
    this.options = options;
    __privateAdd4(this, _SuiStackMessagingClient_instances);
    __privateAdd4(this, _suiClient2);
    __privateAdd4(this, _packageConfig);
    __privateAdd4(this, _storage);
    __privateAdd4(this, _envelopeEncryption);
    __privateAdd4(this, _sealConfig2);
    __privateSet2(this, _suiClient2, options.suiClient);
    __privateSet2(this, _storage, options.storage);
    __privateSet2(this, _sealConfig2, {
      threshold: options.sealConfig?.threshold ?? 2
      // Default threshold of 2
    });
    if (!options.packageConfig) {
      const network = __privateGet2(this, _suiClient2).network;
      switch (network) {
        case "testnet":
          __privateSet2(this, _packageConfig, TESTNET_MESSAGING_PACKAGE_CONFIG);
          break;
        case "mainnet":
          __privateSet2(this, _packageConfig, MAINNET_MESSAGING_PACKAGE_CONFIG);
          break;
        default:
          __privateSet2(this, _packageConfig, TESTNET_MESSAGING_PACKAGE_CONFIG);
          break;
      }
    } else {
      __privateSet2(this, _packageConfig, options.packageConfig);
    }
    const sealApproveContract = __privateGet2(this, _packageConfig).sealApproveContract ?? {
      packageId: __privateGet2(this, _packageConfig).packageId,
      ...DEFAULT_SEAL_APPROVE_CONTRACT
    };
    __privateSet2(this, _envelopeEncryption, new EnvelopeEncryption({
      suiClient: __privateGet2(this, _suiClient2),
      sealApproveContract,
      sessionKey: options.sessionKey,
      sessionKeyConfig: options.sessionKeyConfig,
      sealConfig: __privateGet2(this, _sealConfig2)
    }));
  }
  static experimental_asClientExtension(options) {
    return {
      name: "messaging",
      register: (client) => {
        const sealClient = client.seal;
        if (!sealClient) {
          throw new MessagingClientError("SealClient extension is required for MessagingClient");
        }
        if (!("storage" in options) && !("walrusStorageConfig" in options)) {
          throw new MessagingClientError(
            'Either a custom storage adapter via "storage" option or explicit Walrus storage configuration via "walrusStorageConfig" option must be provided. Fallback to default Walrus endpoints is not supported.'
          );
        }
        let packageConfig = options.packageConfig;
        if (!packageConfig) {
          const network = client.network;
          switch (network) {
            case "testnet":
              packageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;
              break;
            case "mainnet":
              packageConfig = MAINNET_MESSAGING_PACKAGE_CONFIG;
              break;
            default:
              packageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;
              break;
          }
        }
        const storage = "storage" in options ? (c) => options.storage(c) : (c) => {
          return new WalrusStorageAdapter(c, options.walrusStorageConfig);
        };
        return new _SuiStackMessagingClient2({
          suiClient: client,
          storage,
          packageConfig,
          sessionKey: "sessionKey" in options ? options.sessionKey : void 0,
          sessionKeyConfig: "sessionKeyConfig" in options ? options.sessionKeyConfig : void 0,
          sealConfig: options.sealConfig
        });
      }
    };
  }
  // ===== Read Path =====
  /**
   * Get channel memberships for a user
   * @param request - Pagination and filter options
   * @returns Channel memberships with pagination info
   */
  async getChannelMemberships(request) {
    const memberCapsRes = await __privateGet2(this, _suiClient2).core.getOwnedObjects({
      ...request,
      type: MemberCap.name.replace("@local-pkg/sui-stack-messaging", __privateGet2(this, _packageConfig).packageId)
    });
    const validObjects = memberCapsRes.objects.filter(
      (object) => !(object instanceof Error)
    );
    if (validObjects.length === 0) {
      return {
        hasNextPage: memberCapsRes.hasNextPage,
        cursor: memberCapsRes.cursor,
        memberships: []
      };
    }
    const contents = await __privateMethod3(this, _SuiStackMessagingClient_instances, getObjectContents_fn).call(this, validObjects);
    const memberships = await Promise.all(
      contents.map(async (content) => {
        const parsedMemberCap = MemberCap.parse(content);
        return { member_cap_id: parsedMemberCap.id.id, channel_id: parsedMemberCap.channel_id };
      })
    );
    return {
      hasNextPage: memberCapsRes.hasNextPage,
      cursor: memberCapsRes.cursor,
      memberships
    };
  }
  /**
   * Get channel objects for a user (returns decrypted data)
   * @param request - Pagination and filter options
   * @returns Decrypted channel objects with pagination info
   */
  async getChannelObjectsByAddress(request) {
    const membershipsPaginated = await this.getChannelMemberships(request);
    const channelObjects = await this.getChannelObjectsByChannelIds({
      channelIds: membershipsPaginated.memberships.map((m) => m.channel_id),
      userAddress: request.address,
      memberCapIds: membershipsPaginated.memberships.map((m) => m.member_cap_id)
    });
    return {
      hasNextPage: membershipsPaginated.hasNextPage,
      cursor: membershipsPaginated.cursor,
      channelObjects
    };
  }
  /**
   * Get channel objects by channel IDs (returns decrypted data)
   * @param request - Request with channel IDs and user address, and optionally memberCapIds
   * @returns Decrypted channel objects
   */
  async getChannelObjectsByChannelIds(request) {
    const { channelIds, userAddress, memberCapIds } = request;
    const channelObjectsRes = await __privateGet2(this, _suiClient2).core.getObjects({
      objectIds: channelIds
    });
    const parsedChannels = await Promise.all(
      channelObjectsRes.objects.map(async (object) => {
        if (object instanceof Error || !object.content) {
          throw new MessagingClientError(`Failed to parse Channel object: ${object}`);
        }
        return Channel.parse(await object.content);
      })
    );
    const decryptedChannels = await Promise.all(
      parsedChannels.map(async (channel, index) => {
        const decryptedChannel = {
          ...channel,
          last_message: null
        };
        if (channel.last_message) {
          try {
            const memberCapId = memberCapIds?.[index] || await __privateMethod3(this, _SuiStackMessagingClient_instances, getUserMemberCapId_fn).call(this, userAddress, channel.id.id);
            const encryptedKey = await __privateMethod3(this, _SuiStackMessagingClient_instances, getEncryptionKeyFromChannel_fn).call(this, channel);
            const decryptedMessage = await __privateMethod3(this, _SuiStackMessagingClient_instances, decryptMessage_fn).call(this, channel.last_message, channel.id.id, memberCapId, encryptedKey);
            decryptedChannel.last_message = decryptedMessage;
          } catch (error) {
            console.warn(`Failed to decrypt last message for channel ${channel.id.id}:`, error);
            decryptedChannel.last_message = null;
          }
        }
        return decryptedChannel;
      })
    );
    return decryptedChannels;
  }
  /**
   * Get all members of a channel
   * @param channelId - The channel ID
   * @returns Channel members with addresses and member cap IDs
   */
  async getChannelMembers(channelId) {
    const channelObjectsRes = await __privateGet2(this, _suiClient2).core.getObjects({
      objectIds: [channelId]
    });
    const channelObject = channelObjectsRes.objects[0];
    if (channelObject instanceof Error || !channelObject.content) {
      throw new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);
    }
    const channel = Channel.parse(await channelObject.content);
    const memberCapIds = channel.auth.member_permissions.contents.map((entry) => entry.key);
    if (memberCapIds.length === 0) {
      return { members: [] };
    }
    const memberCapObjects = await __privateGet2(this, _suiClient2).core.getObjects({
      objectIds: memberCapIds
    });
    const members = [];
    for (const obj of memberCapObjects.objects) {
      if (obj instanceof Error || !obj.content) {
        console.warn("Failed to fetch MemberCap object:", obj);
        continue;
      }
      try {
        const memberCap = MemberCap.parse(await obj.content);
        if (obj.owner) {
          let memberAddress;
          if (obj.owner.$kind === "AddressOwner") {
            memberAddress = obj.owner.AddressOwner;
          } else if (obj.owner.$kind === "ObjectOwner") {
            console.warn("MemberCap is object-owned, skipping:", memberCap.id.id);
            continue;
          } else {
            console.warn("MemberCap has unknown ownership type:", obj.owner);
            continue;
          }
          members.push({
            memberAddress,
            memberCapId: memberCap.id.id
          });
        }
      } catch (error) {
        console.warn("Failed to parse MemberCap object:", error);
      }
    }
    return { members };
  }
  /**
   * Get messages from a channel with pagination (returns decrypted messages)
   * @param request - Request parameters including channelId, userAddress, cursor, limit, and direction
   * @returns Decrypted messages with pagination info
   */
  async getChannelMessages({
    channelId,
    userAddress,
    cursor = null,
    limit = 50,
    direction = "backward"
  }) {
    const channelObjectsRes = await __privateGet2(this, _suiClient2).core.getObjects({
      objectIds: [channelId]
    });
    const channelObject = channelObjectsRes.objects[0];
    if (channelObject instanceof Error || !channelObject.content) {
      throw new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);
    }
    const channel = Channel.parse(await channelObject.content);
    const messagesTableId = channel.messages.contents.id.id;
    const totalMessagesCount = BigInt(channel.messages_count);
    if (totalMessagesCount === BigInt(0)) {
      return __privateMethod3(this, _SuiStackMessagingClient_instances, createEmptyMessagesResponse_fn).call(this, direction);
    }
    if (cursor !== null && cursor >= totalMessagesCount) {
      throw new MessagingClientError(
        `Cursor ${cursor} is out of bounds. Channel has ${totalMessagesCount} messages.`
      );
    }
    const fetchRange = __privateMethod3(this, _SuiStackMessagingClient_instances, calculateFetchRange_fn).call(this, {
      cursor,
      limit,
      direction,
      totalMessagesCount
    });
    if (fetchRange.startIndex >= fetchRange.endIndex) {
      return __privateMethod3(this, _SuiStackMessagingClient_instances, createEmptyMessagesResponse_fn).call(this, direction);
    }
    const rawMessages = await __privateMethod3(this, _SuiStackMessagingClient_instances, fetchMessagesInRange_fn).call(this, messagesTableId, fetchRange);
    const memberCapId = await __privateMethod3(this, _SuiStackMessagingClient_instances, getUserMemberCapId_fn).call(this, userAddress, channelId);
    const encryptedKey = await __privateMethod3(this, _SuiStackMessagingClient_instances, getEncryptionKeyFromChannel_fn).call(this, channel);
    const decryptedMessages = await Promise.all(
      rawMessages.map(async (message) => {
        try {
          return await __privateMethod3(this, _SuiStackMessagingClient_instances, decryptMessage_fn).call(this, message, channelId, memberCapId, encryptedKey);
        } catch (error) {
          console.warn(`Failed to decrypt message in channel ${channelId}:`, error);
          return {
            text: "[Failed to decrypt message]",
            sender: message.sender,
            createdAtMs: message.created_at_ms,
            attachments: []
          };
        }
      })
    );
    const nextPagination = __privateMethod3(this, _SuiStackMessagingClient_instances, determineNextPagination_fn).call(this, {
      fetchRange,
      direction,
      totalMessagesCount
    });
    return {
      messages: decryptedMessages,
      cursor: nextPagination.cursor,
      hasNextPage: nextPagination.hasNextPage,
      direction
    };
  }
  /**
   * Get new messages since last polling state (returns decrypted messages)
   * @param request - Request with channelId, userAddress, pollingState, and limit
   * @returns New decrypted messages since last poll
   */
  async getLatestMessages({
    channelId,
    userAddress,
    pollingState,
    limit = 50
  }) {
    const channelObjectsRes = await __privateGet2(this, _suiClient2).core.getObjects({
      objectIds: [channelId]
    });
    const channelObject = channelObjectsRes.objects[0];
    if (channelObject instanceof Error || !channelObject.content) {
      throw new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);
    }
    const channel = Channel.parse(await channelObject.content);
    const latestMessageCount = BigInt(channel.messages_count);
    const newMessagesCount = latestMessageCount - pollingState.lastMessageCount;
    if (newMessagesCount === BigInt(0)) {
      return {
        messages: [],
        cursor: pollingState.lastCursor,
        hasNextPage: pollingState.lastCursor !== null,
        direction: "backward"
      };
    }
    const fetchLimit = Math.min(Number(newMessagesCount), limit);
    const response = await this.getChannelMessages({
      channelId,
      userAddress,
      cursor: pollingState.lastCursor,
      limit: fetchLimit,
      direction: "backward"
    });
    return response;
  }
  // ===== Write Path =====
  /**
   * Create a channel creation flow
   *
   * @usage
   * ```
   * const flow = client.createChannelFlow();
   *
   * // Step-by-step execution
   * // 1. build
   * const tx = flow.build();
   * // 2. getGeneratedCaps
   * const { creatorCap, creatorMemberCap, additionalMemberCaps } = await flow.getGeneratedCaps({ digest });
   * // 3. generateAndAttachEncryptionKey
   * const { transaction, creatorCap, encryptedKeyBytes } = await flow.generateAndAttachEncryptionKey({ creatorCap, creatorMemberCap });
   * // 4. getGeneratedEncryptionKey
   * const { channelId, encryptedKeyBytes } = await flow.getGeneratedEncryptionKey({ creatorCap, encryptedKeyBytes });
   * ```
   *
   * @param opts - Options including creator address and initial members
   * @returns Channel creation flow with step-by-step methods
   */
  createChannelFlow({
    creatorAddress,
    initialMemberAddresses
  }) {
    const build = () => {
      const tx = new Transaction();
      const config = tx.add(none());
      const [channel, creatorCap, creatorMemberCap] = tx.add(_new2({ arguments: { config } }));
      let memberCaps = null;
      if (initialMemberAddresses && initialMemberAddresses.length > 0) {
        memberCaps = tx.add(
          addMembers({
            arguments: {
              self: channel,
              memberCap: creatorMemberCap,
              n: initialMemberAddresses.length
            }
          })
        );
      }
      tx.add(share({ arguments: { self: channel, creatorCap } }));
      tx.add(
        transferToRecipient({
          arguments: { cap: creatorMemberCap, creatorCap, recipient: creatorAddress }
        })
      );
      if (memberCaps !== null) {
        tx.add(
          transferMemberCaps({
            arguments: {
              memberAddresses: tx.pure.vector("address", initialMemberAddresses),
              memberCaps,
              creatorCap
            }
          })
        );
      }
      tx.add(transferToSender({ arguments: { self: creatorCap } }));
      return tx;
    };
    const getGeneratedCaps = async ({ digest }) => {
      return await __privateMethod3(this, _SuiStackMessagingClient_instances, getGeneratedCaps_fn).call(this, digest);
    };
    const generateAndAttachEncryptionKey = async ({
      creatorCap,
      creatorMemberCap
    }) => {
      const encryptedKeyBytes = await __privateGet2(this, _envelopeEncryption).generateEncryptedChannelDEK({
        channelId: creatorCap.channel_id
      });
      const tx = new Transaction();
      tx.add(
        addEncryptedKey({
          arguments: {
            self: tx.object(creatorCap.channel_id),
            memberCap: tx.object(creatorMemberCap.id.id),
            newEncryptionKeyBytes: tx.pure.vector("u8", encryptedKeyBytes)
          }
        })
      );
      return {
        transaction: tx,
        creatorCap,
        encryptedKeyBytes
      };
    };
    const getGeneratedEncryptionKey = ({
      creatorCap,
      encryptedKeyBytes
    }) => {
      return { channelId: creatorCap.channel_id, encryptedKeyBytes };
    };
    const stepResults = {};
    function getResults(step, current) {
      if (!stepResults[step]) {
        throw new Error(`${String(step)} must be executed before calling ${String(current)}`);
      }
      return stepResults[step];
    }
    return {
      build: () => {
        if (!stepResults.build) {
          stepResults.build = build();
        }
        return stepResults.build;
      },
      getGeneratedCaps: async (opts) => {
        getResults("build", "getGeneratedCaps");
        stepResults.getGeneratedCaps = await getGeneratedCaps(opts);
        return stepResults.getGeneratedCaps;
      },
      generateAndAttachEncryptionKey: async () => {
        stepResults.generateAndAttachEncryptionKey = await generateAndAttachEncryptionKey(
          getResults("getGeneratedCaps", "generateAndAttachEncryptionKey")
        );
        return stepResults.generateAndAttachEncryptionKey.transaction;
      },
      getGeneratedEncryptionKey: () => {
        return getGeneratedEncryptionKey(
          getResults("generateAndAttachEncryptionKey", "getGeneratedEncryptionKey")
        );
      }
    };
  }
  /**
   * Create a send message transaction builder
   * @param channelId - The channel ID
   * @param memberCapId - The member cap ID
   * @param sender - The sender address
   * @param message - The message text
   * @param encryptedKey - The encrypted symmetric key
   * @param attachments - Optional file attachments
   * @returns Transaction builder function
   */
  async sendMessage(channelId, memberCapId, sender, message, encryptedKey, attachments) {
    return async (tx) => {
      const channel = tx.object(channelId);
      const memberCap = tx.object(memberCapId);
      const { encryptedBytes: ciphertext, nonce: textNonce } = await __privateGet2(this, _envelopeEncryption).encryptText({
        text: message,
        channelId,
        sender,
        memberCapId,
        encryptedKey
      });
      const attachmentsVec = await __privateMethod3(this, _SuiStackMessagingClient_instances, createAttachmentsVec_fn).call(this, tx, encryptedKey, channelId, memberCapId, sender, attachments);
      tx.add(
        sendMessage({
          package: __privateGet2(this, _packageConfig).packageId,
          arguments: {
            self: channel,
            memberCap,
            ciphertext: tx.pure.vector("u8", ciphertext),
            nonce: tx.pure.vector("u8", textNonce),
            attachments: attachmentsVec
          }
        })
      );
    };
  }
  /**
   * Execute a send message transaction
   * @param params - Transaction parameters including signer, channelId, memberCapId, message, and encryptedKey
   * @returns Transaction digest and message ID
   */
  async executeSendMessageTransaction({
    signer,
    channelId,
    memberCapId,
    message,
    attachments,
    encryptedKey
  }) {
    const tx = new Transaction();
    const sendMessageTxBuilder = await this.sendMessage(
      channelId,
      memberCapId,
      signer.toSuiAddress(),
      message,
      encryptedKey,
      attachments
    );
    await sendMessageTxBuilder(tx);
    const { digest, effects } = await __privateMethod3(this, _SuiStackMessagingClient_instances, executeTransaction_fn).call(this, tx, signer, "send message", true);
    const messageId = effects.changedObjects.find((obj) => obj.idOperation === "Created")?.id;
    if (messageId === void 0) {
      throw new MessagingClientError("Message id not found on the transaction effects");
    }
    return { digest, messageId };
  }
  /**
   * Update the external SessionKey instance (useful for React context updates)
   * Only works when the client was configured with an external SessionKey
   */
  updateSessionKey(newSessionKey) {
    __privateGet2(this, _envelopeEncryption).updateSessionKey(newSessionKey);
  }
  /**
   * Force refresh the managed SessionKey (useful for testing or manual refresh)
   * Only works when the client was configured with SessionKeyConfig
   */
  async refreshSessionKey() {
    return __privateGet2(this, _envelopeEncryption).refreshSessionKey();
  }
  /**
   * Execute a create channel transaction
   * @param params - Transaction parameters including signer and optional initial members
   * @returns Transaction digest, channel ID, creator cap ID, and encrypted key
   */
  async executeCreateChannelTransaction({
    signer,
    initialMembers
  }) {
    const flow = this.createChannelFlow({
      creatorAddress: signer.toSuiAddress(),
      initialMemberAddresses: initialMembers
    });
    const channelTx = flow.build();
    const { digest: channelDigest } = await __privateMethod3(this, _SuiStackMessagingClient_instances, executeTransaction_fn).call(this, channelTx, signer, "create channel");
    const {
      creatorCap,
      creatorMemberCap,
      additionalMemberCaps: _
    } = await flow.getGeneratedCaps({
      digest: channelDigest
    });
    const attachKeyTx = await flow.generateAndAttachEncryptionKey({ creatorMemberCap });
    const { digest: keyDigest } = await __privateMethod3(this, _SuiStackMessagingClient_instances, executeTransaction_fn).call(this, attachKeyTx, signer, "attach encryption key");
    const { channelId, encryptedKeyBytes } = flow.getGeneratedEncryptionKey();
    return { digest: keyDigest, creatorCapId: creatorCap.id.id, channelId, encryptedKeyBytes };
  }
};
_suiClient2 = /* @__PURE__ */ new WeakMap();
_packageConfig = /* @__PURE__ */ new WeakMap();
_storage = /* @__PURE__ */ new WeakMap();
_envelopeEncryption = /* @__PURE__ */ new WeakMap();
_sealConfig2 = /* @__PURE__ */ new WeakMap();
_SuiStackMessagingClient_instances = /* @__PURE__ */ new WeakSet();
getUserMemberCapId_fn = async function(userAddress, channelId) {
  let cursor = null;
  let hasNextPage = true;
  while (hasNextPage) {
    const memberships = await this.getChannelMemberships({
      address: userAddress,
      cursor
    });
    const membership = memberships.memberships.find((m) => m.channel_id === channelId);
    if (membership) {
      return membership.member_cap_id;
    }
    cursor = memberships.cursor;
    hasNextPage = memberships.hasNextPage;
  }
  throw new MessagingClientError(`User ${userAddress} is not a member of channel ${channelId}`);
};
getEncryptionKeyFromChannel_fn = async function(channel) {
  const encryptedKeyBytes = channel.encryption_key_history.latest;
  const keyVersion = channel.encryption_key_history.latest_version;
  return {
    $kind: "Encrypted",
    encryptedBytes: new Uint8Array(encryptedKeyBytes),
    version: keyVersion
  };
};
decryptMessage_fn = async function(message, channelId, memberCapId, encryptedKey) {
  const text = await __privateGet2(this, _envelopeEncryption).decryptText({
    encryptedBytes: new Uint8Array(message.ciphertext),
    nonce: new Uint8Array(message.nonce),
    sender: message.sender,
    channelId,
    memberCapId,
    encryptedKey
  });
  if (!message.attachments || message.attachments.length === 0) {
    return { text, attachments: [], sender: message.sender, createdAtMs: message.created_at_ms };
  }
  const attachmentsMetadata = await Promise.all(
    message.attachments.map(async (attachment) => {
      const metadata = await __privateGet2(this, _envelopeEncryption).decryptAttachmentMetadata({
        encryptedBytes: new Uint8Array(attachment.encrypted_metadata),
        nonce: new Uint8Array(attachment.metadata_nonce),
        channelId,
        sender: message.sender,
        encryptedKey,
        memberCapId
      });
      return {
        metadata,
        attachment
        // Keep reference to original attachment
      };
    })
  );
  const lazyAttachmentsDataPromises = attachmentsMetadata.map(
    ({ metadata, attachment }) => ({
      ...metadata,
      data: __privateMethod3(this, _SuiStackMessagingClient_instances, createLazyAttachmentDataPromise_fn).call(this, {
        blobRef: attachment.blob_ref,
        nonce: new Uint8Array(attachment.data_nonce),
        channelId,
        sender: message.sender,
        encryptedKey,
        memberCapId
      })
    })
  );
  return {
    text,
    sender: message.sender,
    createdAtMs: message.created_at_ms,
    attachments: lazyAttachmentsDataPromises
  };
};
createAttachmentsVec_fn = async function(tx, encryptedKey, channelId, memberCapId, sender, attachments) {
  const attachmentType = __privateGet2(this, _packageConfig).packageId ? (
    // todo: this needs better handling - it's needed for the integration tests
    Attachment.name.replace("@local-pkg/sui-stack-messaging", __privateGet2(this, _packageConfig).packageId)
  ) : Attachment.name;
  if (!attachments || attachments.length === 0) {
    return tx.moveCall({
      package: "0x1",
      module: "vector",
      function: "empty",
      arguments: [],
      typeArguments: [attachmentType]
    });
  }
  const encryptedDataPayloads = await Promise.all(
    attachments.map(async (file) => {
      return __privateGet2(this, _envelopeEncryption).encryptAttachmentData({
        file,
        channelId,
        memberCapId,
        encryptedKey,
        sender
      });
    })
  );
  const attachmentRefs = await __privateGet2(this, _storage).call(this, __privateGet2(this, _suiClient2)).upload(
    encryptedDataPayloads.map((p) => p.encryptedBytes),
    { storageType: "quilts" }
  );
  const encryptedMetadataPayloads = await Promise.all(
    attachments.map((file) => {
      return __privateGet2(this, _envelopeEncryption).encryptAttachmentMetadata({
        file,
        channelId,
        memberCapId,
        encryptedKey,
        sender
      });
    })
  );
  return tx.makeMoveVec({
    type: attachmentType,
    elements: attachmentRefs.ids.map((blobRef, i) => {
      const dataNonce = encryptedDataPayloads[i].nonce;
      const metadata = encryptedMetadataPayloads[i];
      const metadataNonce = metadata.nonce;
      return tx.add(
        _new({
          package: __privateGet2(this, _packageConfig).packageId,
          arguments: {
            blobRef: tx.pure.string(blobRef),
            encryptedMetadata: tx.pure.vector("u8", metadata.encryptedBytes),
            dataNonce: tx.pure.vector("u8", dataNonce),
            metadataNonce: tx.pure.vector("u8", metadataNonce),
            keyVersion: tx.pure("u32", encryptedKey.version)
          }
        })
      );
    })
  });
};
executeTransaction_fn = async function(transaction, signer, action, waitForTransaction = true) {
  transaction.setSenderIfNotSet(signer.toSuiAddress());
  const { digest, effects } = await signer.signAndExecuteTransaction({
    transaction,
    client: __privateGet2(this, _suiClient2)
  });
  if (effects?.status.error) {
    throw new MessagingClientError(`Failed to ${action} (${digest}): ${effects?.status.error}`);
  }
  if (waitForTransaction) {
    await __privateGet2(this, _suiClient2).core.waitForTransaction({
      digest
    });
  }
  return { digest, effects };
};
getGeneratedCaps_fn = async function(digest) {
  const creatorCapType = CreatorCap.name.replace(
    "@local-pkg/sui-stack-messaging",
    __privateGet2(this, _packageConfig).packageId
  );
  const creatorMemberCapType = MemberCap.name.replace(
    "@local-pkg/sui-stack-messaging",
    __privateGet2(this, _packageConfig).packageId
  );
  const additionalMemberCapType = MemberCap.name.replace(
    "@local-pkg/sui-stack-messaging",
    __privateGet2(this, _packageConfig).packageId
  );
  const {
    transaction: { effects }
  } = await __privateGet2(this, _suiClient2).core.waitForTransaction({
    digest
  });
  const createdObjectIds = effects?.changedObjects.filter((object) => object.idOperation === "Created").map((object) => object.id);
  const createdObjects = await __privateGet2(this, _suiClient2).core.getObjects({
    objectIds: createdObjectIds
  });
  const suiCreatorCapObject = createdObjects.objects.find(
    (object) => !(object instanceof Error) && object.type === creatorCapType
  );
  if (suiCreatorCapObject instanceof Error || !suiCreatorCapObject) {
    throw new MessagingClientError(
      `CreatorCap object not found in transaction effects for transaction (${digest})`
    );
  }
  const creatorCapParsed = CreatorCap.parse(await suiCreatorCapObject.content);
  const suiCreatorMemberCapObject = createdObjects.objects.find(
    (object) => !(object instanceof Error) && object.type === creatorMemberCapType && // only get the creator's member cap
    object.owner.$kind === "AddressOwner" && suiCreatorCapObject.owner.$kind === "AddressOwner" && object.owner.AddressOwner === suiCreatorCapObject.owner.AddressOwner
  );
  if (suiCreatorMemberCapObject instanceof Error || !suiCreatorMemberCapObject) {
    throw new MessagingClientError(
      `CreatorMemberCap object not found in transaction effects for transaction (${digest})`
    );
  }
  const creatorMemberCapParsed = MemberCap.parse(await suiCreatorMemberCapObject.content);
  const suiAdditionalMemberCapsObjects = createdObjects.objects.filter(
    (object) => !(object instanceof Error) && object.type === additionalMemberCapType
  );
  const additionalMemberCapsParsed = await Promise.all(
    suiAdditionalMemberCapsObjects.map(async (object) => {
      if (object instanceof Error) {
        throw new MessagingClientError(
          `AdditionalMemberCap object not found in transaction effects for transaction (${digest})`
        );
      }
      return MemberCap.parse(await object.content);
    })
  );
  additionalMemberCapsParsed.filter((cap) => cap.id.id !== creatorMemberCapParsed.id.id);
  return {
    creatorCap: creatorCapParsed,
    creatorMemberCap: creatorMemberCapParsed,
    additionalMemberCaps: additionalMemberCapsParsed
  };
};
deriveMessageIDsFromRange_fn = function(messagesTableId, startIndex, endIndex) {
  const messageIDs = [];
  for (let i = startIndex; i < endIndex; i++) {
    messageIDs.push(deriveDynamicFieldID(messagesTableId, "u64", suiBcs.U64.serialize(i).toBytes()));
  }
  return messageIDs;
};
parseMessageObjects_fn = async function(messageObjects) {
  const DynamicFieldMessage = suiBcs.struct("DynamicFieldMessage", {
    id: suiBcs.Address,
    // UID is represented as an address
    name: suiBcs.U64,
    // the key (message index)
    value: Message
    // the actual Message
  });
  const parsedMessageObjects = await Promise.all(
    messageObjects.objects.map(async (object) => {
      if (object instanceof Error || !object.content) {
        throw new MessagingClientError(`Failed to parse message object: ${object}`);
      }
      const content = await object.content;
      const dynamicField = DynamicFieldMessage.parse(content);
      return dynamicField.value;
    })
  );
  return parsedMessageObjects;
};
createLazyAttachmentDataPromise_fn = async function({
  channelId,
  memberCapId,
  sender,
  encryptedKey,
  blobRef,
  nonce
}) {
  const downloadAndDecrypt = async () => {
    const [encryptedData] = await __privateGet2(this, _storage).call(this, __privateGet2(this, _suiClient2)).download([blobRef]);
    const decryptedData = await __privateGet2(this, _envelopeEncryption).decryptAttachmentData({
      encryptedBytes: new Uint8Array(encryptedData),
      nonce: new Uint8Array(nonce),
      channelId,
      memberCapId,
      sender,
      encryptedKey
    });
    return decryptedData.data;
  };
  return new Promise((resolve, reject) => {
    downloadAndDecrypt().then(resolve).catch(reject);
  });
};
calculateFetchRange_fn = function({
  cursor,
  limit,
  direction,
  totalMessagesCount
}) {
  const limitBigInt = BigInt(limit);
  if (direction === "backward") {
    if (cursor === null) {
      const startIndex3 = totalMessagesCount > limitBigInt ? totalMessagesCount - limitBigInt : BigInt(0);
      return {
        startIndex: startIndex3,
        endIndex: totalMessagesCount
      };
    }
    const endIndex2 = cursor;
    const startIndex2 = endIndex2 > limitBigInt ? endIndex2 - limitBigInt : BigInt(0);
    return {
      startIndex: startIndex2,
      endIndex: endIndex2
    };
  }
  if (cursor === null) {
    const endIndex2 = totalMessagesCount > limitBigInt ? limitBigInt : totalMessagesCount;
    return {
      startIndex: BigInt(0),
      endIndex: endIndex2
    };
  }
  const startIndex = cursor + BigInt(1);
  const endIndex = startIndex + limitBigInt > totalMessagesCount ? totalMessagesCount : startIndex + limitBigInt;
  return {
    startIndex,
    endIndex
  };
};
fetchMessagesInRange_fn = async function(messagesTableId, range) {
  const messageIds = __privateMethod3(this, _SuiStackMessagingClient_instances, deriveMessageIDsFromRange_fn).call(this, messagesTableId, range.startIndex, range.endIndex);
  if (messageIds.length === 0) {
    return [];
  }
  const messageObjects = await __privateGet2(this, _suiClient2).core.getObjects({ objectIds: messageIds });
  return await __privateMethod3(this, _SuiStackMessagingClient_instances, parseMessageObjects_fn).call(this, messageObjects);
};
determineNextPagination_fn = function({
  fetchRange,
  direction,
  totalMessagesCount
}) {
  let nextCursor = null;
  let hasNextPage = false;
  if (direction === "backward") {
    nextCursor = fetchRange.startIndex > BigInt(0) ? fetchRange.startIndex : null;
    hasNextPage = fetchRange.startIndex > BigInt(0);
  } else {
    nextCursor = fetchRange.endIndex < totalMessagesCount ? fetchRange.endIndex - BigInt(1) : null;
    hasNextPage = fetchRange.endIndex < totalMessagesCount;
  }
  return {
    cursor: nextCursor,
    hasNextPage
  };
};
createEmptyMessagesResponse_fn = function(direction) {
  return {
    messages: [],
    cursor: null,
    hasNextPage: false,
    direction
  };
};
getObjectContents_fn = async function(objects) {
  const contentPromises = objects.map(async (object) => {
    try {
      return await object.content;
    } catch (error) {
      if (error instanceof Error && error.message.includes("GRPC does not return object contents")) {
        return null;
      }
      throw error;
    }
  });
  const contents = await Promise.all(contentPromises);
  const needsBatchFetch = contents.some((content) => content === null);
  if (needsBatchFetch) {
    const objectIds = objects.map((obj) => obj.id);
    const objectResponses = await __privateGet2(this, _suiClient2).core.getObjects({ objectIds });
    const batchContents = await Promise.all(
      objectResponses.objects.map(async (obj) => {
        if (obj instanceof Error || !obj.content) {
          throw new MessagingClientError(`Failed to fetch object content: ${obj}`);
        }
        return await obj.content;
      })
    );
    return batchContents;
  }
  return contents.filter((content) => content !== null);
};
var SuiStackMessagingClient = _SuiStackMessagingClient;
export {
  ApiNotImplementedFeatureError,
  DEFAULT_SEAL_APPROVE_CONTRACT,
  GeneralError,
  MAINNET_MESSAGING_PACKAGE_CONFIG,
  MessagingAPIError,
  MessagingClientError,
  NotImplementedFeatureError,
  SuiStackMessagingClient,
  TESTNET_MESSAGING_PACKAGE_CONFIG,
  UserError,
  WalrusStorageAdapter,
  toMajorityError
};
//# sourceMappingURL=@mysten_messaging.js.map
