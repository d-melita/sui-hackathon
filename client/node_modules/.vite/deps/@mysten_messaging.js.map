{
  "version": 3,
  "sources": ["../../@mysten/messaging/src/contracts/utils/index.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/sui/object.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/sui/vec_map.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/sui/vec_set.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/std/type_name.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/sui/versioned.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/auth.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/sui/table.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/deps/sui/table_vec.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/attachment.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/message.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/encryption_key_history.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/channel.ts", "../../@mysten/messaging/src/constants.ts", "../../@mysten/messaging/src/error.ts", "../../@mysten/messaging/src/storage/adapters/walrus/walrus.ts", "../../@mysten/messaging/src/encryption/constants.ts", "../../@mysten/messaging/src/encryption/webCryptoPrimitives.ts", "../../@mysten/messaging/src/encryption/sessionKeyManager.ts", "../../@mysten/messaging/src/encryption/envelopeEncryption.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/creator_cap.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/member_cap.ts", "../../@mysten/messaging/src/contracts/sui_stack_messaging/config.ts", "../../@mysten/messaging/src/client.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BcsType, TypeTag } from '@mysten/sui/bcs';\nimport { bcs, TypeTagSerializer, BcsStruct, BcsEnum, BcsTuple } from '@mysten/sui/bcs';\nimport { normalizeSuiAddress } from '@mysten/sui/utils';\nimport type { TransactionArgument } from '@mysten/sui/transactions';\nimport { isArgument } from '@mysten/sui/transactions';\n\nconst MOVE_STDLIB_ADDRESS = normalizeSuiAddress('0x1');\nconst SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress('0x2');\nconst SUI_SYSTEM_ADDRESS = normalizeSuiAddress('0x3');\n\nexport type RawTransactionArgument<T> = T | TransactionArgument;\n\nexport function getPureBcsSchema(typeTag: string | TypeTag): BcsType<any> | null {\n\tconst parsedTag = typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;\n\n\tif ('u8' in parsedTag) {\n\t\treturn bcs.U8;\n\t} else if ('u16' in parsedTag) {\n\t\treturn bcs.U16;\n\t} else if ('u32' in parsedTag) {\n\t\treturn bcs.U32;\n\t} else if ('u64' in parsedTag) {\n\t\treturn bcs.U64;\n\t} else if ('u128' in parsedTag) {\n\t\treturn bcs.U128;\n\t} else if ('u256' in parsedTag) {\n\t\treturn bcs.U256;\n\t} else if ('address' in parsedTag) {\n\t\treturn bcs.Address;\n\t} else if ('bool' in parsedTag) {\n\t\treturn bcs.Bool;\n\t} else if ('vector' in parsedTag) {\n\t\tconst type = getPureBcsSchema(parsedTag.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t} else if ('struct' in parsedTag) {\n\t\tconst structTag = parsedTag.struct;\n\t\tconst pkg = normalizeSuiAddress(parsedTag.struct.address);\n\n\t\tif (pkg === MOVE_STDLIB_ADDRESS) {\n\t\t\tif (\n\t\t\t\t(structTag.module === 'ascii' || structTag.module === 'string') &&\n\t\t\t\tstructTag.name === 'String'\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (structTag.module === 'option' && structTag.name === 'Option') {\n\t\t\t\tconst type = getPureBcsSchema(structTag.typeParams[0]!);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (pkg === SUI_FRAMEWORK_ADDRESS && structTag.module === 'Object' && structTag.name === 'ID') {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizeMoveArguments(\n\targs: unknown[] | object,\n\targTypes: string[],\n\tparameterNames?: string[],\n) {\n\tif (parameterNames && argTypes.length !== parameterNames.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of parameterNames, expected ${argTypes.length}, got ${parameterNames.length}`,\n\t\t);\n\t}\n\n\tconst normalizedArgs: TransactionArgument[] = [];\n\n\tlet index = 0;\n\tfor (const [i, argType] of argTypes.entries()) {\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::deny_list::DenyList`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.denyList());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::random::Random`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.random());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::clock::Clock`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.clock());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_SYSTEM_ADDRESS}::sui_system::SuiSystemState`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.system());\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet arg;\n\t\tif (Array.isArray(args)) {\n\t\t\tif (index >= args.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid number of arguments, expected at least ${index + 1}, got ${args.length}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\targ = args[index];\n\t\t} else {\n\t\t\tif (!parameterNames) {\n\t\t\t\tthrow new Error(`Expected arguments to be passed as an array`);\n\t\t\t}\n\t\t\tconst name = parameterNames[index];\n\t\t\targ = args[name as keyof typeof args];\n\n\t\t\tif (arg == null) {\n\t\t\t\tthrow new Error(`Parameter ${name} is required`);\n\t\t\t}\n\t\t}\n\n\t\tindex += 1;\n\n\t\tif (typeof arg === 'function' || isArgument(arg)) {\n\t\t\tnormalizedArgs.push(arg as TransactionArgument);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst type = argTypes[i]!;\n\t\tconst bcsType = getPureBcsSchema(type);\n\n\t\tif (bcsType) {\n\t\t\tconst bytes = bcsType.serialize(arg as never);\n\t\t\tnormalizedArgs.push((tx) => tx.pure(bytes));\n\t\t\tcontinue;\n\t\t} else if (typeof arg === 'string') {\n\t\t\tnormalizedArgs.push((tx) => tx.object(arg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tthrow new Error(`Invalid argument ${stringify(arg)} for type ${type}`);\n\t}\n\n\treturn normalizedArgs;\n}\n\nexport class MoveStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsStruct<T, Name> {}\n\nexport class MoveEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string,\n> extends BcsEnum<T, Name> {}\n\nexport class MoveTuple<\n\tT extends readonly BcsType<any>[],\n\tconst Name extends string,\n> extends BcsTuple<T, Name> {}\n\nfunction stringify(val: unknown) {\n\tif (typeof val === 'object') {\n\t\treturn JSON.stringify(val, (val: unknown) => val);\n\t}\n\tif (typeof val === 'bigint') {\n\t\treturn val.toString();\n\t}\n\n\treturn val;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Sui object identifiers */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::object';\nexport const UID = new MoveStruct({\n\tname: `${$moduleName}::UID`,\n\tfields: {\n\t\tid: bcs.Address,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { MoveStruct } from '../../../utils/index.js';\nconst $moduleName = '0x2::vec_map';\n/** An entry in the map */\nexport function Entry<K extends BcsType<any>, V extends BcsType<any>>(...typeParameters: [K, V]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::Entry<${typeParameters[0].name as K['name']}, ${typeParameters[1].name as V['name']}>`,\n\t\tfields: {\n\t\t\tkey: typeParameters[0],\n\t\t\tvalue: typeParameters[1],\n\t\t},\n\t});\n}\n/**\n * A map data structure backed by a vector. The map is guaranteed not to contain\n * duplicate keys, but entries are _not_ sorted by key--entries are included in\n * insertion order. All operations are O(N) in the size of the map--the intention\n * of this data structure is only to provide the convenience of programming against\n * a map API. Large maps should use handwritten parent/child relationships instead.\n * Maps that need sorted iteration rather than insertion order iteration should\n * also be handwritten.\n */\nexport function VecMap<K extends BcsType<any>, V extends BcsType<any>>(...typeParameters: [K, V]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::VecMap<${typeParameters[0].name as K['name']}, ${typeParameters[1].name as V['name']}>`,\n\t\tfields: {\n\t\t\tcontents: bcs.vector(Entry(typeParameters[0], typeParameters[1])),\n\t\t},\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { MoveStruct } from '../../../utils/index.js';\nconst $moduleName = '0x2::vec_set';\n/**\n * A set data structure backed by a vector. The set is guaranteed not to contain\n * duplicate keys. All operations are O(N) in the size of the set\n *\n * - the intention of this data structure is only to provide the convenience of\n *   programming against a set API. Sets that need sorted iteration rather than\n *   insertion order iteration should be handwritten.\n */\nexport function VecSet<K extends BcsType<any>>(...typeParameters: [K]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::VecSet<${typeParameters[0].name as K['name']}>`,\n\t\tfields: {\n\t\t\tcontents: bcs.vector(typeParameters[0]),\n\t\t},\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Functionality for converting Move types into values. Use with care! */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = 'std::type_name';\nexport const TypeName = new MoveStruct({\n\tname: `${$moduleName}::TypeName`,\n\tfields: {\n\t\t/**\n\t\t * String representation of the type. All types are represented using their source\n\t\t * syntax: \"u8\", \"u64\", \"bool\", \"address\", \"vector\", and so on for primitive types.\n\t\t * Struct types are represented as fully qualified type names; e.g.\n\t\t * `00000000000000000000000000000001::string::String` or\n\t\t * `0000000000000000000000000000000a::module_name1::type_name1<0000000000000000000000000000000a::module_name2::type_name2<u64>>`\n\t\t * Addresses are hex-encoded lowercase values of length ADDRESS_LENGTH (16, 20, or\n\t\t * 32 depending on the Move platform)\n\t\t */\n\t\tname: bcs.string(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::versioned';\nexport const Versioned = new MoveStruct({\n\tname: `${$moduleName}::Versioned`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, MoveTuple } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as vec_map from './deps/sui/vec_map.js';\nimport * as vec_set from './deps/sui/vec_set.js';\nimport * as type_name from './deps/std/type_name.js';\nimport * as versioned from './deps/sui/versioned.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::auth';\nexport const Auth = new MoveStruct({\n\tname: `${$moduleName}::Auth`,\n\tfields: {\n\t\tmember_permissions: vec_map.VecMap(bcs.Address, vec_set.VecSet(type_name.TypeName)),\n\t\tconfig: versioned.Versioned,\n\t},\n});\nexport const EditPermissions = new MoveTuple({\n\tname: `${$moduleName}::EditPermissions`,\n\tfields: [bcs.bool()],\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A table is a map-like collection. But unlike a traditional collection, it's keys\n * and values are not stored within the `Table` value, but instead are stored using\n * Sui's object system. The `Table` struct acts only as a handle into the object\n * system to retrieve those keys and values. Note that this means that `Table`\n * values with exactly the same key-value mapping will not be equal, with `==`, at\n * runtime. For example\n *\n * ```\n * let table1 = table::new<u64, bool>();\n * let table2 = table::new<u64, bool>();\n * table::add(&mut table1, 0, false);\n * table::add(&mut table1, 1, true);\n * table::add(&mut table2, 0, false);\n * table::add(&mut table2, 1, true);\n * // table1 does not equal table2, despite having the same entries\n * assert!(&table1 != &table2);\n * ```\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::table';\nexport const Table = new MoveStruct({\n\tname: `${$moduleName}::Table`,\n\tfields: {\n\t\t/** the ID of this table */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the table */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** A basic scalable vector library implemented using `Table`. */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport * as table from './table.js';\nconst $moduleName = '0x2::table_vec';\nexport const TableVec = new MoveStruct({\n\tname: `${$moduleName}::TableVec`,\n\tfields: {\n\t\t/** The contents of the table vector. */\n\t\tcontents: table.Table,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/sui-stack-messaging::attachment';\nexport const Attachment = new MoveStruct({\n\tname: `${$moduleName}::Attachment`,\n\tfields: {\n\t\tblob_ref: bcs.string(),\n\t\tencrypted_metadata: bcs.vector(bcs.u8()),\n\t\tdata_nonce: bcs.vector(bcs.u8()),\n\t\tmetadata_nonce: bcs.vector(bcs.u8()),\n\t\tkey_version: bcs.u32(),\n\t},\n});\nexport interface NewArguments {\n\tblobRef: RawTransactionArgument<string>;\n\tencryptedMetadata: RawTransactionArgument<number[]>;\n\tdataNonce: RawTransactionArgument<number[]>;\n\tmetadataNonce: RawTransactionArgument<number[]>;\n\tkeyVersion: RawTransactionArgument<number>;\n}\nexport interface NewOptions {\n\tpackage?: string;\n\targuments:\n\t\t| NewArguments\n\t\t| [\n\t\t\t\tblobRef: RawTransactionArgument<string>,\n\t\t\t\tencryptedMetadata: RawTransactionArgument<number[]>,\n\t\t\t\tdataNonce: RawTransactionArgument<number[]>,\n\t\t\t\tmetadataNonce: RawTransactionArgument<number[]>,\n\t\t\t\tkeyVersion: RawTransactionArgument<number>,\n\t\t  ];\n}\nexport function _new(options: NewOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'blobRef',\n\t\t'encryptedMetadata',\n\t\t'dataNonce',\n\t\t'metadataNonce',\n\t\t'keyVersion',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'attachment',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BlobRefArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BlobRefOptions {\n\tpackage?: string;\n\targuments: BlobRefArguments | [self: RawTransactionArgument<string>];\n}\nexport function blobRef(options: BlobRefOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::attachment::Attachment`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'attachment',\n\t\t\tfunction: 'blob_ref',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DataNonceArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface DataNonceOptions {\n\tpackage?: string;\n\targuments: DataNonceArguments | [self: RawTransactionArgument<string>];\n}\nexport function dataNonce(options: DataNonceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::attachment::Attachment`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'attachment',\n\t\t\tfunction: 'data_nonce',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as attachment from './attachment.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::message';\nexport const Message = new MoveStruct({\n\tname: `${$moduleName}::Message`,\n\tfields: {\n\t\t/** The address of the sender of this message. TODO: should we encrypt this as well? */\n\t\tsender: bcs.Address,\n\t\t/** The message content, encrypted with a DEK(Data Encryption Key) */\n\t\tciphertext: bcs.vector(bcs.u8()),\n\t\t/** The nonce used for the encryption of the content. */\n\t\tnonce: bcs.vector(bcs.u8()),\n\t\t/**\n\t\t * The version of the DEK(Data Encryption Key) that was used to encrypt this\n\t\t * Message\n\t\t */\n\t\tkey_version: bcs.u32(),\n\t\t/** A vector of attachments associated with this message. */\n\t\tattachments: bcs.vector(attachment.Attachment),\n\t\t/** Timestamp in milliseconds when the message was created. */\n\t\tcreated_at_ms: bcs.u64(),\n\t},\n});\nexport const MessageAddedEvent = new MoveStruct({\n\tname: `${$moduleName}::MessageAddedEvent`,\n\tfields: {\n\t\tchannel_id: bcs.Address,\n\t\tmessage_index: bcs.u64(),\n\t\tsender: bcs.Address,\n\t\tciphertext: bcs.vector(bcs.u8()),\n\t\tnonce: bcs.vector(bcs.u8()),\n\t\tkey_version: bcs.u32(),\n\t\tattachment_refs: bcs.vector(bcs.string()),\n\t\tattachment_nonces: bcs.vector(bcs.vector(bcs.u8())),\n\t\tcreated_at_ms: bcs.u64(),\n\t},\n});\nexport interface NewArguments {\n\tsender: RawTransactionArgument<string>;\n\tciphertext: RawTransactionArgument<number[]>;\n\tnonce: RawTransactionArgument<number[]>;\n\tkeyVersion: RawTransactionArgument<number>;\n\tattachments: RawTransactionArgument<string[]>;\n}\nexport interface NewOptions {\n\tpackage?: string;\n\targuments:\n\t\t| NewArguments\n\t\t| [\n\t\t\t\tsender: RawTransactionArgument<string>,\n\t\t\t\tciphertext: RawTransactionArgument<number[]>,\n\t\t\t\tnonce: RawTransactionArgument<number[]>,\n\t\t\t\tkeyVersion: RawTransactionArgument<number>,\n\t\t\t\tattachments: RawTransactionArgument<string[]>,\n\t\t  ];\n}\nexport function _new(options: NewOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t'address',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'u32',\n\t\t`vector<${packageAddress}::attachment::Attachment>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['sender', 'ciphertext', 'nonce', 'keyVersion', 'attachments', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'message',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, MoveTuple } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as table_vec from './deps/sui/table_vec.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::encryption_key_history';\nexport const EncryptionKeyHistory = new MoveStruct({\n\tname: `${$moduleName}::EncryptionKeyHistory`,\n\tfields: {\n\t\tlatest: bcs.vector(bcs.u8()),\n\t\tlatest_version: bcs.u32(),\n\t\thistory: table_vec.TableVec,\n\t},\n});\nexport const EditEncryptionKey = new MoveTuple({\n\tname: `${$moduleName}::EditEncryptionKey`,\n\tfields: [bcs.bool()],\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, MoveTuple, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nimport * as auth from './auth.js';\nimport * as table_vec from './deps/sui/table_vec.js';\nimport * as message from './message.js';\nimport * as encryption_key_history from './encryption_key_history.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::channel';\nexport const Channel = new MoveStruct({\n\tname: `${$moduleName}::Channel`,\n\tfields: {\n\t\tid: object.UID,\n\t\t/** The version of this object, for handling updgrades. */\n\t\tversion: bcs.u64(),\n\t\t/**\n\t\t * The Authorization struct, gating actions to member permissions. Note: It also,\n\t\t * practically, keeps tracks of the members (MemberCap ID -> Permissions)\n\t\t */\n\t\tauth: auth.Auth,\n\t\t/**\n\t\t * The message history of the channel.\n\t\t *\n\t\t * Using `TableVec` to avoid the object size limit.\n\t\t */\n\t\tmessages: table_vec.TableVec,\n\t\t/**\n\t\t * The total number of messages, for efficiency, so that we don't have to make a\n\t\t * call to messages.length() (Maybe I am overthinking this, need to measure)\n\t\t */\n\t\tmessages_count: bcs.u64(),\n\t\t/**\n\t\t * A duplicate of the last entry of the messages TableVec,\n\t\t *\n\t\t * Utilize this for efficient fetching e.g. list of conversations showing the\n\t\t * latest message and the user who sent it\n\t\t */\n\t\tlast_message: bcs.option(message.Message),\n\t\t/** The timestamp (in milliseconds) when the channel was created. */\n\t\tcreated_at_ms: bcs.u64(),\n\t\t/**\n\t\t * The timestamp (in milliseconds) when the channel was last updated. (e.g. change\n\t\t * in metadata, members, admins, keys)\n\t\t */\n\t\tupdated_at_ms: bcs.u64(),\n\t\t/**\n\t\t * History of Encryption keys\n\t\t *\n\t\t * Holds the latest key, the latest_version, and a TableVec of the historical keys\n\t\t */\n\t\tencryption_key_history: encryption_key_history.EncryptionKeyHistory,\n\t},\n});\nexport const SimpleMessenger = new MoveTuple({\n\tname: `${$moduleName}::SimpleMessenger`,\n\tfields: [bcs.bool()],\n});\nexport interface NewArguments {\n\tconfig: RawTransactionArgument<string | null>;\n}\nexport interface NewOptions {\n\tpackage?: string;\n\targuments: NewArguments | [config: RawTransactionArgument<string | null>];\n}\n/**\n * Create a new `Channel` object with empty Config, Roles, messages. Adds the\n * creator as a member.\n *\n * The flow is: new() -> (optionally set initial config) -> (optionally set initial\n * members) -> share() -> client generate a DEK and encrypt it with Seal using the\n * ChannelID as identity bytes -> add_encrypted_key(CreatorCap)\n */\nexport function _new(options: NewOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<${packageAddress}::config::Config>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['config', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ShareArguments {\n\tself: RawTransactionArgument<string>;\n\tcreatorCap: RawTransactionArgument<string>;\n}\nexport interface ShareOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ShareArguments\n\t\t| [self: RawTransactionArgument<string>, creatorCap: RawTransactionArgument<string>];\n}\n/**\n * Share the Channel object Note: at this point the client needs to attach an\n * encrypted DEK Otherwise, it is considered in an invalid state, and cannot be\n * interacted with.\n */\nexport function share(options: ShareOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::creator_cap::CreatorCap`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'creatorCap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'share',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddEncryptedKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tnewEncryptionKeyBytes: RawTransactionArgument<number[]>;\n}\nexport interface AddEncryptedKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddEncryptedKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tnewEncryptionKeyBytes: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Add the encrypted Channel Key (a key encrypted with Seal) to the Channel. */\nexport function addEncryptedKey(options: AddEncryptedKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'newEncryptionKeyBytes'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'add_encrypted_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddMembersArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tn: RawTransactionArgument<number | bigint>;\n}\nexport interface AddMembersOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddMembersArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tn: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Add new members to the Channel with the default SimpleMessenger permission */\nexport function addMembers(options: AddMembersOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'u64',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'n', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'add_members',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMembersArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tmembersToRemove: RawTransactionArgument<string[]>;\n}\nexport interface RemoveMembersOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMembersArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tmembersToRemove: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/**\n * Remove members from the Channel TODO: should we enforce a key rotation here, by\n * asking for a new_encryption_key arg?\n */\nexport function removeMembers(options: RemoveMembersOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'vector<0x0000000000000000000000000000000000000000000000000000000000000002::object::ID>',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'membersToRemove', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'remove_members',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SendMessageArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tciphertext: RawTransactionArgument<number[]>;\n\tnonce: RawTransactionArgument<number[]>;\n\tattachments: RawTransactionArgument<string[]>;\n}\nexport interface SendMessageOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SendMessageArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tciphertext: RawTransactionArgument<number[]>,\n\t\t\t\tnonce: RawTransactionArgument<number[]>,\n\t\t\t\tattachments: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/** Send a new message to the Channel */\nexport function sendMessage(options: SendMessageOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t`vector<${packageAddress}::attachment::Attachment>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'ciphertext', 'nonce', 'attachments', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'send_message',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NamespaceArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface NamespaceOptions {\n\tpackage?: string;\n\targuments: NamespaceArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Returns a namespace for the channel to be utilized by seal_policies In this case\n * we use the Channel's UID bytes\n */\nexport function namespace(options: NamespaceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::channel::Channel`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'namespace',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { MessagingPackageConfig } from './types.js';\n\n// Default fallback package ID for when environment variables are not available\nconst FALLBACK_PACKAGE_ID = '0x984960ebddd75c15c6d38355ac462621db0ffc7d6647214c802cd3b685e1af3d';\n\n// Default Seal approve contract configurations - uses same package ID as messaging\n// Note: packageId is not included here as it will be taken from the messaging package config\nexport const DEFAULT_SEAL_APPROVE_CONTRACT = {\n\tmodule: 'seal_policies',\n\tfunctionName: 'seal_approve',\n};\n\nexport const TESTNET_MESSAGING_PACKAGE_CONFIG = {\n\tpackageId: FALLBACK_PACKAGE_ID,\n} satisfies MessagingPackageConfig;\n\nexport const MAINNET_MESSAGING_PACKAGE_CONFIG = {\n\tpackageId: FALLBACK_PACKAGE_ID,\n} satisfies MessagingPackageConfig;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nexport class MessagingClientError extends Error {}\n\nexport class UserError extends MessagingClientError {}\n\nexport class MessagingAPIError extends MessagingClientError {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic requestId?: string,\n\t\tpublic status?: number,\n\t) {\n\t\tsuper(message);\n\t}\n\n\tstatic #generate(error: string, message: string, requestId: string, status?: number) {\n\t\tswitch (error) {\n\t\t\tcase 'NotImplementedFeature':\n\t\t\t\treturn new ApiNotImplementedFeatureError(requestId);\n\t\t\tdefault:\n\t\t\t\treturn new GeneralError(message, requestId, status);\n\t\t}\n\t}\n\n\tstatic async assertResponse(response: Response, requestId: string) {\n\t\tif (response.ok) {\n\t\t\treturn;\n\t\t}\n\t\tlet errorInstance: MessagingAPIError;\n\t\ttry {\n\t\t\tconst text = await response.text();\n\t\t\tconst error = JSON.parse(text)['error'];\n\t\t\tconst message = JSON.parse(text)['message'];\n\t\t\terrorInstance = MessagingAPIError.#generate(error, message, requestId);\n\t\t} catch {\n\t\t\t// If we can't parse the response as JSON or if it doesn't have the expected format,\n\t\t\t// fall back to using the status text\n\t\t\terrorInstance = new GeneralError(response.statusText, requestId, response.status);\n\t\t}\n\t\tthrow errorInstance;\n\t}\n}\n\nexport class ApiNotImplementedFeatureError extends MessagingAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('API: Not implemented yet', requestId);\n\t}\n}\n\n/** General server errors that are not specific to the Messaging API (e.g., 404 \"Not Found\") */\nexport class GeneralError extends MessagingAPIError {}\n\n// Errors returned by the SDK\nexport class NotImplementedFeatureError extends UserError {\n\tconstructor() {\n\t\tsuper('SDK: Not implemented yet');\n\t}\n}\n\nexport function toMajorityError(errors: Error[]): Error {\n\tlet maxCount = 0;\n\tlet majorityError = errors[0];\n\tconst counts = new Map<string, number>();\n\tfor (const error of errors) {\n\t\tconst errorName = error.constructor.name;\n\t\tconst newCount = (counts.get(errorName) || 0) + 1;\n\t\tcounts.set(errorName, newCount);\n\n\t\tif (newCount > maxCount) {\n\t\t\tmaxCount = newCount;\n\t\t\tmajorityError = error;\n\t\t}\n\t}\n\n\treturn majorityError;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { ClientWithExtensions } from '@mysten/sui/dist/cjs/experimental';\nimport type { StorageAdapter, StorageConfig, StorageOptions } from '../storage.js';\nimport type { WalrusClient } from '@mysten/walrus';\nimport type { WalrusResponse } from './types.js';\n\nexport class WalrusStorageAdapter implements StorageAdapter {\n\tconstructor(\n\t\t// Client parameter kept for future implementation - currently unused\n\t\t// @ts-expect-error TS6138 - intentionally unused parameter for future implementation\n\t\tprivate readonly _client: ClientWithExtensions<{ walrus?: WalrusClient }>,\n\t\tprivate readonly config: StorageConfig,\n\t) {}\n\n\t/**\n\t * Upload data to Walrus storage\n\t * @param data - Array of data to upload\n\t * @param _options - Storage options (currently unused)\n\t * @returns Upload result with blob IDs\n\t */\n\tasync upload(data: Uint8Array[], _options: StorageOptions): Promise<{ ids: string[] }> {\n\t\treturn await this.#uploadQuilts(data); // todo: option handling for blobs vs quilts\n\t}\n\n\t/**\n\t * Download data from Walrus storage\n\t * @param ids - Array of blob IDs to download\n\t * @returns Array of downloaded data\n\t */\n\tasync download(ids: string[]): Promise<Uint8Array[]> {\n\t\tif (ids.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\treturn await this.#downloadQuilts(ids);\n\t}\n\n\t/**\n\t * Upload data as quilts to Walrus\n\t * @param data - Array of data to upload\n\t * @returns Upload result with quilt patch IDs\n\t */\n\tasync #uploadQuilts(data: Uint8Array[]): Promise<{ ids: string[] }> {\n\t\tconst formData = new FormData();\n\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tconst identifier = `attachment${i}`;\n\t\t\tconst blob = new Blob([new Uint8Array(data[i])]);\n\t\t\tformData.append(identifier, blob);\n\t\t}\n\n\t\tconst response = await fetch(\n\t\t\t`${this.config.publisher}/v1/quilts?epochs=${this.config.epochs}`,\n\t\t\t{\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tbody: formData,\n\t\t\t},\n\t\t);\n\t\tif (!response.ok) {\n\t\t\t// Read the error response body to get the actual error message\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error('Error response body:', errorText);\n\t\t\tthrow new Error(\n\t\t\t\t`Walrus upload failed: ${response.status} ${response.statusText} - ${errorText}`,\n\t\t\t);\n\t\t}\n\n\t\tconst result = await response.json();\n\t\t// const blobId = this.#extractBlobId(result as WalrusResponse);\n\t\t// TODO: figure out the Types, so we avoid the use of any\n\t\t//  // @ts-ignore\n\t\t// console.log((await this.client.walrus.getBlob({blobId})));\n\t\treturn { ids: this.#extractQuiltsPatchIds(result as WalrusResponse) };\n\t}\n\n\t/**\n\t * Download data from Walrus quilts\n\t * @param patchIds - Array of quilt patch IDs to download\n\t * @returns Array of downloaded data\n\t */\n\tasync #downloadQuilts(patchIds: string[]): Promise<Uint8Array[]> {\n\t\t/* OpenApi\n  /v1/blobs/by-quilt-id/{quilt_id}/{identifier}:\n    get:\n      tags:\n      - routes\n      summary: Get blob from quilt by ID and identifier\n      description: Retrieve a specific blob from a quilt using the quilt ID and its identifier. Returns the raw blob bytes, the identifier and other attributes are returned as headers. If the quilt ID or identifier is not found, the response is 404.\n      operationId: get_blob_by_quilt_id_and_identifier\n      parameters:\n      - name: quilt_id\n        in: path\n        description: The quilt ID encoded as URL-safe base64\n        required: true\n        schema:\n          $ref: '#/components/schemas/BlobId'\n        example: rkcHpHQrornOymttgvSq3zvcmQEsMqzmeUM1HSY4ShU\n      - name: identifier\n        in: path\n        description: The identifier of the blob within the quilt\n        required: true\n        schema:\n          type: string\n        example: my-file.txt\n      responses:\n        '200':\n          description: The blob was retrieved successfully. Returns the raw blob bytes, the identifier and other attributes are returned as headers.\n          content:\n            application/octet-stream:\n              schema:\n                type: array\n                items:\n                  type: integer\n                  format: int32\n                  minimum: 0\n        '404':\n          description: May be returned when (1) The requested blob has not yet been stored on Walrus. (2) The requested quilt patch does not exist on Walrus.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Status'\n        '451':\n          description: The blob cannot be returned as has been blocked.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Status'\n        '500':\n          description: An internal server error has occurred. Please report this error.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Status'\n\t\t*/\n\n\t\tconst response = await Promise.all(\n\t\t\tpatchIds.map(\n\t\t\t\tasync (id) => await fetch(`${this.config.aggregator}/v1/blobs/by-quilt-patch-id/${id}`),\n\t\t\t),\n\t\t);\n\t\tconst data = await Promise.all(response.map(async (response) => await response.arrayBuffer()));\n\t\treturn data.map((data) => new Uint8Array(data));\n\t}\n\n\t/**\n\t * Extract blob ID from Walrus response\n\t * @param response - Walrus API response\n\t * @returns Extracted blob ID\n\t */\n\t// @ts-expect-error Method is currently unused but kept for future implementation\n\t#extractBlobId(response: WalrusResponse): string {\n\t\t// direct blob uploads\n\t\tif (response.newlyCreated?.blobObject?.blobId) {\n\t\t\treturn response.newlyCreated.blobObject.blobId;\n\t\t}\n\t\tif (response.alreadyCertified?.blobId) {\n\t\t\treturn response.alreadyCertified.blobId;\n\t\t}\n\n\t\t// quilt uploads\n\t\tif (response.blobStoreResult?.newlyCreated?.blobObject?.blobId) {\n\t\t\treturn response.blobStoreResult.newlyCreated.blobObject.blobId;\n\t\t}\n\n\t\tthrow new Error('Unable to extract blob ID from response');\n\t}\n\n\t/**\n\t * Extract quilt patch IDs from Walrus response\n\t * @param response - Walrus API response\n\t * @returns Array of quilt patch IDs\n\t */\n\t#extractQuiltsPatchIds(response: WalrusResponse): string[] {\n\t\tif (response.storedQuiltBlobs) {\n\t\t\treturn response.storedQuiltBlobs.map((quilt) => quilt.quiltPatchId);\n\t\t}\n\n\t\tthrow new Error('Unable to extract quilt patch IDs from response');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { EncryptionPrimitivesConfig } from './types.js';\n\nexport const ENCRYPTION_PRIMITIVES_CONFIG = {\n\tkeySize: 256,\n\tnonceSize: 12,\n\tdekAlgorithm: 'AES-GCM',\n} as const satisfies EncryptionPrimitivesConfig;\n\nexport const ALLOWLISTED_SEAL_KEY_SERVERS = {\n\tmainnet: [],\n\ttestnet: [\n\t\t'0x73d05d62c18d9374e3ea529e8e0ed6161da1a141a94d3f76ae3fe4e99356db75',\n\t\t'0xf5d14a81a982144ae441cd7d64b09027f116a468bd36e7eca494f750591623c8',\n\t],\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { MessagingClientError } from '../error.js';\nimport { ENCRYPTION_PRIMITIVES_CONFIG } from './constants.js';\nimport type { EncryptionPrimitives, EncryptionPrimitivesConfig } from './types.js';\n\n/**\n * Default implementation of the KeyProvider interface using Web Crypto API\n */\nexport class WebCryptoPrimitives implements EncryptionPrimitives {\n\tprivate static instance: WebCryptoPrimitives;\n\tprivate config: EncryptionPrimitivesConfig;\n\n\tprivate constructor(config: EncryptionPrimitivesConfig) {\n\t\tthis.config = config;\n\t}\n\n\tpublic static getInstance(config?: EncryptionPrimitivesConfig): WebCryptoPrimitives {\n\t\tif (!WebCryptoPrimitives.instance) {\n\t\t\tWebCryptoPrimitives.instance = new WebCryptoPrimitives(\n\t\t\t\tconfig ?? ENCRYPTION_PRIMITIVES_CONFIG,\n\t\t\t);\n\t\t}\n\t\treturn WebCryptoPrimitives.instance;\n\t}\n\n\t// ===== Key methods =====\n\n\t/**\n\t * Generate a cryptographically secure random Data Encryption Key\n\t * @param length - Optional key length\n\t * @returns Random DEK bytes\n\t */\n\tasync generateDEK(length?: number): Promise<Uint8Array<ArrayBuffer>> {\n\t\tswitch (this.config.dekAlgorithm) {\n\t\t\tcase 'AES-GCM': {\n\t\t\t\tconst dek = await crypto.subtle.generateKey(\n\t\t\t\t\t{ name: this.config.dekAlgorithm, length: length ?? this.config.keySize },\n\t\t\t\t\ttrue,\n\t\t\t\t\t['encrypt', 'decrypt'],\n\t\t\t\t);\n\t\t\t\treturn await crypto.subtle.exportKey('raw', dek).then((dekData) => new Uint8Array(dekData));\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new MessagingClientError('Unsupported Data Encryption Key algorithm');\n\t\t}\n\t}\n\n\t/**\n\t * Generate a cryptographically secure nonce\n\t * @param length - Optional nonce length\n\t * @returns Random nonce bytes\n\t */\n\tgenerateNonce(length?: number): Uint8Array<ArrayBuffer> {\n\t\treturn crypto.getRandomValues(new Uint8Array(length ?? this.config.nonceSize));\n\t}\n\n\t// ===== Encryption methods =====\n\t/**\n\t * Encrypt bytes using a Data Encryption Key and nonce\n\t * @param key - The encryption key\n\t * @param nonce - The encryption nonce\n\t * @param aad - Additional authenticated data\n\t * @param bytesToEncrypt - The bytes to encrypt\n\t * @returns Encrypted bytes\n\t */\n\tasync encryptBytes(\n\t\tkey: Uint8Array<ArrayBuffer>,\n\t\tnonce: Uint8Array<ArrayBuffer>,\n\t\taad: Uint8Array<ArrayBuffer>,\n\t\tbytesToEncrypt: Uint8Array<ArrayBuffer>,\n\t): Promise<Uint8Array<ArrayBuffer>> {\n\t\tswitch (this.config.dekAlgorithm) {\n\t\t\tcase 'AES-GCM': {\n\t\t\t\tconst importedDEK = await crypto.subtle.importKey(\n\t\t\t\t\t'raw',\n\t\t\t\t\tkey,\n\t\t\t\t\t{ name: this.config.dekAlgorithm },\n\t\t\t\t\tfalse,\n\t\t\t\t\t['encrypt'],\n\t\t\t\t);\n\n\t\t\t\treturn await crypto.subtle\n\t\t\t\t\t.encrypt(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: this.config.dekAlgorithm,\n\t\t\t\t\t\t\tiv: nonce,\n\t\t\t\t\t\t\tadditionalData: aad,\n\t\t\t\t\t\t},\n\t\t\t\t\t\timportedDEK,\n\t\t\t\t\t\tbytesToEncrypt,\n\t\t\t\t\t)\n\t\t\t\t\t.then((encryptedData) => new Uint8Array(encryptedData));\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new MessagingClientError('Unsupported encryption algorithm');\n\t\t}\n\t}\n\n\t/**\n\t * Decrypt bytes using a Data Encryption Key and nonce\n\t * @param key - The decryption key\n\t * @param nonce - The decryption nonce\n\t * @param aad - Additional authenticated data\n\t * @param encryptedBytes - The bytes to decrypt\n\t * @returns Decrypted bytes\n\t */\n\tasync decryptBytes(\n\t\tkey: Uint8Array<ArrayBuffer>,\n\t\tnonce: Uint8Array<ArrayBuffer>,\n\t\taad: Uint8Array<ArrayBuffer>,\n\t\tencryptedBytes: Uint8Array<ArrayBuffer>,\n\t): Promise<Uint8Array<ArrayBuffer>> {\n\t\tswitch (this.config.dekAlgorithm) {\n\t\t\tcase 'AES-GCM': {\n\t\t\t\tconst importedDEK = await crypto.subtle.importKey(\n\t\t\t\t\t'raw',\n\t\t\t\t\tkey,\n\t\t\t\t\t{ name: this.config.dekAlgorithm },\n\t\t\t\t\tfalse,\n\t\t\t\t\t['decrypt'],\n\t\t\t\t);\n\n\t\t\t\treturn await crypto.subtle\n\t\t\t\t\t.decrypt(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: this.config.dekAlgorithm,\n\t\t\t\t\t\t\tiv: nonce,\n\t\t\t\t\t\t\tadditionalData: aad,\n\t\t\t\t\t\t},\n\t\t\t\t\t\timportedDEK,\n\t\t\t\t\t\tencryptedBytes,\n\t\t\t\t\t)\n\t\t\t\t\t.then((decryptedData) => new Uint8Array(decryptedData));\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new MessagingClientError('Unsupported encryption algorithm');\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SessionKey } from '@mysten/seal';\nimport type { MessagingCompatibleClient } from '../types.js';\nimport type { SealApproveContract, SessionKeyConfig } from './types.js';\n\n/**\n * Internal utility for managing SessionKey lifecycle.\n * Handles both external SessionKey instances and internal SessionKeyConfig management.\n *\n * @internal - Not exposed in public API\n */\nexport class SessionKeyManager {\n\tprivate managedSessionKey?: SessionKey;\n\n\tconstructor(\n\t\tprivate sessionKey: SessionKey | undefined,\n\t\tprivate readonly sessionKeyConfig: SessionKeyConfig | undefined,\n\t\tprivate readonly suiClient: MessagingCompatibleClient,\n\t\tprivate readonly sealApproveContract: SealApproveContract,\n\t) {\n\t\tif (!sessionKey && !sessionKeyConfig) {\n\t\t\tthrow new Error('Either sessionKey or sessionKeyConfig must be provided');\n\t\t}\n\t\tif (sessionKey && sessionKeyConfig) {\n\t\t\tthrow new Error('Cannot provide both sessionKey and sessionKeyConfig. Choose one.');\n\t\t}\n\t}\n\n\t/**\n\t * Get a valid SessionKey instance\n\t */\n\tasync getSessionKey(): Promise<SessionKey> {\n\t\t// External SessionKey case\n\t\tif (this.sessionKey) {\n\t\t\tif (this.sessionKey.isExpired()) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'The provided SessionKey has expired. Please provide a new SessionKey instance. ' +\n\t\t\t\t\t\t'When using an external SessionKey, lifecycle management is your responsibility.',\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn this.sessionKey;\n\t\t}\n\n\t\t// Managed SessionKey case\n\t\tif (this.sessionKeyConfig) {\n\t\t\tif (this.managedSessionKey && !this.managedSessionKey.isExpired()) {\n\t\t\t\treturn this.managedSessionKey;\n\t\t\t}\n\n\t\t\t// Create or recreate the SessionKey\n\t\t\tthis.managedSessionKey = await SessionKey.create({\n\t\t\t\taddress: this.sessionKeyConfig.address,\n\t\t\t\tsigner: this.sessionKeyConfig.signer,\n\t\t\t\tttlMin: this.sessionKeyConfig.ttlMin,\n\t\t\t\tmvrName: this.sessionKeyConfig.mvrName,\n\t\t\t\tpackageId: this.sealApproveContract.packageId,\n\t\t\t\tsuiClient: this.suiClient,\n\t\t\t});\n\n\t\t\treturn this.managedSessionKey;\n\t\t}\n\n\t\tthrow new Error('Invalid SessionKeyManager state');\n\t}\n\n\t/**\n\t * Update the external SessionKey instance\n\t */\n\tupdateExternalSessionKey(newSessionKey: SessionKey): void {\n\t\tif (!this.sessionKey) {\n\t\t\tthrow new Error('Cannot update external SessionKey when using managed SessionKey');\n\t\t}\n\t\tthis.sessionKey = newSessionKey;\n\t}\n\n\t/**\n\t * Force refresh the managed SessionKey\n\t */\n\tasync refreshManagedSessionKey(): Promise<SessionKey> {\n\t\tif (!this.sessionKeyConfig) {\n\t\t\tthrow new Error('Cannot refresh managed SessionKey when using external SessionKey');\n\t\t}\n\t\tthis.managedSessionKey = undefined;\n\t\treturn this.getSessionKey();\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SessionKey } from '@mysten/seal';\nimport { EncryptedObject } from '@mysten/seal';\nimport { fromHex, isValidSuiObjectId, toHex } from '@mysten/sui/utils';\n\nimport type {\n\tAttachmentMetadata,\n\tDecryptAttachmentDataOpts,\n\tDecryptAttachmentDataResult,\n\tDecryptAttachmentMetadataOpts,\n\tDecryptAttachmentMetadataResult,\n\tDecryptAttachmentOpts,\n\tDecryptAttachmentResult,\n\tDecryptChannelDEKOpts,\n\tDecryptMessageOpts,\n\tDecryptTextOpts,\n\tEncryptAttachmentOpts,\n\tEncryptedAttachmentPayload,\n\tEncryptedMessagePayload,\n\tEncryptedPayload,\n\tEncryptionPrimitives,\n\tEncryptMessageOpts,\n\tEncryptTextOpts,\n\tEnvelopeEncryptionConfig,\n\tGenerateEncryptedChannelDEKopts,\n\tSealApproveContract,\n\tSealConfig,\n\tSymmetricKey,\n} from './types.js';\nimport { WebCryptoPrimitives } from './webCryptoPrimitives.js';\nimport { Transaction } from '@mysten/sui/transactions';\nimport type { MessagingCompatibleClient } from '../types.js';\nimport { SessionKeyManager } from './sessionKeyManager.js';\n\n/**\n * Core envelope encryption service that utilizes Seal\n */\nexport class EnvelopeEncryption {\n\t#suiClient: MessagingCompatibleClient;\n\t#encryptionPrimitives: EncryptionPrimitives;\n\t#sessionKeyManager: SessionKeyManager;\n\t#sealApproveContract: SealApproveContract;\n\t#sealConfig: SealConfig;\n\n\tconstructor(config: EnvelopeEncryptionConfig) {\n\t\tthis.#suiClient = config.suiClient;\n\t\tthis.#sealApproveContract = config.sealApproveContract;\n\t\t// Initialize with defaults if not provided\n\t\tthis.#sealConfig = {\n\t\t\tthreshold: config.sealConfig?.threshold ?? 2,\n\t\t};\n\t\tthis.#encryptionPrimitives = config.encryptionPrimitives ?? WebCryptoPrimitives.getInstance();\n\n\t\tthis.#sessionKeyManager = new SessionKeyManager(\n\t\t\tconfig.sessionKey,\n\t\t\tconfig.sessionKeyConfig,\n\t\t\tthis.#suiClient,\n\t\t\tthis.#sealApproveContract,\n\t\t);\n\t}\n\n\t/**\n\t * Update the external SessionKey instance (useful for React context updates)\n\t */\n\tupdateSessionKey(newSessionKey: SessionKey): void {\n\t\tthis.#sessionKeyManager.updateExternalSessionKey(newSessionKey);\n\t}\n\n\t/**\n\t * Force refresh the managed SessionKey (useful for testing or manual refresh)\n\t */\n\tasync refreshSessionKey(): Promise<SessionKey> {\n\t\treturn this.#sessionKeyManager.refreshManagedSessionKey();\n\t}\n\n\t// ===== Encryption methods =====\n\t/**\n\t * Generate encrypted channel data encryption key\n\t * @param channelId - The channel ID\n\t * @returns Encrypted DEK bytes\n\t */\n\tasync generateEncryptedChannelDEK({\n\t\tchannelId,\n\t}: GenerateEncryptedChannelDEKopts): Promise<Uint8Array<ArrayBuffer>> {\n\t\tif (!isValidSuiObjectId(channelId)) {\n\t\t\tthrow new Error('The channelId provided is not a valid Sui Object ID');\n\t\t}\n\t\t// Generate a new DEK\n\t\tconst dek = await this.#encryptionPrimitives.generateDEK();\n\t\t// Encrypt with Seal before returning\n\t\tconst nonce = this.#encryptionPrimitives.generateNonce();\n\t\tconst sealPolicyBytes = fromHex(channelId); // Using channelId as the policy;\n\t\tconst id = toHex(new Uint8Array([...sealPolicyBytes, ...nonce]));\n\t\tconst { encryptedObject: encryptedDekBytes } = await this.#suiClient.seal.encrypt({\n\t\t\tthreshold: this.#sealConfig.threshold!,\n\t\t\tpackageId: this.#sealApproveContract.packageId,\n\t\t\tid,\n\t\t\tdata: dek,\n\t\t});\n\t\treturn new Uint8Array(encryptedDekBytes);\n\t}\n\n\t/**\n\t * Generate a random nonce\n\t * @returns Random nonce bytes\n\t */\n\tgenerateNonce(): Uint8Array<ArrayBuffer> {\n\t\treturn this.#encryptionPrimitives.generateNonce();\n\t}\n\n\t/**\n\t * Encrypt text message\n\t * @param text - The text to encrypt\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted payload with ciphertext and nonce\n\t */\n\tasync encryptText({\n\t\ttext,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptTextOpts): Promise<EncryptedPayload> {\n\t\tconst nonce = this.#encryptionPrimitives.generateNonce();\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst ciphertext = await this.#encryptionPrimitives.encryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tnew Uint8Array(new TextEncoder().encode(text)),\n\t\t);\n\t\treturn {\n\t\t\tencryptedBytes: ciphertext,\n\t\t\tnonce,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt text message\n\t * @param encryptedBytes - The encrypted text bytes\n\t * @param nonce - The encryption nonce\n\t * @param channelId - The channel ID\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param sender - The sender address\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted text string\n\t */\n\tasync decryptText({\n\t\tencryptedBytes: ciphertext,\n\t\tnonce,\n\t\tchannelId,\n\t\tencryptedKey,\n\t\tsender,\n\t\tmemberCapId,\n\t}: DecryptTextOpts): Promise<string> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst decryptedBytes = await this.#encryptionPrimitives.decryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, encryptedKey.version, sender),\n\t\t\tciphertext,\n\t\t);\n\t\treturn new TextDecoder().decode(decryptedBytes);\n\t}\n\n\t/**\n\t * Encrypt attachment file and metadata\n\t * @param file - The file to encrypt\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted attachment payload with data and metadata\n\t */\n\tasync encryptAttachment({\n\t\tfile,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptAttachmentOpts): Promise<EncryptedAttachmentPayload> {\n\t\t// Encrypt the attachment Data\n\t\tconst { encryptedBytes: encryptedData, nonce: dataNonce } = await this.encryptAttachmentData({\n\t\t\tfile,\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t});\n\t\t// Encrypt the attachment Metadata\n\t\tconst { encryptedBytes: encryptedMetadata, nonce: metadataNonce } =\n\t\t\tawait this.encryptAttachmentMetadata({\n\t\t\t\tfile,\n\t\t\t\tchannelId,\n\t\t\t\tsender,\n\t\t\t\tencryptedKey,\n\t\t\t\tmemberCapId,\n\t\t\t});\n\n\t\treturn {\n\t\t\tdata: { encryptedBytes: encryptedData, nonce: dataNonce },\n\t\t\tmetadata: { encryptedBytes: encryptedMetadata, nonce: metadataNonce },\n\t\t};\n\t}\n\n\t/**\n\t * Encrypt attachment file data\n\t * @param file - The file to encrypt\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted payload with data and nonce\n\t */\n\tasync encryptAttachmentData({\n\t\tfile,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptAttachmentOpts): Promise<EncryptedPayload> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst nonce = this.generateNonce();\n\n\t\t// Read file as ArrayBuffer\n\t\tconst fileData = await file.arrayBuffer();\n\n\t\t// Encrypt file data\n\t\tconst encryptedData = await this.#encryptionPrimitives.encryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tnew Uint8Array(fileData),\n\t\t);\n\t\treturn { encryptedBytes: encryptedData, nonce };\n\t}\n\n\t/**\n\t * Encrypt attachment metadata\n\t * @param file - The file to get metadata from\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted payload with metadata and nonce\n\t */\n\tasync encryptAttachmentMetadata({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tfile,\n\t}: EncryptAttachmentOpts): Promise<EncryptedPayload> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst nonce = this.generateNonce();\n\n\t\t// Extract file metadata\n\t\tconst metadata: AttachmentMetadata = {\n\t\t\tfileName: file.name,\n\t\t\tmimeType: file.type,\n\t\t\tfileSize: file.size,\n\t\t};\n\n\t\t// Encrypt metadata as one piece of data\n\t\tconst metadataStr = JSON.stringify(metadata);\n\t\tconst encryptedMetadata = await this.#encryptionPrimitives.encryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tnew Uint8Array(new TextEncoder().encode(metadataStr)),\n\t\t);\n\n\t\treturn {\n\t\t\tencryptedBytes: encryptedMetadata,\n\t\t\tnonce,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt attachment metadata\n\t * @param encryptedBytes - The encrypted metadata bytes\n\t * @param nonce - The encryption nonce\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted attachment metadata\n\t */\n\tasync decryptAttachmentMetadata({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tencryptedBytes,\n\t\tnonce,\n\t}: DecryptAttachmentMetadataOpts): Promise<DecryptAttachmentMetadataResult> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\t// Decrypt metadata\n\t\tconst decryptedMetadataBytes = await this.#encryptionPrimitives.decryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tencryptedBytes,\n\t\t);\n\t\t// Parse the bytes back to JSON\n\t\tconst metadataStr = new TextDecoder().decode(decryptedMetadataBytes);\n\t\tconst { fileName, mimeType, fileSize } = JSON.parse(metadataStr);\n\n\t\treturn {\n\t\t\tfileName,\n\t\t\tmimeType,\n\t\t\tfileSize,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt attachment file data\n\t * @param encryptedBytes - The encrypted data bytes\n\t * @param nonce - The encryption nonce\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted attachment data\n\t */\n\tasync decryptAttachmentData({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tencryptedBytes,\n\t\tnonce,\n\t}: DecryptAttachmentDataOpts): Promise<DecryptAttachmentDataResult> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\t\tconst decryptedData = await this.#encryptionPrimitives.decryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tencryptedBytes,\n\t\t);\n\t\treturn { data: decryptedData };\n\t}\n\n\t/**\n\t * Decrypt attachment file and metadata\n\t * @param data - The encrypted data payload\n\t * @param metadata - The encrypted metadata payload\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted attachment with data and metadata\n\t */\n\tasync decryptAttachment({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tdata,\n\t\tmetadata,\n\t}: DecryptAttachmentOpts): Promise<DecryptAttachmentResult> {\n\t\t// Decrypt file data\n\t\tconst decryptedData = await this.decryptAttachmentData({\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t\tencryptedBytes: data.encryptedBytes,\n\t\t\tnonce: data.nonce,\n\t\t});\n\n\t\t// Decrypt metadata\n\t\tconst { fileName, mimeType, fileSize } = await this.decryptAttachmentMetadata({\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t\tencryptedBytes: metadata.encryptedBytes,\n\t\t\tnonce: metadata.nonce,\n\t\t});\n\n\t\treturn {\n\t\t\tdata: decryptedData.data,\n\t\t\tfileName,\n\t\t\tmimeType,\n\t\t\tfileSize,\n\t\t};\n\t}\n\n\t/**\n\t * Encrypt message text and attachments\n\t * @param text - The message text\n\t * @param attachments - Optional file attachments\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted message payload\n\t */\n\tasync encryptMessage({\n\t\ttext,\n\t\tattachments,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptMessageOpts): Promise<EncryptedMessagePayload> {\n\t\t// Encrypt text\n\t\tconst { encryptedBytes: ciphertext, nonce } = await this.encryptText({\n\t\t\ttext,\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\t// If there are no attachments, return early\n\t\tif (!attachments || attachments.length === 0) {\n\t\t\treturn { text: { encryptedBytes: ciphertext, nonce } };\n\t\t}\n\n\t\t// Encrypt attachments in parallel\n\t\tconst encryptedAttachments = await Promise.all(\n\t\t\tattachments.map((file) =>\n\t\t\t\tthis.encryptAttachment({\n\t\t\t\t\tfile,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\ttext: { encryptedBytes: ciphertext, nonce },\n\t\t\tattachments: encryptedAttachments,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt message text and attachments\n\t * @param ciphertext - The encrypted text bytes\n\t * @param nonce - The encryption nonce\n\t * @param attachments - Optional encrypted attachments\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted message with text and attachments\n\t */\n\tasync decryptMessage({\n\t\tciphertext,\n\t\tnonce,\n\t\tattachments,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: DecryptMessageOpts): Promise<{ text: string; attachments?: DecryptAttachmentResult[] }> {\n\t\t// Decrypt text\n\t\tconst text = await this.decryptText({\n\t\t\tencryptedBytes: ciphertext,\n\t\t\tnonce,\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\t// If there are no attachments, return early\n\t\tif (!attachments || attachments.length === 0) {\n\t\t\treturn { text };\n\t\t}\n\n\t\t// Decrypt attachments in parallel\n\t\tconst decryptedAttachments = await Promise.all(\n\t\t\tattachments.map((attachment) =>\n\t\t\t\tthis.decryptAttachment({\n\t\t\t\t\t...attachment,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\ttext,\n\t\t\tattachments: decryptedAttachments,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt encrypted channel data encryption key using Seal\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param channelId - The channel ID\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted symmetric key\n\t */\n\tasync decryptChannelDEK({\n\t\tencryptedKey,\n\t\tchannelId,\n\t\tmemberCapId,\n\t}: DecryptChannelDEKOpts): Promise<SymmetricKey> {\n\t\tif (!isValidSuiObjectId(channelId)) {\n\t\t\tthrow new Error('The channelId provided is not a valid Sui Object ID');\n\t\t}\n\t\tif (!isValidSuiObjectId(memberCapId)) {\n\t\t\tthrow new Error('The memberCapId provided is not a valid Sui Object ID');\n\t\t}\n\n\t\t// === Decrypt the cached key ===\n\t\t// Prepare seal_approve ptb\n\n\t\tconst channelIdBytes = EncryptedObject.parse(encryptedKey.encryptedBytes).id;\n\n\t\tconst tx = new Transaction();\n\t\ttx.moveCall({\n\t\t\ttarget: `${this.#sealApproveContract.packageId}::${this.#sealApproveContract.module}::${this.#sealApproveContract.functionName}`,\n\t\t\targuments: [\n\t\t\t\t// Seal Identity Bytes: Channel object ID\n\t\t\t\t// key form: [packageId][channelId][random nonce]\n\t\t\t\ttx.pure.vector('u8', fromHex(channelIdBytes)),\n\t\t\t\t// Channel Object\n\t\t\t\ttx.object(channelId),\n\t\t\t\t// Member Cap Object\n\t\t\t\ttx.object(memberCapId),\n\t\t\t],\n\t\t});\n\t\tconst txBytes = await tx.build({ client: this.#suiClient, onlyTransactionKind: true });\n\t\t// Decrypt using Seal\n\t\tlet dekBytes: Uint8Array;\n\t\ttry {\n\t\t\tdekBytes = await this.#suiClient.seal.decrypt({\n\t\t\t\tdata: encryptedKey.encryptedBytes,\n\t\t\t\tsessionKey: await this.#sessionKeyManager.getSessionKey(),\n\t\t\t\ttxBytes,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.error('Error decrypting channel DEK', error);\n\t\t\tthrow error;\n\t\t}\n\t\t// const dekBytes = await this.#suiClient.seal.decrypt({\n\t\t// \tdata: encryptedKey.encryptedBytes,\n\t\t// \tsessionKey: await this.getSessionKey(),\n\t\t// \ttxBytes,\n\t\t// });\n\n\t\treturn {\n\t\t\t$kind: 'Unencrypted',\n\t\t\tbytes: new Uint8Array(dekBytes || new Uint8Array()),\n\t\t\tversion: encryptedKey.version,\n\t\t};\n\t}\n\n\t// ===== Private methods =====\n\n\t/**\n\t * Get Additional Authenticated Data for encryption/decryption\n\t * @param channelId - The channel ID\n\t * @param keyVersion - The key version\n\t * @param sender - The sender address\n\t * @returns AAD bytes\n\t */\n\tprivate encryptionAAD(\n\t\tchannelId: string,\n\t\tkeyVersion: number,\n\t\tsender: string,\n\t): Uint8Array<ArrayBuffer> {\n\t\treturn new Uint8Array(new TextEncoder().encode(channelId + keyVersion.toString() + sender));\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::creator_cap';\nexport const CreatorCap = new MoveStruct({\n\tname: `${$moduleName}::CreatorCap`,\n\tfields: {\n\t\tid: object.UID,\n\t\tchannel_id: bcs.Address,\n\t},\n});\nexport interface TransferToSenderArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TransferToSenderOptions {\n\tpackage?: string;\n\targuments: TransferToSenderArguments | [self: RawTransactionArgument<string>];\n}\n/** Transfer a CreatorCap to the transaction sender. */\nexport function transferToSender(options: TransferToSenderOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::creator_cap::CreatorCap`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'creator_cap',\n\t\t\tfunction: 'transfer_to_sender',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::member_cap';\nexport const MemberCap = new MoveStruct({\n\tname: `${$moduleName}::MemberCap`,\n\tfields: {\n\t\tid: object.UID,\n\t\tchannel_id: bcs.Address,\n\t},\n});\nexport interface TransferToRecipientArguments {\n\tcap: RawTransactionArgument<string>;\n\tcreatorCap: RawTransactionArgument<string>;\n\trecipient: RawTransactionArgument<string>;\n}\nexport interface TransferToRecipientOptions {\n\tpackage?: string;\n\targuments:\n\t\t| TransferToRecipientArguments\n\t\t| [\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tcreatorCap: RawTransactionArgument<string>,\n\t\t\t\trecipient: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Transfer a MemberCap to the specified address. Should only be called by a\n * Channel Creator, after a Channel is created and shared.\n */\nexport function transferToRecipient(options: TransferToRecipientOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t`${packageAddress}::creator_cap::CreatorCap`,\n\t\t'address',\n\t] satisfies string[];\n\tconst parameterNames = ['cap', 'creatorCap', 'recipient'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'member_cap',\n\t\t\tfunction: 'transfer_to_recipient',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TransferMemberCapsArguments {\n\tmemberAddresses: RawTransactionArgument<string[]>;\n\tmemberCaps: RawTransactionArgument<string[]>;\n\tcreatorCap: RawTransactionArgument<string>;\n}\nexport interface TransferMemberCapsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| TransferMemberCapsArguments\n\t\t| [\n\t\t\t\tmemberAddresses: RawTransactionArgument<string[]>,\n\t\t\t\tmemberCaps: RawTransactionArgument<string[]>,\n\t\t\t\tcreatorCap: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Transfer MemberCaps to the associated addresses Should only be called by a\n * Channel Creator, after a Channel is created and shared.\n */\nexport function transferMemberCaps(options: TransferMemberCapsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t'vector<address>',\n\t\t`vector<${packageAddress}::member_cap::MemberCap>`,\n\t\t`${packageAddress}::creator_cap::CreatorCap`,\n\t] satisfies string[];\n\tconst parameterNames = ['memberAddresses', 'memberCaps', 'creatorCap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'member_cap',\n\t\t\tfunction: 'transfer_member_caps',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ChannelIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ChannelIdOptions {\n\tpackage?: string;\n\targuments: ChannelIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function channelId(options: ChannelIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::member_cap::MemberCap`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'member_cap',\n\t\t\tfunction: 'channel_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveTuple, MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/sui-stack-messaging::config';\nexport const EditConfig = new MoveTuple({\n\tname: `${$moduleName}::EditConfig`,\n\tfields: [bcs.bool()],\n});\nexport const Config = new MoveStruct({\n\tname: `${$moduleName}::Config`,\n\tfields: {\n\t\tmax_channel_members: bcs.u64(),\n\t\tmax_channel_roles: bcs.u64(),\n\t\tmax_message_text_chars: bcs.u64(),\n\t\tmax_message_attachments: bcs.u64(),\n\t\trequire_invitation: bcs.bool(),\n\t\trequire_request: bcs.bool(),\n\t\temit_events: bcs.bool(),\n\t},\n});\nexport interface DefaultOptions {\n\tpackage?: string;\n\targuments?: [];\n}\nexport function _default(options: DefaultOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'default',\n\t\t});\n}\nexport interface NewArguments {\n\tmaxChannelMembers: RawTransactionArgument<number | bigint>;\n\tmaxChannelRoles: RawTransactionArgument<number | bigint>;\n\tmaxMessageTextChars: RawTransactionArgument<number | bigint>;\n\tmaxMessageAttachments: RawTransactionArgument<number | bigint>;\n\trequireInvitation: RawTransactionArgument<boolean>;\n\trequireRequest: RawTransactionArgument<boolean>;\n\temitEvents: RawTransactionArgument<boolean>;\n}\nexport interface NewOptions {\n\tpackage?: string;\n\targuments:\n\t\t| NewArguments\n\t\t| [\n\t\t\t\tmaxChannelMembers: RawTransactionArgument<number | bigint>,\n\t\t\t\tmaxChannelRoles: RawTransactionArgument<number | bigint>,\n\t\t\t\tmaxMessageTextChars: RawTransactionArgument<number | bigint>,\n\t\t\t\tmaxMessageAttachments: RawTransactionArgument<number | bigint>,\n\t\t\t\trequireInvitation: RawTransactionArgument<boolean>,\n\t\t\t\trequireRequest: RawTransactionArgument<boolean>,\n\t\t\t\temitEvents: RawTransactionArgument<boolean>,\n\t\t  ];\n}\nexport function _new(options: NewOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = ['u64', 'u64', 'u64', 'u64', 'bool', 'bool', 'bool'] satisfies string[];\n\tconst parameterNames = [\n\t\t'maxChannelMembers',\n\t\t'maxChannelRoles',\n\t\t'maxMessageTextChars',\n\t\t'maxMessageAttachments',\n\t\t'requireInvitation',\n\t\t'requireRequest',\n\t\t'emitEvents',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NoneOptions {\n\tpackage?: string;\n\targuments?: [];\n}\nexport function none(options: NoneOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'none',\n\t\t});\n}\nexport interface IsValidConfigArguments {\n\tconfig: RawTransactionArgument<string>;\n}\nexport interface IsValidConfigOptions {\n\tpackage?: string;\n\targuments: IsValidConfigArguments | [config: RawTransactionArgument<string>];\n}\nexport function isValidConfig(options: IsValidConfigOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['config'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'is_valid_config',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigMaxChannelMembersArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigMaxChannelMembersOptions {\n\tpackage?: string;\n\targuments: ConfigMaxChannelMembersArguments | [self: RawTransactionArgument<string>];\n}\nexport function configMaxChannelMembers(options: ConfigMaxChannelMembersOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_max_channel_members',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigMaxChannelRolesArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigMaxChannelRolesOptions {\n\tpackage?: string;\n\targuments: ConfigMaxChannelRolesArguments | [self: RawTransactionArgument<string>];\n}\nexport function configMaxChannelRoles(options: ConfigMaxChannelRolesOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_max_channel_roles',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigMaxMessageTextCharsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigMaxMessageTextCharsOptions {\n\tpackage?: string;\n\targuments: ConfigMaxMessageTextCharsArguments | [self: RawTransactionArgument<string>];\n}\nexport function configMaxMessageTextChars(options: ConfigMaxMessageTextCharsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_max_message_text_chars',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigMaxMessageAttachmentsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigMaxMessageAttachmentsOptions {\n\tpackage?: string;\n\targuments: ConfigMaxMessageAttachmentsArguments | [self: RawTransactionArgument<string>];\n}\nexport function configMaxMessageAttachments(options: ConfigMaxMessageAttachmentsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_max_message_attachments',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigRequireInvitationArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigRequireInvitationOptions {\n\tpackage?: string;\n\targuments: ConfigRequireInvitationArguments | [self: RawTransactionArgument<string>];\n}\nexport function configRequireInvitation(options: ConfigRequireInvitationOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_require_invitation',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigRequireRequestArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigRequireRequestOptions {\n\tpackage?: string;\n\targuments: ConfigRequireRequestArguments | [self: RawTransactionArgument<string>];\n}\nexport function configRequireRequest(options: ConfigRequireRequestOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_require_request',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ConfigEmitEventsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ConfigEmitEventsOptions {\n\tpackage?: string;\n\targuments: ConfigEmitEventsArguments | [self: RawTransactionArgument<string>];\n}\nexport function configEmitEvents(options: ConfigEmitEventsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::config::Config`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'config',\n\t\t\tfunction: 'config_emit_events',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { Transaction } from '@mysten/sui/transactions';\nimport type { TransactionResult } from '@mysten/sui/transactions';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { deriveDynamicFieldID } from '@mysten/sui/utils';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Experimental_SuiClientTypes } from '@mysten/sui/experimental';\nimport type { SessionKey } from '@mysten/seal';\n\nimport {\n\t_new as newChannel,\n\taddEncryptedKey,\n\tshare as shareChannel,\n\tsendMessage,\n\taddMembers,\n\tChannel,\n} from './contracts/sui_stack_messaging/channel.js';\n\nimport { _new as newAttachment, Attachment } from './contracts/sui_stack_messaging/attachment.js';\n\nimport type {\n\tChannelMembershipsRequest,\n\tChannelMembershipsResponse,\n\tChannelMembersResponse,\n\tChannelMember,\n\tCreateChannelFlow,\n\tCreateChannelFlowGetGeneratedCapsOpts,\n\tCreateChannelFlowOpts,\n\tGetLatestMessagesRequest,\n\tMessagingClientExtensionOptions,\n\tMessagingClientOptions,\n\tMessagingCompatibleClient,\n\tMessagingPackageConfig,\n\tParsedChannelObject,\n\tParsedMessageObject,\n\tDecryptMessageResult,\n\tLazyDecryptAttachmentResult,\n\tGetChannelMessagesRequest,\n\tDecryptedChannelObject,\n\tDecryptedMessagesResponse,\n\tDecryptedChannelObjectsByAddressResponse,\n\tGetChannelObjectsByChannelIdsRequest,\n} from './types.js';\nimport {\n\tMAINNET_MESSAGING_PACKAGE_CONFIG,\n\tTESTNET_MESSAGING_PACKAGE_CONFIG,\n\tDEFAULT_SEAL_APPROVE_CONTRACT,\n} from './constants.js';\nimport { MessagingClientError } from './error.js';\nimport type { StorageAdapter } from './storage/adapters/storage.js';\nimport { WalrusStorageAdapter } from './storage/adapters/walrus/walrus.js';\nimport type { EncryptedSymmetricKey, SealConfig } from './encryption/types.js';\nimport { EnvelopeEncryption } from './encryption/envelopeEncryption.js';\n\nimport type { RawTransactionArgument } from './contracts/utils/index.js';\nimport {\n\tCreatorCap,\n\ttransferToSender as transferCreatorCap,\n} from './contracts/sui_stack_messaging/creator_cap.js';\nimport {\n\tMemberCap,\n\ttransferMemberCaps,\n\ttransferToRecipient as transferMemberCap,\n} from './contracts/sui_stack_messaging/member_cap.js';\nimport { none as noneConfig } from './contracts/sui_stack_messaging/config.js';\nimport { Message } from './contracts/sui_stack_messaging/message.js';\n\nexport class SuiStackMessagingClient {\n\t#suiClient: MessagingCompatibleClient;\n\t#packageConfig: MessagingPackageConfig;\n\t#storage: (client: MessagingCompatibleClient) => StorageAdapter;\n\t#envelopeEncryption: EnvelopeEncryption;\n\t#sealConfig: SealConfig;\n\t// TODO: Leave the responsibility of caching to the caller\n\t// #encryptedChannelDEKCache: Map<string, EncryptedSymmetricKey> = new Map(); // channelId --> EncryptedSymmetricKey\n\t// #channelMessagesTableIdCache: Map<string, string> = new Map<string, string>(); // channelId --> messagesTableId\n\n\tprivate constructor(public options: MessagingClientOptions) {\n\t\tthis.#suiClient = options.suiClient;\n\t\tthis.#storage = options.storage;\n\n\t\t// Initialize Seal config with defaults\n\t\tthis.#sealConfig = {\n\t\t\tthreshold: options.sealConfig?.threshold ?? 2, // Default threshold of 2\n\t\t};\n\n\t\t// Auto-detect network from client or use package config\n\t\tif (!options.packageConfig) {\n\t\t\tconst network = this.#suiClient.network;\n\t\t\tswitch (network) {\n\t\t\t\tcase 'testnet':\n\t\t\t\t\tthis.#packageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mainnet':\n\t\t\t\t\tthis.#packageConfig = MAINNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Fallback to testnet for unrecognized networks\n\t\t\t\t\tthis.#packageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#packageConfig = options.packageConfig;\n\t\t}\n\n\t\t// Resolve sealApproveContract with defaults (use same packageId as messaging package)\n\t\tconst sealApproveContract = this.#packageConfig.sealApproveContract ?? {\n\t\t\tpackageId: this.#packageConfig.packageId,\n\t\t\t...DEFAULT_SEAL_APPROVE_CONTRACT,\n\t\t};\n\n\t\t// Initialize EnvelopeEncryption directly\n\t\tthis.#envelopeEncryption = new EnvelopeEncryption({\n\t\t\tsuiClient: this.#suiClient,\n\t\t\tsealApproveContract,\n\t\t\tsessionKey: options.sessionKey,\n\t\t\tsessionKeyConfig: options.sessionKeyConfig,\n\t\t\tsealConfig: this.#sealConfig,\n\t\t});\n\t}\n\n\tstatic experimental_asClientExtension(options: MessagingClientExtensionOptions) {\n\t\treturn {\n\t\t\tname: 'messaging' as const,\n\t\t\tregister: (client: MessagingCompatibleClient) => {\n\t\t\t\tconst sealClient = client.seal;\n\n\t\t\t\tif (!sealClient) {\n\t\t\t\t\tthrow new MessagingClientError('SealClient extension is required for MessagingClient');\n\t\t\t\t}\n\n\t\t\t\t// Check if storage configuration is provided\n\t\t\t\tif (!('storage' in options) && !('walrusStorageConfig' in options)) {\n\t\t\t\t\tthrow new MessagingClientError(\n\t\t\t\t\t\t'Either a custom storage adapter via \"storage\" option or explicit Walrus storage configuration via \"walrusStorageConfig\" option must be provided. Fallback to default Walrus endpoints is not supported.',\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Auto-detect network from the client or use default package config\n\t\t\t\tlet packageConfig = options.packageConfig;\n\t\t\t\tif (!packageConfig) {\n\t\t\t\t\tconst network = client.network;\n\t\t\t\t\tswitch (network) {\n\t\t\t\t\t\tcase 'testnet':\n\t\t\t\t\t\t\tpackageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mainnet':\n\t\t\t\t\t\t\tpackageConfig = MAINNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// Fallback to testnet if network is not recognized\n\t\t\t\t\t\t\tpackageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Handle storage configuration\n\t\t\t\tconst storage =\n\t\t\t\t\t'storage' in options\n\t\t\t\t\t\t? (c: MessagingCompatibleClient) => options.storage(c)\n\t\t\t\t\t\t: (c: MessagingCompatibleClient) => {\n\t\t\t\t\t\t\t\t// WalrusClient is optional - we can use WalrusStorageAdapter without it\n\t\t\t\t\t\t\t\t// In the future, when WalrusClient SDK is used, we can check for its presence and use different logic\n\t\t\t\t\t\t\t\treturn new WalrusStorageAdapter(c, options.walrusStorageConfig);\n\t\t\t\t\t\t\t};\n\n\t\t\t\treturn new SuiStackMessagingClient({\n\t\t\t\t\tsuiClient: client,\n\t\t\t\t\tstorage,\n\t\t\t\t\tpackageConfig,\n\t\t\t\t\tsessionKey: 'sessionKey' in options ? options.sessionKey : undefined,\n\t\t\t\t\tsessionKeyConfig: 'sessionKeyConfig' in options ? options.sessionKeyConfig : undefined,\n\t\t\t\t\tsealConfig: options.sealConfig,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t}\n\n\t// ===== Private Helper Methods =====\n\n\t/**\n\t * Get user's member cap ID for a specific channel\n\t * @param userAddress - The user's address\n\t * @param channelId - The channel ID\n\t * @returns Member cap ID\n\t */\n\tasync #getUserMemberCapId(userAddress: string, channelId: string): Promise<string> {\n\t\tlet cursor: string | null = null;\n\t\tlet hasNextPage = true;\n\n\t\twhile (hasNextPage) {\n\t\t\tconst memberships = await this.getChannelMemberships({\n\t\t\t\taddress: userAddress,\n\t\t\t\tcursor,\n\t\t\t});\n\n\t\t\tconst membership = memberships.memberships.find((m) => m.channel_id === channelId);\n\n\t\t\tif (membership) {\n\t\t\t\treturn membership.member_cap_id;\n\t\t\t}\n\n\t\t\tcursor = memberships.cursor;\n\t\t\thasNextPage = memberships.hasNextPage;\n\t\t}\n\n\t\tthrow new MessagingClientError(`User ${userAddress} is not a member of channel ${channelId}`);\n\t}\n\n\t/**\n\t * Get encryption key from channel\n\t * @param channel - The channel object\n\t * @returns Encrypted symmetric key\n\t */\n\tasync #getEncryptionKeyFromChannel(channel: ParsedChannelObject): Promise<EncryptedSymmetricKey> {\n\t\tconst encryptedKeyBytes = channel.encryption_key_history.latest;\n\t\tconst keyVersion = channel.encryption_key_history.latest_version;\n\n\t\treturn {\n\t\t\t$kind: 'Encrypted' as const,\n\t\t\tencryptedBytes: new Uint8Array(encryptedKeyBytes),\n\t\t\tversion: keyVersion,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt a message (private method)\n\t * @param message - The encrypted message object\n\t * @param channelId - The channel ID\n\t * @param memberCapId - The member cap ID\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @returns Decrypted message with lazy-loaded attachments\n\t */\n\tasync #decryptMessage(\n\t\tmessage: (typeof Message)['$inferType'],\n\t\tchannelId: string,\n\t\tmemberCapId: string,\n\t\tencryptedKey: EncryptedSymmetricKey,\n\t): Promise<DecryptMessageResult> {\n\t\t// 1. Decrypt text\n\t\tconst text = await this.#envelopeEncryption.decryptText({\n\t\t\tencryptedBytes: new Uint8Array(message.ciphertext),\n\t\t\tnonce: new Uint8Array(message.nonce),\n\t\t\tsender: message.sender,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t\tencryptedKey,\n\t\t});\n\n\t\t// 2. If no attachments, return early\n\t\tif (!message.attachments || message.attachments.length === 0) {\n\t\t\treturn { text, attachments: [], sender: message.sender, createdAtMs: message.created_at_ms };\n\t\t}\n\n\t\t// 3. Decrypt attachments metadata\n\t\tconst attachmentsMetadata = await Promise.all(\n\t\t\tmessage.attachments.map(async (attachment) => {\n\t\t\t\t// Use the encrypted_metadata field directly - no download needed for metadata\n\t\t\t\tconst metadata = await this.#envelopeEncryption.decryptAttachmentMetadata({\n\t\t\t\t\tencryptedBytes: new Uint8Array(attachment.encrypted_metadata),\n\t\t\t\t\tnonce: new Uint8Array(attachment.metadata_nonce),\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender: message.sender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tmetadata,\n\t\t\t\t\tattachment, // Keep reference to original attachment\n\t\t\t\t};\n\t\t\t}),\n\t\t);\n\n\t\t// 4. Create lazy-loaded attachmentsData\n\t\tconst lazyAttachmentsDataPromises: LazyDecryptAttachmentResult[] = attachmentsMetadata.map(\n\t\t\t({ metadata, attachment }) => ({\n\t\t\t\t...metadata,\n\t\t\t\tdata: this.#createLazyAttachmentDataPromise({\n\t\t\t\t\tblobRef: attachment.blob_ref,\n\t\t\t\t\tnonce: new Uint8Array(attachment.data_nonce),\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender: message.sender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t}),\n\t\t\t}),\n\t\t);\n\n\t\treturn {\n\t\t\ttext,\n\t\t\tsender: message.sender,\n\t\t\tcreatedAtMs: message.created_at_ms,\n\t\t\tattachments: lazyAttachmentsDataPromises,\n\t\t};\n\t}\n\n\t// ===== Read Path =====\n\n\t/**\n\t * Get channel memberships for a user\n\t * @param request - Pagination and filter options\n\t * @returns Channel memberships with pagination info\n\t */\n\tasync getChannelMemberships(\n\t\trequest: ChannelMembershipsRequest,\n\t): Promise<ChannelMembershipsResponse> {\n\t\tconst memberCapsRes = await this.#suiClient.core.getOwnedObjects({\n\t\t\t...request,\n\t\t\ttype: MemberCap.name.replace('@local-pkg/sui-stack-messaging', this.#packageConfig.packageId),\n\t\t});\n\t\t// Filter out any error objects\n\t\tconst validObjects = memberCapsRes.objects.filter(\n\t\t\t(object): object is Experimental_SuiClientTypes.ObjectResponse => !(object instanceof Error),\n\t\t);\n\n\t\tif (validObjects.length === 0) {\n\t\t\treturn {\n\t\t\t\thasNextPage: memberCapsRes.hasNextPage,\n\t\t\t\tcursor: memberCapsRes.cursor,\n\t\t\t\tmemberships: [],\n\t\t\t};\n\t\t}\n\n\t\t// Get all object contents efficiently\n\t\tconst contents = await this.#getObjectContents(validObjects);\n\n\t\t// Parse all MemberCaps\n\t\tconst memberships = await Promise.all(\n\t\t\tcontents.map(async (content) => {\n\t\t\t\tconst parsedMemberCap = MemberCap.parse(content);\n\t\t\t\treturn { member_cap_id: parsedMemberCap.id.id, channel_id: parsedMemberCap.channel_id };\n\t\t\t}),\n\t\t);\n\n\t\treturn {\n\t\t\thasNextPage: memberCapsRes.hasNextPage,\n\t\t\tcursor: memberCapsRes.cursor,\n\t\t\tmemberships,\n\t\t};\n\t}\n\n\t/**\n\t * Get channel objects for a user (returns decrypted data)\n\t * @param request - Pagination and filter options\n\t * @returns Decrypted channel objects with pagination info\n\t */\n\tasync getChannelObjectsByAddress(\n\t\trequest: ChannelMembershipsRequest,\n\t): Promise<DecryptedChannelObjectsByAddressResponse> {\n\t\tconst membershipsPaginated = await this.getChannelMemberships(request);\n\t\tconst channelObjects = await this.getChannelObjectsByChannelIds({\n\t\t\tchannelIds: membershipsPaginated.memberships.map((m) => m.channel_id),\n\t\t\tuserAddress: request.address,\n\t\t\tmemberCapIds: membershipsPaginated.memberships.map((m) => m.member_cap_id),\n\t\t});\n\n\t\treturn {\n\t\t\thasNextPage: membershipsPaginated.hasNextPage,\n\t\t\tcursor: membershipsPaginated.cursor,\n\t\t\tchannelObjects,\n\t\t};\n\t}\n\n\t/**\n\t * Get channel objects by channel IDs (returns decrypted data)\n\t * @param request - Request with channel IDs and user address, and optionally memberCapIds\n\t * @returns Decrypted channel objects\n\t */\n\tasync getChannelObjectsByChannelIds(\n\t\trequest: GetChannelObjectsByChannelIdsRequest,\n\t): Promise<DecryptedChannelObject[]> {\n\t\tconst { channelIds, userAddress, memberCapIds } = request;\n\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: channelIds,\n\t\t});\n\n\t\tconst parsedChannels = await Promise.all(\n\t\t\tchannelObjectsRes.objects.map(async (object) => {\n\t\t\t\tif (object instanceof Error || !object.content) {\n\t\t\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${object}`);\n\t\t\t\t}\n\t\t\t\treturn Channel.parse(await object.content);\n\t\t\t}),\n\t\t);\n\n\t\t// Decrypt each channel's last_message if it exists\n\t\tconst decryptedChannels = await Promise.all(\n\t\t\tparsedChannels.map(async (channel, index) => {\n\t\t\t\tconst decryptedChannel: DecryptedChannelObject = {\n\t\t\t\t\t...channel,\n\t\t\t\t\tlast_message: null,\n\t\t\t\t};\n\n\t\t\t\t// Decrypt last_message if it exists\n\t\t\t\tif (channel.last_message) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Use provided memberCapId or fetch it\n\t\t\t\t\t\tconst memberCapId =\n\t\t\t\t\t\t\tmemberCapIds?.[index] || (await this.#getUserMemberCapId(userAddress, channel.id.id));\n\t\t\t\t\t\tconst encryptedKey = await this.#getEncryptionKeyFromChannel(channel);\n\t\t\t\t\t\tconst decryptedMessage = await this.#decryptMessage(\n\t\t\t\t\t\t\tchannel.last_message,\n\t\t\t\t\t\t\tchannel.id.id,\n\t\t\t\t\t\t\tmemberCapId,\n\t\t\t\t\t\t\tencryptedKey,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdecryptedChannel.last_message = decryptedMessage;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// If decryption fails, set last_message to null\n\t\t\t\t\t\tconsole.warn(`Failed to decrypt last message for channel ${channel.id.id}:`, error);\n\t\t\t\t\t\tdecryptedChannel.last_message = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn decryptedChannel;\n\t\t\t}),\n\t\t);\n\n\t\treturn decryptedChannels;\n\t}\n\n\t/**\n\t * Get all members of a channel\n\t * @param channelId - The channel ID\n\t * @returns Channel members with addresses and member cap IDs\n\t */\n\tasync getChannelMembers(channelId: string): Promise<ChannelMembersResponse> {\n\t\t// 1. Get the channel object to access the auth structure\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: [channelId],\n\t\t});\n\t\tconst channelObject = channelObjectsRes.objects[0];\n\t\tif (channelObject instanceof Error || !channelObject.content) {\n\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);\n\t\t}\n\t\tconst channel = Channel.parse(await channelObject.content);\n\n\t\t// 2. Extract member cap IDs from the auth structure\n\t\tconst memberCapIds = channel.auth.member_permissions.contents.map((entry) => entry.key);\n\n\t\tif (memberCapIds.length === 0) {\n\t\t\treturn { members: [] };\n\t\t}\n\n\t\t// 3. Fetch all MemberCap objects\n\t\tconst memberCapObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: memberCapIds,\n\t\t});\n\n\t\t// 4. Parse MemberCap objects and extract member addresses\n\t\tconst members: ChannelMember[] = [];\n\t\tfor (const obj of memberCapObjects.objects) {\n\t\t\tif (obj instanceof Error || !obj.content) {\n\t\t\t\tconsole.warn('Failed to fetch MemberCap object:', obj);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst memberCap = MemberCap.parse(await obj.content);\n\n\t\t\t\t// Get the owner of the MemberCap object\n\t\t\t\tif (obj.owner) {\n\t\t\t\t\tlet memberAddress: string;\n\t\t\t\t\tif (obj.owner.$kind === 'AddressOwner') {\n\t\t\t\t\t\tmemberAddress = obj.owner.AddressOwner;\n\t\t\t\t\t} else if (obj.owner.$kind === 'ObjectOwner') {\n\t\t\t\t\t\t// For object-owned MemberCaps, we can't easily get the address\n\t\t\t\t\t\t// This is a limitation of the current approach\n\t\t\t\t\t\tconsole.warn('MemberCap is object-owned, skipping:', memberCap.id.id);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('MemberCap has unknown ownership type:', obj.owner);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tmembers.push({\n\t\t\t\t\t\tmemberAddress,\n\t\t\t\t\t\tmemberCapId: memberCap.id.id,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('Failed to parse MemberCap object:', error);\n\t\t\t}\n\t\t}\n\n\t\treturn { members };\n\t}\n\n\t/**\n\t * Get messages from a channel with pagination (returns decrypted messages)\n\t * @param request - Request parameters including channelId, userAddress, cursor, limit, and direction\n\t * @returns Decrypted messages with pagination info\n\t */\n\tasync getChannelMessages({\n\t\tchannelId,\n\t\tuserAddress,\n\t\tcursor = null,\n\t\tlimit = 50,\n\t\tdirection = 'backward',\n\t}: GetChannelMessagesRequest): Promise<DecryptedMessagesResponse> {\n\t\t// 1. Get channel metadata (we need the raw channel object for metadata, not decrypted)\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: [channelId],\n\t\t});\n\t\tconst channelObject = channelObjectsRes.objects[0];\n\t\tif (channelObject instanceof Error || !channelObject.content) {\n\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);\n\t\t}\n\t\tconst channel = Channel.parse(await channelObject.content);\n\n\t\tconst messagesTableId = channel.messages.contents.id.id;\n\t\tconst totalMessagesCount = BigInt(channel.messages_count);\n\n\t\t// 2. Validate inputs\n\t\tif (totalMessagesCount === BigInt(0)) {\n\t\t\treturn this.#createEmptyMessagesResponse(direction);\n\t\t}\n\n\t\tif (cursor !== null && cursor >= totalMessagesCount) {\n\t\t\tthrow new MessagingClientError(\n\t\t\t\t`Cursor ${cursor} is out of bounds. Channel has ${totalMessagesCount} messages.`,\n\t\t\t);\n\t\t}\n\n\t\t// 3. Calculate fetch range based on direction and cursor\n\t\tconst fetchRange = this.#calculateFetchRange({\n\t\t\tcursor,\n\t\t\tlimit,\n\t\t\tdirection,\n\t\t\ttotalMessagesCount,\n\t\t});\n\n\t\t// 4. Handle edge cases\n\t\tif (fetchRange.startIndex >= fetchRange.endIndex) {\n\t\t\treturn this.#createEmptyMessagesResponse(direction);\n\t\t}\n\n\t\t// 5. Fetch and parse messages\n\t\tconst rawMessages = await this.#fetchMessagesInRange(messagesTableId, fetchRange);\n\n\t\t// 6. Decrypt messages\n\t\tconst memberCapId = await this.#getUserMemberCapId(userAddress, channelId);\n\t\tconst encryptedKey = await this.#getEncryptionKeyFromChannel(channel);\n\n\t\tconst decryptedMessages = await Promise.all(\n\t\t\trawMessages.map(async (message) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this.#decryptMessage(message, channelId, memberCapId, encryptedKey);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn(`Failed to decrypt message in channel ${channelId}:`, error);\n\t\t\t\t\t// Return a placeholder for failed decryption\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: '[Failed to decrypt message]',\n\t\t\t\t\t\tsender: message.sender,\n\t\t\t\t\t\tcreatedAtMs: message.created_at_ms,\n\t\t\t\t\t\tattachments: [],\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// 7. Determine next pagination\n\t\tconst nextPagination = this.#determineNextPagination({\n\t\t\tfetchRange,\n\t\t\tdirection,\n\t\t\ttotalMessagesCount,\n\t\t});\n\n\t\t// 8. Create response\n\t\treturn {\n\t\t\tmessages: decryptedMessages,\n\t\t\tcursor: nextPagination.cursor,\n\t\t\thasNextPage: nextPagination.hasNextPage,\n\t\t\tdirection,\n\t\t};\n\t}\n\n\t/**\n\t * Get new messages since last polling state (returns decrypted messages)\n\t * @param request - Request with channelId, userAddress, pollingState, and limit\n\t * @returns New decrypted messages since last poll\n\t */\n\tasync getLatestMessages({\n\t\tchannelId,\n\t\tuserAddress,\n\t\tpollingState,\n\t\tlimit = 50,\n\t}: GetLatestMessagesRequest): Promise<DecryptedMessagesResponse> {\n\t\t// 1. Get current channel state to check for new messages\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: [channelId],\n\t\t});\n\t\tconst channelObject = channelObjectsRes.objects[0];\n\t\tif (channelObject instanceof Error || !channelObject.content) {\n\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);\n\t\t}\n\t\tconst channel = Channel.parse(await channelObject.content);\n\t\tconst latestMessageCount = BigInt(channel.messages_count);\n\n\t\t// 2. Check if there are new messages since last poll\n\t\tconst newMessagesCount = latestMessageCount - pollingState.lastMessageCount;\n\n\t\tif (newMessagesCount === BigInt(0)) {\n\t\t\t// No new messages - return empty response with same cursor\n\t\t\treturn {\n\t\t\t\tmessages: [],\n\t\t\t\tcursor: pollingState.lastCursor,\n\t\t\t\thasNextPage: pollingState.lastCursor !== null,\n\t\t\t\tdirection: 'backward',\n\t\t\t};\n\t\t}\n\n\t\t// 3. Use unified method to fetch new messages\n\t\t// Limit to the number of new messages or the requested limit, whichever is smaller\n\t\tconst fetchLimit = Math.min(Number(newMessagesCount), limit);\n\n\t\tconst response = await this.getChannelMessages({\n\t\t\tchannelId,\n\t\t\tuserAddress,\n\t\t\tcursor: pollingState.lastCursor,\n\t\t\tlimit: fetchLimit,\n\t\t\tdirection: 'backward',\n\t\t});\n\n\t\treturn response;\n\t}\n\n\t// ===== Write Path =====\n\n\t/**\n\t * Create a channel creation flow\n\t *\n\t * @usage\n\t * ```\n\t * const flow = client.createChannelFlow();\n\t *\n\t * // Step-by-step execution\n\t * // 1. build\n\t * const tx = flow.build();\n\t * // 2. getGeneratedCaps\n\t * const { creatorCap, creatorMemberCap, additionalMemberCaps } = await flow.getGeneratedCaps({ digest });\n\t * // 3. generateAndAttachEncryptionKey\n\t * const { transaction, creatorCap, encryptedKeyBytes } = await flow.generateAndAttachEncryptionKey({ creatorCap, creatorMemberCap });\n\t * // 4. getGeneratedEncryptionKey\n\t * const { channelId, encryptedKeyBytes } = await flow.getGeneratedEncryptionKey({ creatorCap, encryptedKeyBytes });\n\t * ```\n\t *\n\t * @param opts - Options including creator address and initial members\n\t * @returns Channel creation flow with step-by-step methods\n\t */\n\tcreateChannelFlow({\n\t\tcreatorAddress,\n\t\tinitialMemberAddresses,\n\t}: CreateChannelFlowOpts): CreateChannelFlow {\n\t\tconst build = () => {\n\t\t\tconst tx = new Transaction();\n\t\t\tconst config = tx.add(noneConfig());\n\t\t\tconst [channel, creatorCap, creatorMemberCap] = tx.add(newChannel({ arguments: { config } }));\n\n\t\t\t// Add initial members if provided\n\t\t\tlet memberCaps: RawTransactionArgument<string> | null = null;\n\t\t\tif (initialMemberAddresses && initialMemberAddresses.length > 0) {\n\t\t\t\tmemberCaps = tx.add(\n\t\t\t\t\taddMembers({\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tself: channel,\n\t\t\t\t\t\t\tmemberCap: creatorMemberCap,\n\t\t\t\t\t\t\tn: initialMemberAddresses.length,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Share the channel and transfer creator cap\n\t\t\ttx.add(shareChannel({ arguments: { self: channel, creatorCap } }));\n\t\t\t// Transfer MemberCaps\n\t\t\ttx.add(\n\t\t\t\ttransferMemberCap({\n\t\t\t\t\targuments: { cap: creatorMemberCap, creatorCap, recipient: creatorAddress },\n\t\t\t\t}),\n\t\t\t);\n\t\t\tif (memberCaps !== null) {\n\t\t\t\ttx.add(\n\t\t\t\t\ttransferMemberCaps({\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tmemberAddresses: tx.pure.vector('address', initialMemberAddresses!),\n\t\t\t\t\t\t\tmemberCaps,\n\t\t\t\t\t\t\tcreatorCap,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttx.add(transferCreatorCap({ arguments: { self: creatorCap } }));\n\n\t\t\treturn tx;\n\t\t};\n\n\t\tconst getGeneratedCaps = async ({ digest }: CreateChannelFlowGetGeneratedCapsOpts) => {\n\t\t\treturn await this.#getGeneratedCaps(digest);\n\t\t};\n\n\t\tconst generateAndAttachEncryptionKey = async ({\n\t\t\tcreatorCap,\n\t\t\tcreatorMemberCap,\n\t\t}: Awaited<ReturnType<typeof getGeneratedCaps>>) => {\n\t\t\t// Generate the encrypted channel DEK\n\t\t\tconst encryptedKeyBytes = await this.#envelopeEncryption.generateEncryptedChannelDEK({\n\t\t\t\tchannelId: creatorCap.channel_id,\n\t\t\t});\n\n\t\t\tconst tx = new Transaction();\n\n\t\t\ttx.add(\n\t\t\t\taddEncryptedKey({\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: tx.object(creatorCap.channel_id),\n\t\t\t\t\t\tmemberCap: tx.object(creatorMemberCap.id.id),\n\t\t\t\t\t\tnewEncryptionKeyBytes: tx.pure.vector('u8', encryptedKeyBytes),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: tx,\n\t\t\t\tcreatorCap,\n\t\t\t\tencryptedKeyBytes,\n\t\t\t};\n\t\t};\n\n\t\tconst getGeneratedEncryptionKey = ({\n\t\t\tcreatorCap,\n\t\t\tencryptedKeyBytes,\n\t\t}: Awaited<ReturnType<typeof generateAndAttachEncryptionKey>>) => {\n\t\t\treturn { channelId: creatorCap.channel_id, encryptedKeyBytes };\n\t\t};\n\n\t\tconst stepResults: {\n\t\t\tbuild?: ReturnType<typeof build>;\n\t\t\tgetGeneratedCaps?: Awaited<ReturnType<typeof getGeneratedCaps>>;\n\t\t\tgenerateAndAttachEncryptionKey?: Awaited<ReturnType<typeof generateAndAttachEncryptionKey>>;\n\t\t\tgetGeneratedEncryptionKey?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${String(step)} must be executed before calling ${String(current)}`);\n\t\t\t}\n\t\t\treturn stepResults[step]!;\n\t\t}\n\n\t\treturn {\n\t\t\tbuild: () => {\n\t\t\t\tif (!stepResults.build) {\n\t\t\t\t\tstepResults.build = build();\n\t\t\t\t}\n\t\t\t\treturn stepResults.build;\n\t\t\t},\n\t\t\tgetGeneratedCaps: async (opts: CreateChannelFlowGetGeneratedCapsOpts) => {\n\t\t\t\tgetResults('build', 'getGeneratedCaps');\n\t\t\t\tstepResults.getGeneratedCaps = await getGeneratedCaps(opts);\n\t\t\t\treturn stepResults.getGeneratedCaps;\n\t\t\t},\n\t\t\tgenerateAndAttachEncryptionKey: async () => {\n\t\t\t\tstepResults.generateAndAttachEncryptionKey = await generateAndAttachEncryptionKey(\n\t\t\t\t\tgetResults('getGeneratedCaps', 'generateAndAttachEncryptionKey'),\n\t\t\t\t);\n\t\t\t\treturn stepResults.generateAndAttachEncryptionKey.transaction;\n\t\t\t},\n\t\t\tgetGeneratedEncryptionKey: () => {\n\t\t\t\treturn getGeneratedEncryptionKey(\n\t\t\t\t\tgetResults('generateAndAttachEncryptionKey', 'getGeneratedEncryptionKey'),\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Create a send message transaction builder\n\t * @param channelId - The channel ID\n\t * @param memberCapId - The member cap ID\n\t * @param sender - The sender address\n\t * @param message - The message text\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param attachments - Optional file attachments\n\t * @returns Transaction builder function\n\t */\n\tasync sendMessage(\n\t\tchannelId: string,\n\t\tmemberCapId: string,\n\t\tsender: string,\n\t\tmessage: string,\n\t\tencryptedKey: EncryptedSymmetricKey,\n\t\tattachments?: File[],\n\t) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst channel = tx.object(channelId);\n\t\t\tconst memberCap = tx.object(memberCapId);\n\n\t\t\t// Encrypt the message text\n\t\t\tconst { encryptedBytes: ciphertext, nonce: textNonce } =\n\t\t\t\tawait this.#envelopeEncryption.encryptText({\n\t\t\t\t\ttext: message,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t});\n\n\t\t\t// Encrypt and upload attachments\n\t\t\tconst attachmentsVec = await this.#createAttachmentsVec(\n\t\t\t\ttx,\n\t\t\t\tencryptedKey,\n\t\t\t\tchannelId,\n\t\t\t\tmemberCapId,\n\t\t\t\tsender,\n\t\t\t\tattachments,\n\t\t\t);\n\n\t\t\ttx.add(\n\t\t\t\tsendMessage({\n\t\t\t\t\tpackage: this.#packageConfig.packageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: channel,\n\t\t\t\t\t\tmemberCap,\n\t\t\t\t\t\tciphertext: tx.pure.vector('u8', ciphertext),\n\t\t\t\t\t\tnonce: tx.pure.vector('u8', textNonce),\n\t\t\t\t\t\tattachments: attachmentsVec,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\tasync #createAttachmentsVec(\n\t\ttx: Transaction,\n\t\tencryptedKey: EncryptedSymmetricKey,\n\t\tchannelId: string,\n\t\tmemberCapId: string,\n\t\tsender: string,\n\t\tattachments?: File[],\n\t): Promise<TransactionResult> {\n\t\tconst attachmentType = this.#packageConfig.packageId\n\t\t\t? // todo: this needs better handling - it's needed for the integration tests\n\t\t\t\tAttachment.name.replace('@local-pkg/sui-stack-messaging', this.#packageConfig.packageId)\n\t\t\t: Attachment.name;\n\n\t\tif (!attachments || attachments.length === 0) {\n\t\t\treturn tx.moveCall({\n\t\t\t\tpackage: '0x1',\n\t\t\t\tmodule: 'vector',\n\t\t\t\tfunction: 'empty',\n\t\t\t\targuments: [],\n\t\t\t\ttypeArguments: [attachmentType],\n\t\t\t});\n\t\t}\n\n\t\t// 1. Encrypt all attachment data in parallel\n\t\tconst encryptedDataPayloads = await Promise.all(\n\t\t\tattachments.map(async (file) => {\n\t\t\t\treturn this.#envelopeEncryption.encryptAttachmentData({\n\t\t\t\t\tfile,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tsender,\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\t// 2. Upload encrypted data to storage in parallel\n\t\tconst attachmentRefs = await this.#storage(this.#suiClient).upload(\n\t\t\tencryptedDataPayloads.map((p) => p.encryptedBytes),\n\t\t\t{ storageType: 'quilts' },\n\t\t);\n\n\t\t// 3. Encrypt all metadata in parallel\n\t\tconst encryptedMetadataPayloads = await Promise.all(\n\t\t\tattachments.map((file) => {\n\t\t\t\treturn this.#envelopeEncryption.encryptAttachmentMetadata({\n\t\t\t\t\tfile,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tsender,\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\t// 4. Build the move vector for the transaction\n\t\treturn tx.makeMoveVec({\n\t\t\ttype: attachmentType,\n\t\t\telements: attachmentRefs.ids.map((blobRef, i) => {\n\t\t\t\tconst dataNonce = encryptedDataPayloads[i].nonce;\n\t\t\t\tconst metadata = encryptedMetadataPayloads[i];\n\t\t\t\tconst metadataNonce = metadata.nonce;\n\t\t\t\treturn tx.add(\n\t\t\t\t\tnewAttachment({\n\t\t\t\t\t\tpackage: this.#packageConfig.packageId,\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tblobRef: tx.pure.string(blobRef),\n\t\t\t\t\t\t\tencryptedMetadata: tx.pure.vector('u8', metadata.encryptedBytes),\n\t\t\t\t\t\t\tdataNonce: tx.pure.vector('u8', dataNonce),\n\t\t\t\t\t\t\tmetadataNonce: tx.pure.vector('u8', metadataNonce),\n\t\t\t\t\t\t\tkeyVersion: tx.pure('u32', encryptedKey.version),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\t}\n\n\t/**\n\t * Execute a send message transaction\n\t * @param params - Transaction parameters including signer, channelId, memberCapId, message, and encryptedKey\n\t * @returns Transaction digest and message ID\n\t */\n\tasync executeSendMessageTransaction({\n\t\tsigner,\n\t\tchannelId,\n\t\tmemberCapId,\n\t\tmessage,\n\t\tattachments,\n\t\tencryptedKey,\n\t}: {\n\t\tchannelId: string;\n\t\tmemberCapId: string;\n\t\tmessage: string;\n\t\tencryptedKey: EncryptedSymmetricKey;\n\t\tattachments?: File[];\n\t} & { signer: Signer }): Promise<{ digest: string; messageId: string }> {\n\t\tconst tx = new Transaction();\n\t\tconst sendMessageTxBuilder = await this.sendMessage(\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t\tsigner.toSuiAddress(),\n\t\t\tmessage,\n\t\t\tencryptedKey,\n\t\t\tattachments,\n\t\t);\n\t\tawait sendMessageTxBuilder(tx);\n\t\tconst { digest, effects } = await this.#executeTransaction(tx, signer, 'send message', true);\n\n\t\tconst messageId = effects.changedObjects.find((obj) => obj.idOperation === 'Created')?.id;\n\t\tif (messageId === undefined) {\n\t\t\tthrow new MessagingClientError('Message id not found on the transaction effects');\n\t\t}\n\n\t\treturn { digest, messageId };\n\t}\n\n\t/**\n\t * Update the external SessionKey instance (useful for React context updates)\n\t * Only works when the client was configured with an external SessionKey\n\t */\n\tupdateSessionKey(newSessionKey: SessionKey): void {\n\t\tthis.#envelopeEncryption.updateSessionKey(newSessionKey);\n\t}\n\n\t/**\n\t * Force refresh the managed SessionKey (useful for testing or manual refresh)\n\t * Only works when the client was configured with SessionKeyConfig\n\t */\n\tasync refreshSessionKey(): Promise<SessionKey> {\n\t\treturn this.#envelopeEncryption.refreshSessionKey();\n\t}\n\n\t/**\n\t * Execute a create channel transaction\n\t * @param params - Transaction parameters including signer and optional initial members\n\t * @returns Transaction digest, channel ID, creator cap ID, and encrypted key\n\t */\n\tasync executeCreateChannelTransaction({\n\t\tsigner,\n\t\tinitialMembers,\n\t}: {\n\t\tinitialMembers?: string[];\n\t} & { signer: Signer }): Promise<{\n\t\tdigest: string;\n\t\tchannelId: string;\n\t\tcreatorCapId: string;\n\t\tencryptedKeyBytes: Uint8Array<ArrayBuffer>;\n\t}> {\n\t\tconst flow = this.createChannelFlow({\n\t\t\tcreatorAddress: signer.toSuiAddress(),\n\t\t\tinitialMemberAddresses: initialMembers,\n\t\t});\n\n\t\t// Step 1: Build and execute the channel creation transaction\n\t\tconst channelTx = flow.build();\n\t\tconst { digest: channelDigest } = await this.#executeTransaction(\n\t\t\tchannelTx,\n\t\t\tsigner,\n\t\t\t'create channel',\n\t\t);\n\n\t\t// Step 2: Get the creator cap from the transaction\n\t\tconst {\n\t\t\tcreatorCap,\n\t\t\tcreatorMemberCap,\n\t\t\tadditionalMemberCaps: _,\n\t\t} = await flow.getGeneratedCaps({\n\t\t\tdigest: channelDigest,\n\t\t});\n\n\t\t// Step 3: Generate and attach encryption key\n\t\tconst attachKeyTx = await flow.generateAndAttachEncryptionKey({ creatorMemberCap });\n\t\tconst { digest: keyDigest } = await this.#executeTransaction(\n\t\t\tattachKeyTx,\n\t\t\tsigner,\n\t\t\t'attach encryption key',\n\t\t);\n\n\t\t// Step 4: Get the encrypted key bytes\n\t\tconst { channelId, encryptedKeyBytes } = flow.getGeneratedEncryptionKey();\n\n\t\treturn { digest: keyDigest, creatorCapId: creatorCap.id.id, channelId, encryptedKeyBytes };\n\t}\n\n\t// ===== Private Methods =====\n\tasync #executeTransaction(\n\t\ttransaction: Transaction,\n\t\tsigner: Signer,\n\t\taction: string,\n\t\twaitForTransaction: boolean = true,\n\t) {\n\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\n\t\tconst { digest, effects } = await signer.signAndExecuteTransaction({\n\t\t\ttransaction,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (effects?.status.error) {\n\t\t\tthrow new MessagingClientError(`Failed to ${action} (${digest}): ${effects?.status.error}`);\n\t\t}\n\n\t\tif (waitForTransaction) {\n\t\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\t\tdigest,\n\t\t\t});\n\t\t}\n\n\t\treturn { digest, effects };\n\t}\n\n\tasync #getGeneratedCaps(digest: string) {\n\t\tconst creatorCapType = CreatorCap.name.replace(\n\t\t\t'@local-pkg/sui-stack-messaging',\n\t\t\tthis.#packageConfig.packageId,\n\t\t);\n\t\tconst creatorMemberCapType = MemberCap.name.replace(\n\t\t\t'@local-pkg/sui-stack-messaging',\n\t\t\tthis.#packageConfig.packageId,\n\t\t);\n\t\tconst additionalMemberCapType = MemberCap.name.replace(\n\t\t\t'@local-pkg/sui-stack-messaging',\n\t\t\tthis.#packageConfig.packageId,\n\t\t);\n\n\t\tconst {\n\t\t\ttransaction: { effects },\n\t\t} = await this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiCreatorCapObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === creatorCapType,\n\t\t);\n\n\t\tif (suiCreatorCapObject instanceof Error || !suiCreatorCapObject) {\n\t\t\tthrow new MessagingClientError(\n\t\t\t\t`CreatorCap object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\tconst creatorCapParsed = CreatorCap.parse(await suiCreatorCapObject.content);\n\n\t\tconst suiCreatorMemberCapObject = createdObjects.objects.find(\n\t\t\t(object) =>\n\t\t\t\t!(object instanceof Error) &&\n\t\t\t\tobject.type === creatorMemberCapType &&\n\t\t\t\t// only get the creator's member cap\n\t\t\t\tobject.owner.$kind === 'AddressOwner' &&\n\t\t\t\tsuiCreatorCapObject.owner.$kind === 'AddressOwner' &&\n\t\t\t\tobject.owner.AddressOwner === suiCreatorCapObject.owner.AddressOwner,\n\t\t);\n\n\t\tif (suiCreatorMemberCapObject instanceof Error || !suiCreatorMemberCapObject) {\n\t\t\tthrow new MessagingClientError(\n\t\t\t\t`CreatorMemberCap object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\tconst creatorMemberCapParsed = MemberCap.parse(await suiCreatorMemberCapObject.content);\n\n\t\tconst suiAdditionalMemberCapsObjects = createdObjects.objects.filter(\n\t\t\t(object) => !(object instanceof Error) && object.type === additionalMemberCapType,\n\t\t);\n\n\t\t// exclude the creator's member cap from the additional member caps\n\t\tconst additionalMemberCapsParsed = await Promise.all(\n\t\t\tsuiAdditionalMemberCapsObjects.map(async (object) => {\n\t\t\t\tif (object instanceof Error) {\n\t\t\t\t\tthrow new MessagingClientError(\n\t\t\t\t\t\t`AdditionalMemberCap object not found in transaction effects for transaction (${digest})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn MemberCap.parse(await object.content);\n\t\t\t}),\n\t\t);\n\t\tadditionalMemberCapsParsed.filter((cap) => cap.id.id !== creatorMemberCapParsed.id.id);\n\n\t\treturn {\n\t\t\tcreatorCap: creatorCapParsed,\n\t\t\tcreatorMemberCap: creatorMemberCapParsed,\n\t\t\tadditionalMemberCaps: additionalMemberCapsParsed,\n\t\t};\n\t}\n\n\t// Derive the message IDs from the given range\n\t// Note: messages = TableVec<Message>\n\t// --> TableVec{contents: Table<u64, Message>}\n\t#deriveMessageIDsFromRange(messagesTableId: string, startIndex: bigint, endIndex: bigint) {\n\t\tconst messageIDs: string[] = [];\n\n\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\tmessageIDs.push(deriveDynamicFieldID(messagesTableId, 'u64', bcs.U64.serialize(i).toBytes()));\n\t\t}\n\n\t\treturn messageIDs;\n\t}\n\n\t// Parse the message objects response\n\t// Note: the given message objects response\n\t// is in the form of dynamic_field::Field<u64, Message>\n\tasync #parseMessageObjects(\n\t\tmessageObjects: Experimental_SuiClientTypes.GetObjectsResponse,\n\t): Promise<ParsedMessageObject[]> {\n\t\tconst DynamicFieldMessage = bcs.struct('DynamicFieldMessage', {\n\t\t\tid: bcs.Address, // UID is represented as an address\n\t\t\tname: bcs.U64, // the key (message index)\n\t\t\tvalue: Message, // the actual Message\n\t\t});\n\n\t\tconst parsedMessageObjects = await Promise.all(\n\t\t\tmessageObjects.objects.map(async (object) => {\n\t\t\t\tif (object instanceof Error || !object.content) {\n\t\t\t\t\tthrow new MessagingClientError(`Failed to parse message object: ${object}`);\n\t\t\t\t}\n\t\t\t\tconst content = await object.content;\n\t\t\t\t// Parse the dynamic field wrapper\n\t\t\t\tconst dynamicField = DynamicFieldMessage.parse(content);\n\n\t\t\t\t// Extract the actual Message from the value field\n\t\t\t\treturn dynamicField.value;\n\t\t\t}),\n\t\t);\n\n\t\treturn parsedMessageObjects;\n\t}\n\n\tasync #createLazyAttachmentDataPromise({\n\t\tchannelId,\n\t\tmemberCapId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tblobRef,\n\t\tnonce,\n\t}: {\n\t\tchannelId: string;\n\t\tmemberCapId: string;\n\t\tsender: string;\n\t\tencryptedKey: EncryptedSymmetricKey;\n\t\tblobRef: string;\n\t\tnonce: Uint8Array;\n\t}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tconst downloadAndDecrypt = async (): Promise<Uint8Array<ArrayBuffer>> => {\n\t\t\t// Download the encrypted data\n\t\t\tconst [encryptedData] = await this.#storage(this.#suiClient).download([blobRef]);\n\n\t\t\t// Decrypt the data\n\t\t\tconst decryptedData = await this.#envelopeEncryption.decryptAttachmentData({\n\t\t\t\tencryptedBytes: new Uint8Array(encryptedData),\n\t\t\t\tnonce: new Uint8Array(nonce),\n\t\t\t\tchannelId,\n\t\t\t\tmemberCapId,\n\t\t\t\tsender,\n\t\t\t\tencryptedKey,\n\t\t\t});\n\n\t\t\treturn decryptedData.data;\n\t\t};\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tdownloadAndDecrypt().then(resolve).catch(reject);\n\t\t});\n\t}\n\n\t/**\n\t * Calculate the range of message indices to fetch\n\t */\n\t#calculateFetchRange({\n\t\tcursor,\n\t\tlimit,\n\t\tdirection,\n\t\ttotalMessagesCount,\n\t}: {\n\t\tcursor: bigint | null;\n\t\tlimit: number;\n\t\tdirection: 'backward' | 'forward';\n\t\ttotalMessagesCount: bigint;\n\t}): { startIndex: bigint; endIndex: bigint } {\n\t\tconst limitBigInt = BigInt(limit);\n\n\t\tif (direction === 'backward') {\n\t\t\t// Fetch messages in descending order (newest first)\n\t\t\tif (cursor === null) {\n\t\t\t\t// First request - get latest messages\n\t\t\t\tconst startIndex =\n\t\t\t\t\ttotalMessagesCount > limitBigInt ? totalMessagesCount - limitBigInt : BigInt(0);\n\t\t\t\treturn {\n\t\t\t\t\tstartIndex,\n\t\t\t\t\tendIndex: totalMessagesCount,\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Subsequent requests - get older messages\n\t\t\tconst endIndex = cursor; // Cursor is exclusive in backward direction\n\t\t\tconst startIndex = endIndex > limitBigInt ? endIndex - limitBigInt : BigInt(0);\n\t\t\treturn {\n\t\t\t\tstartIndex,\n\t\t\t\tendIndex,\n\t\t\t};\n\t\t}\n\t\t// Fetch messages in ascending order (oldest first)\n\t\tif (cursor === null) {\n\t\t\t// First request - get oldest messages\n\t\t\tconst endIndex = totalMessagesCount > limitBigInt ? limitBigInt : totalMessagesCount;\n\t\t\treturn {\n\t\t\t\tstartIndex: BigInt(0),\n\t\t\t\tendIndex,\n\t\t\t};\n\t\t}\n\t\t// Subsequent requests - get newer messages\n\t\tconst startIndex = cursor + BigInt(1); // Cursor is inclusive in forward direction\n\t\tconst endIndex =\n\t\t\tstartIndex + limitBigInt > totalMessagesCount ? totalMessagesCount : startIndex + limitBigInt;\n\t\treturn {\n\t\t\tstartIndex,\n\t\t\tendIndex,\n\t\t};\n\t}\n\n\t/**\n\t * Fetch messages in the specified range\n\t */\n\tasync #fetchMessagesInRange(\n\t\tmessagesTableId: string,\n\t\trange: { startIndex: bigint; endIndex: bigint },\n\t): Promise<ParsedMessageObject[]> {\n\t\tconst messageIds = this.#deriveMessageIDsFromRange(\n\t\t\tmessagesTableId,\n\t\t\trange.startIndex,\n\t\t\trange.endIndex,\n\t\t);\n\n\t\tif (messageIds.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst messageObjects = await this.#suiClient.core.getObjects({ objectIds: messageIds });\n\t\treturn await this.#parseMessageObjects(messageObjects);\n\t}\n\n\t/**\n\t * Create a messages response with pagination info\n\t */\n\t#determineNextPagination({\n\t\tfetchRange,\n\t\tdirection,\n\t\ttotalMessagesCount,\n\t}: {\n\t\tfetchRange: { startIndex: bigint; endIndex: bigint };\n\t\tdirection: 'backward' | 'forward';\n\t\ttotalMessagesCount: bigint;\n\t}): { cursor: bigint | null; hasNextPage: boolean } {\n\t\t// Determine next cursor and hasNextPage based on direction\n\t\tlet nextCursor: bigint | null = null;\n\t\tlet hasNextPage = false;\n\n\t\tif (direction === 'backward') {\n\t\t\t// For backward direction, cursor points to the oldest message we fetched (exclusive)\n\t\t\tnextCursor = fetchRange.startIndex > BigInt(0) ? fetchRange.startIndex : null;\n\t\t\thasNextPage = fetchRange.startIndex > BigInt(0);\n\t\t} else {\n\t\t\t// For forward direction, cursor points to the newest message we fetched (inclusive)\n\t\t\tnextCursor =\n\t\t\t\tfetchRange.endIndex < totalMessagesCount ? fetchRange.endIndex - BigInt(1) : null;\n\t\t\thasNextPage = fetchRange.endIndex < totalMessagesCount;\n\t\t}\n\n\t\treturn {\n\t\t\tcursor: nextCursor,\n\t\t\thasNextPage,\n\t\t};\n\t}\n\n\t/**\n\t * Create an empty messages response\n\t */\n\t#createEmptyMessagesResponse(direction: 'backward' | 'forward'): DecryptedMessagesResponse {\n\t\treturn {\n\t\t\tmessages: [],\n\t\t\tcursor: null,\n\t\t\thasNextPage: false,\n\t\t\tdirection,\n\t\t};\n\t}\n\t/**\n\t * Helper method to get object contents, handling both SuiClient and SuiGrpcClient\n\t */\n\tasync #getObjectContents(\n\t\tobjects: Experimental_SuiClientTypes.ObjectResponse[],\n\t): Promise<Uint8Array[]> {\n\t\t// First, try to get all contents directly (works for SuiClient)\n\t\tconst contentPromises = objects.map(async (object) => {\n\t\t\ttry {\n\t\t\t\treturn await object.content;\n\t\t\t} catch (error) {\n\t\t\t\t// If this is the gRPC error, we'll handle it below\n\t\t\t\tif (\n\t\t\t\t\terror instanceof Error &&\n\t\t\t\t\terror.message.includes('GRPC does not return object contents')\n\t\t\t\t) {\n\t\t\t\t\treturn null; // Mark for batch fetching\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\n\t\tconst contents = await Promise.all(contentPromises);\n\n\t\t// Check if any failed with the gRPC error\n\t\tconst needsBatchFetch = contents.some((content) => content === null);\n\n\t\tif (needsBatchFetch) {\n\t\t\t// Batch fetch all objects that need content\n\t\t\tconst objectIds = objects.map((obj) => obj.id);\n\t\t\tconst objectResponses = await this.#suiClient.core.getObjects({ objectIds });\n\n\t\t\t// Map the results back to the original order and await the content\n\t\t\tconst batchContents = await Promise.all(\n\t\t\t\tobjectResponses.objects.map(async (obj) => {\n\t\t\t\t\tif (obj instanceof Error || !obj.content) {\n\t\t\t\t\t\tthrow new MessagingClientError(`Failed to fetch object content: ${obj}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn await obj.content;\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn batchContents;\n\t\t}\n\n\t\t// Filter out null values and return\n\t\treturn contents.filter((content): content is Uint8Array => content !== null);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["val", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "_new", "_MessagingAPIError", "__privateAdd", "__privateMethod", "response", "data", "__privateAdd", "$moduleName", "$moduleName", "$moduleName", "_suiClient", "_sealConfig", "_SuiStackMessagingClient", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "_new", "startIndex", "endIndex"]
}
