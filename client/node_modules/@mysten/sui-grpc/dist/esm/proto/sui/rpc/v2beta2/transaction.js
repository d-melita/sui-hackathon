import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../google/protobuf/duration.js";
import { Empty } from "../../../google/protobuf/empty.js";
import { Object } from "./object.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";
import { Argument } from "./argument.js";
import { Input } from "./input.js";
import { ObjectReference } from "./object_reference.js";
import { Bcs } from "./bcs.js";
var TransactionExpiration_TransactionExpirationKind = /* @__PURE__ */ ((TransactionExpiration_TransactionExpirationKind2) => {
  TransactionExpiration_TransactionExpirationKind2[TransactionExpiration_TransactionExpirationKind2["TRANSACTION_EXPIRATION_KIND_UNKNOWN"] = 0] = "TRANSACTION_EXPIRATION_KIND_UNKNOWN";
  TransactionExpiration_TransactionExpirationKind2[TransactionExpiration_TransactionExpirationKind2["NONE"] = 1] = "NONE";
  TransactionExpiration_TransactionExpirationKind2[TransactionExpiration_TransactionExpirationKind2["EPOCH"] = 2] = "EPOCH";
  return TransactionExpiration_TransactionExpirationKind2;
})(TransactionExpiration_TransactionExpirationKind || {});
var ExecutionTimeObservation_ExecutionTimeObservationKind = /* @__PURE__ */ ((ExecutionTimeObservation_ExecutionTimeObservationKind2) => {
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN"] = 0] = "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["MOVE_ENTRY_POINT"] = 1] = "MOVE_ENTRY_POINT";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["TRANSFER_OBJECTS"] = 2] = "TRANSFER_OBJECTS";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["SPLIT_COINS"] = 3] = "SPLIT_COINS";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["MERGE_COINS"] = 4] = "MERGE_COINS";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["PUBLISH"] = 5] = "PUBLISH";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["MAKE_MOVE_VECTOR"] = 6] = "MAKE_MOVE_VECTOR";
  ExecutionTimeObservation_ExecutionTimeObservationKind2[ExecutionTimeObservation_ExecutionTimeObservationKind2["UPGRADE"] = 7] = "UPGRADE";
  return ExecutionTimeObservation_ExecutionTimeObservationKind2;
})(ExecutionTimeObservation_ExecutionTimeObservationKind || {});
class Transaction$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Transaction", [
      { no: 1, name: "bcs", kind: "message", T: () => Bcs },
      {
        no: 2,
        name: "digest",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 4, name: "kind", kind: "message", T: () => TransactionKind },
      {
        no: 5,
        name: "sender",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "gas_payment", kind: "message", T: () => GasPayment },
      { no: 7, name: "expiration", kind: "message", T: () => TransactionExpiration }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Bcs bcs */
        1:
          message.bcs = Bcs.internalBinaryRead(reader, reader.uint32(), options, message.bcs);
          break;
        case /* optional string digest */
        2:
          message.digest = reader.string();
          break;
        case /* optional int32 version */
        3:
          message.version = reader.int32();
          break;
        case /* optional sui.rpc.v2beta2.TransactionKind kind */
        4:
          message.kind = TransactionKind.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.kind
          );
          break;
        case /* optional string sender */
        5:
          message.sender = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.GasPayment gas_payment */
        6:
          message.gasPayment = GasPayment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.gasPayment
          );
          break;
        case /* optional sui.rpc.v2beta2.TransactionExpiration expiration */
        7:
          message.expiration = TransactionExpiration.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.expiration
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bcs)
      Bcs.internalBinaryWrite(
        message.bcs,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.digest !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.digest);
    if (message.version !== void 0) writer.tag(3, WireType.Varint).int32(message.version);
    if (message.kind)
      TransactionKind.internalBinaryWrite(
        message.kind,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.sender !== void 0)
      writer.tag(5, WireType.LengthDelimited).string(message.sender);
    if (message.gasPayment)
      GasPayment.internalBinaryWrite(
        message.gasPayment,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.expiration)
      TransactionExpiration.internalBinaryWrite(
        message.expiration,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Transaction = new Transaction$Type();
class GasPayment$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GasPayment", [
      {
        no: 1,
        name: "objects",
        kind: "message",
        repeat: 2,
        T: () => ObjectReference
      },
      {
        no: 2,
        name: "owner",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "price",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "budget",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.ObjectReference objects */
        1:
          message.objects.push(
            ObjectReference.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional string owner */
        2:
          message.owner = reader.string();
          break;
        case /* optional uint64 price */
        3:
          message.price = reader.uint64().toBigInt();
          break;
        case /* optional uint64 budget */
        4:
          message.budget = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      ObjectReference.internalBinaryWrite(
        message.objects[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.owner !== void 0) writer.tag(2, WireType.LengthDelimited).string(message.owner);
    if (message.price !== void 0) writer.tag(3, WireType.Varint).uint64(message.price);
    if (message.budget !== void 0) writer.tag(4, WireType.Varint).uint64(message.budget);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GasPayment = new GasPayment$Type();
class TransactionExpiration$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.TransactionExpiration", [
      {
        no: 1,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.TransactionExpiration.TransactionExpirationKind",
          TransactionExpiration_TransactionExpirationKind
        ]
      },
      {
        no: 2,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.TransactionExpiration.TransactionExpirationKind kind */
        1:
          message.kind = reader.int32();
          break;
        case /* optional uint64 epoch */
        2:
          message.epoch = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind !== void 0) writer.tag(1, WireType.Varint).int32(message.kind);
    if (message.epoch !== void 0) writer.tag(2, WireType.Varint).uint64(message.epoch);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TransactionExpiration = new TransactionExpiration$Type();
class TransactionKind$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.TransactionKind", [
      {
        no: 2,
        name: "programmable_transaction",
        kind: "message",
        oneof: "kind",
        T: () => ProgrammableTransaction
      },
      {
        no: 3,
        name: "programmable_system_transaction",
        kind: "message",
        oneof: "kind",
        T: () => ProgrammableTransaction
      },
      { no: 100, name: "change_epoch", kind: "message", oneof: "kind", T: () => ChangeEpoch },
      { no: 101, name: "genesis", kind: "message", oneof: "kind", T: () => GenesisTransaction },
      {
        no: 102,
        name: "consensus_commit_prologue_v1",
        kind: "message",
        oneof: "kind",
        T: () => ConsensusCommitPrologue
      },
      {
        no: 103,
        name: "authenticator_state_update",
        kind: "message",
        oneof: "kind",
        T: () => AuthenticatorStateUpdate
      },
      {
        no: 104,
        name: "end_of_epoch",
        kind: "message",
        oneof: "kind",
        T: () => EndOfEpochTransaction
      },
      {
        no: 105,
        name: "randomness_state_update",
        kind: "message",
        oneof: "kind",
        T: () => RandomnessStateUpdate
      },
      {
        no: 106,
        name: "consensus_commit_prologue_v2",
        kind: "message",
        oneof: "kind",
        T: () => ConsensusCommitPrologue
      },
      {
        no: 107,
        name: "consensus_commit_prologue_v3",
        kind: "message",
        oneof: "kind",
        T: () => ConsensusCommitPrologue
      },
      {
        no: 108,
        name: "consensus_commit_prologue_v4",
        kind: "message",
        oneof: "kind",
        T: () => ConsensusCommitPrologue
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.kind = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.ProgrammableTransaction programmable_transaction */
        2:
          message.kind = {
            oneofKind: "programmableTransaction",
            programmableTransaction: ProgrammableTransaction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.programmableTransaction
            )
          };
          break;
        case /* sui.rpc.v2beta2.ProgrammableTransaction programmable_system_transaction */
        3:
          message.kind = {
            oneofKind: "programmableSystemTransaction",
            programmableSystemTransaction: ProgrammableTransaction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.programmableSystemTransaction
            )
          };
          break;
        case /* sui.rpc.v2beta2.ChangeEpoch change_epoch */
        100:
          message.kind = {
            oneofKind: "changeEpoch",
            changeEpoch: ChangeEpoch.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.changeEpoch
            )
          };
          break;
        case /* sui.rpc.v2beta2.GenesisTransaction genesis */
        101:
          message.kind = {
            oneofKind: "genesis",
            genesis: GenesisTransaction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.genesis
            )
          };
          break;
        case /* sui.rpc.v2beta2.ConsensusCommitPrologue consensus_commit_prologue_v1 */
        102:
          message.kind = {
            oneofKind: "consensusCommitPrologueV1",
            consensusCommitPrologueV1: ConsensusCommitPrologue.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.consensusCommitPrologueV1
            )
          };
          break;
        case /* sui.rpc.v2beta2.AuthenticatorStateUpdate authenticator_state_update */
        103:
          message.kind = {
            oneofKind: "authenticatorStateUpdate",
            authenticatorStateUpdate: AuthenticatorStateUpdate.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.authenticatorStateUpdate
            )
          };
          break;
        case /* sui.rpc.v2beta2.EndOfEpochTransaction end_of_epoch */
        104:
          message.kind = {
            oneofKind: "endOfEpoch",
            endOfEpoch: EndOfEpochTransaction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.endOfEpoch
            )
          };
          break;
        case /* sui.rpc.v2beta2.RandomnessStateUpdate randomness_state_update */
        105:
          message.kind = {
            oneofKind: "randomnessStateUpdate",
            randomnessStateUpdate: RandomnessStateUpdate.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.randomnessStateUpdate
            )
          };
          break;
        case /* sui.rpc.v2beta2.ConsensusCommitPrologue consensus_commit_prologue_v2 */
        106:
          message.kind = {
            oneofKind: "consensusCommitPrologueV2",
            consensusCommitPrologueV2: ConsensusCommitPrologue.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.consensusCommitPrologueV2
            )
          };
          break;
        case /* sui.rpc.v2beta2.ConsensusCommitPrologue consensus_commit_prologue_v3 */
        107:
          message.kind = {
            oneofKind: "consensusCommitPrologueV3",
            consensusCommitPrologueV3: ConsensusCommitPrologue.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.consensusCommitPrologueV3
            )
          };
          break;
        case /* sui.rpc.v2beta2.ConsensusCommitPrologue consensus_commit_prologue_v4 */
        108:
          message.kind = {
            oneofKind: "consensusCommitPrologueV4",
            consensusCommitPrologueV4: ConsensusCommitPrologue.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.consensusCommitPrologueV4
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind.oneofKind === "programmableTransaction")
      ProgrammableTransaction.internalBinaryWrite(
        message.kind.programmableTransaction,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "programmableSystemTransaction")
      ProgrammableTransaction.internalBinaryWrite(
        message.kind.programmableSystemTransaction,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "changeEpoch")
      ChangeEpoch.internalBinaryWrite(
        message.kind.changeEpoch,
        writer.tag(100, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "genesis")
      GenesisTransaction.internalBinaryWrite(
        message.kind.genesis,
        writer.tag(101, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "consensusCommitPrologueV1")
      ConsensusCommitPrologue.internalBinaryWrite(
        message.kind.consensusCommitPrologueV1,
        writer.tag(102, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "authenticatorStateUpdate")
      AuthenticatorStateUpdate.internalBinaryWrite(
        message.kind.authenticatorStateUpdate,
        writer.tag(103, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "endOfEpoch")
      EndOfEpochTransaction.internalBinaryWrite(
        message.kind.endOfEpoch,
        writer.tag(104, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "randomnessStateUpdate")
      RandomnessStateUpdate.internalBinaryWrite(
        message.kind.randomnessStateUpdate,
        writer.tag(105, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "consensusCommitPrologueV2")
      ConsensusCommitPrologue.internalBinaryWrite(
        message.kind.consensusCommitPrologueV2,
        writer.tag(106, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "consensusCommitPrologueV3")
      ConsensusCommitPrologue.internalBinaryWrite(
        message.kind.consensusCommitPrologueV3,
        writer.tag(107, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "consensusCommitPrologueV4")
      ConsensusCommitPrologue.internalBinaryWrite(
        message.kind.consensusCommitPrologueV4,
        writer.tag(108, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TransactionKind = new TransactionKind$Type();
class ProgrammableTransaction$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ProgrammableTransaction", [
      { no: 1, name: "inputs", kind: "message", repeat: 2, T: () => Input },
      {
        no: 2,
        name: "commands",
        kind: "message",
        repeat: 2,
        T: () => Command
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.inputs = [];
    message.commands = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.Input inputs */
        1:
          message.inputs.push(Input.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated sui.rpc.v2beta2.Command commands */
        2:
          message.commands.push(Command.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.inputs.length; i++)
      Input.internalBinaryWrite(
        message.inputs[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.commands.length; i++)
      Command.internalBinaryWrite(
        message.commands[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ProgrammableTransaction = new ProgrammableTransaction$Type();
class Command$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Command", [
      { no: 1, name: "move_call", kind: "message", oneof: "command", T: () => MoveCall },
      {
        no: 2,
        name: "transfer_objects",
        kind: "message",
        oneof: "command",
        T: () => TransferObjects
      },
      { no: 3, name: "split_coins", kind: "message", oneof: "command", T: () => SplitCoins },
      { no: 4, name: "merge_coins", kind: "message", oneof: "command", T: () => MergeCoins },
      { no: 5, name: "publish", kind: "message", oneof: "command", T: () => Publish },
      {
        no: 6,
        name: "make_move_vector",
        kind: "message",
        oneof: "command",
        T: () => MakeMoveVector
      },
      { no: 7, name: "upgrade", kind: "message", oneof: "command", T: () => Upgrade }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.command = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.MoveCall move_call */
        1:
          message.command = {
            oneofKind: "moveCall",
            moveCall: MoveCall.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.moveCall
            )
          };
          break;
        case /* sui.rpc.v2beta2.TransferObjects transfer_objects */
        2:
          message.command = {
            oneofKind: "transferObjects",
            transferObjects: TransferObjects.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.transferObjects
            )
          };
          break;
        case /* sui.rpc.v2beta2.SplitCoins split_coins */
        3:
          message.command = {
            oneofKind: "splitCoins",
            splitCoins: SplitCoins.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.splitCoins
            )
          };
          break;
        case /* sui.rpc.v2beta2.MergeCoins merge_coins */
        4:
          message.command = {
            oneofKind: "mergeCoins",
            mergeCoins: MergeCoins.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.mergeCoins
            )
          };
          break;
        case /* sui.rpc.v2beta2.Publish publish */
        5:
          message.command = {
            oneofKind: "publish",
            publish: Publish.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.publish
            )
          };
          break;
        case /* sui.rpc.v2beta2.MakeMoveVector make_move_vector */
        6:
          message.command = {
            oneofKind: "makeMoveVector",
            makeMoveVector: MakeMoveVector.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.makeMoveVector
            )
          };
          break;
        case /* sui.rpc.v2beta2.Upgrade upgrade */
        7:
          message.command = {
            oneofKind: "upgrade",
            upgrade: Upgrade.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.command.upgrade
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.command.oneofKind === "moveCall")
      MoveCall.internalBinaryWrite(
        message.command.moveCall,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.command.oneofKind === "transferObjects")
      TransferObjects.internalBinaryWrite(
        message.command.transferObjects,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.command.oneofKind === "splitCoins")
      SplitCoins.internalBinaryWrite(
        message.command.splitCoins,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.command.oneofKind === "mergeCoins")
      MergeCoins.internalBinaryWrite(
        message.command.mergeCoins,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.command.oneofKind === "publish")
      Publish.internalBinaryWrite(
        message.command.publish,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.command.oneofKind === "makeMoveVector")
      MakeMoveVector.internalBinaryWrite(
        message.command.makeMoveVector,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.command.oneofKind === "upgrade")
      Upgrade.internalBinaryWrite(
        message.command.upgrade,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Command = new Command$Type();
class MoveCall$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MoveCall", [
      {
        no: 1,
        name: "package",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "module",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "function",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "type_arguments",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 5,
        name: "arguments",
        kind: "message",
        repeat: 2,
        T: () => Argument
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.typeArguments = [];
    message.arguments = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string package */
        1:
          message.package = reader.string();
          break;
        case /* optional string module */
        2:
          message.module = reader.string();
          break;
        case /* optional string function */
        3:
          message.function = reader.string();
          break;
        case /* repeated string type_arguments */
        4:
          message.typeArguments.push(reader.string());
          break;
        case /* repeated sui.rpc.v2beta2.Argument arguments */
        5:
          message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.package !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.package);
    if (message.module !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.module);
    if (message.function !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.function);
    for (let i = 0; i < message.typeArguments.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.typeArguments[i]);
    for (let i = 0; i < message.arguments.length; i++)
      Argument.internalBinaryWrite(
        message.arguments[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MoveCall = new MoveCall$Type();
class TransferObjects$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.TransferObjects", [
      {
        no: 1,
        name: "objects",
        kind: "message",
        repeat: 2,
        T: () => Argument
      },
      { no: 2, name: "address", kind: "message", T: () => Argument }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.Argument objects */
        1:
          message.objects.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional sui.rpc.v2beta2.Argument address */
        2:
          message.address = Argument.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.address
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      Argument.internalBinaryWrite(
        message.objects[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.address)
      Argument.internalBinaryWrite(
        message.address,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TransferObjects = new TransferObjects$Type();
class SplitCoins$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SplitCoins", [
      { no: 1, name: "coin", kind: "message", T: () => Argument },
      {
        no: 2,
        name: "amounts",
        kind: "message",
        repeat: 2,
        T: () => Argument
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.amounts = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Argument coin */
        1:
          message.coin = Argument.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.coin
          );
          break;
        case /* repeated sui.rpc.v2beta2.Argument amounts */
        2:
          message.amounts.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.coin)
      Argument.internalBinaryWrite(
        message.coin,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.amounts.length; i++)
      Argument.internalBinaryWrite(
        message.amounts[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SplitCoins = new SplitCoins$Type();
class MergeCoins$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MergeCoins", [
      { no: 1, name: "coin", kind: "message", T: () => Argument },
      {
        no: 2,
        name: "coins_to_merge",
        kind: "message",
        repeat: 2,
        T: () => Argument
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.coinsToMerge = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Argument coin */
        1:
          message.coin = Argument.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.coin
          );
          break;
        case /* repeated sui.rpc.v2beta2.Argument coins_to_merge */
        2:
          message.coinsToMerge.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.coin)
      Argument.internalBinaryWrite(
        message.coin,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.coinsToMerge.length; i++)
      Argument.internalBinaryWrite(
        message.coinsToMerge[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MergeCoins = new MergeCoins$Type();
class Publish$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Publish", [
      {
        no: 1,
        name: "modules",
        kind: "scalar",
        repeat: 2,
        T: 12
      },
      {
        no: 2,
        name: "dependencies",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.modules = [];
    message.dependencies = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes modules */
        1:
          message.modules.push(reader.bytes());
          break;
        case /* repeated string dependencies */
        2:
          message.dependencies.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.modules.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.modules[i]);
    for (let i = 0; i < message.dependencies.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.dependencies[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Publish = new Publish$Type();
class MakeMoveVector$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MakeMoveVector", [
      {
        no: 1,
        name: "element_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "elements",
        kind: "message",
        repeat: 2,
        T: () => Argument
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.elements = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string element_type */
        1:
          message.elementType = reader.string();
          break;
        case /* repeated sui.rpc.v2beta2.Argument elements */
        2:
          message.elements.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.elementType !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.elementType);
    for (let i = 0; i < message.elements.length; i++)
      Argument.internalBinaryWrite(
        message.elements[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MakeMoveVector = new MakeMoveVector$Type();
class Upgrade$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Upgrade", [
      {
        no: 1,
        name: "modules",
        kind: "scalar",
        repeat: 2,
        T: 12
      },
      {
        no: 2,
        name: "dependencies",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 3,
        name: "package",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "ticket", kind: "message", T: () => Argument }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.modules = [];
    message.dependencies = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes modules */
        1:
          message.modules.push(reader.bytes());
          break;
        case /* repeated string dependencies */
        2:
          message.dependencies.push(reader.string());
          break;
        case /* optional string package */
        3:
          message.package = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.Argument ticket */
        4:
          message.ticket = Argument.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ticket
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.modules.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.modules[i]);
    for (let i = 0; i < message.dependencies.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.dependencies[i]);
    if (message.package !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.package);
    if (message.ticket)
      Argument.internalBinaryWrite(
        message.ticket,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Upgrade = new Upgrade$Type();
class RandomnessStateUpdate$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.RandomnessStateUpdate", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "randomness_round",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "random_bytes",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "randomness_object_initial_shared_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 randomness_round */
        2:
          message.randomnessRound = reader.uint64().toBigInt();
          break;
        case /* optional bytes random_bytes */
        3:
          message.randomBytes = reader.bytes();
          break;
        case /* optional uint64 randomness_object_initial_shared_version */
        4:
          message.randomnessObjectInitialSharedVersion = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, WireType.Varint).uint64(message.epoch);
    if (message.randomnessRound !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.randomnessRound);
    if (message.randomBytes !== void 0)
      writer.tag(3, WireType.LengthDelimited).bytes(message.randomBytes);
    if (message.randomnessObjectInitialSharedVersion !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.randomnessObjectInitialSharedVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RandomnessStateUpdate = new RandomnessStateUpdate$Type();
class ChangeEpoch$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ChangeEpoch", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "protocol_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "storage_charge",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "computation_charge",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 5,
        name: "storage_rebate",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 6,
        name: "non_refundable_storage_fee",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 7, name: "epoch_start_timestamp", kind: "message", T: () => Timestamp },
      {
        no: 8,
        name: "system_packages",
        kind: "message",
        repeat: 2,
        T: () => SystemPackage
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.systemPackages = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 protocol_version */
        2:
          message.protocolVersion = reader.uint64().toBigInt();
          break;
        case /* optional uint64 storage_charge */
        3:
          message.storageCharge = reader.uint64().toBigInt();
          break;
        case /* optional uint64 computation_charge */
        4:
          message.computationCharge = reader.uint64().toBigInt();
          break;
        case /* optional uint64 storage_rebate */
        5:
          message.storageRebate = reader.uint64().toBigInt();
          break;
        case /* optional uint64 non_refundable_storage_fee */
        6:
          message.nonRefundableStorageFee = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.Timestamp epoch_start_timestamp */
        7:
          message.epochStartTimestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.epochStartTimestamp
          );
          break;
        case /* repeated sui.rpc.v2beta2.SystemPackage system_packages */
        8:
          message.systemPackages.push(
            SystemPackage.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, WireType.Varint).uint64(message.epoch);
    if (message.protocolVersion !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.protocolVersion);
    if (message.storageCharge !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.storageCharge);
    if (message.computationCharge !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.computationCharge);
    if (message.storageRebate !== void 0)
      writer.tag(5, WireType.Varint).uint64(message.storageRebate);
    if (message.nonRefundableStorageFee !== void 0)
      writer.tag(6, WireType.Varint).uint64(message.nonRefundableStorageFee);
    if (message.epochStartTimestamp)
      Timestamp.internalBinaryWrite(
        message.epochStartTimestamp,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.systemPackages.length; i++)
      SystemPackage.internalBinaryWrite(
        message.systemPackages[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ChangeEpoch = new ChangeEpoch$Type();
class SystemPackage$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SystemPackage", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "modules",
        kind: "scalar",
        repeat: 2,
        T: 12
      },
      {
        no: 3,
        name: "dependencies",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.modules = [];
    message.dependencies = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 version */
        1:
          message.version = reader.uint64().toBigInt();
          break;
        case /* repeated bytes modules */
        2:
          message.modules.push(reader.bytes());
          break;
        case /* repeated string dependencies */
        3:
          message.dependencies.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== void 0) writer.tag(1, WireType.Varint).uint64(message.version);
    for (let i = 0; i < message.modules.length; i++)
      writer.tag(2, WireType.LengthDelimited).bytes(message.modules[i]);
    for (let i = 0; i < message.dependencies.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.dependencies[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SystemPackage = new SystemPackage$Type();
class GenesisTransaction$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GenesisTransaction", [
      {
        no: 1,
        name: "objects",
        kind: "message",
        repeat: 2,
        T: () => Object
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.Object objects */
        1:
          message.objects.push(Object.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      Object.internalBinaryWrite(
        message.objects[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GenesisTransaction = new GenesisTransaction$Type();
class ConsensusCommitPrologue$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ConsensusCommitPrologue", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 3, name: "commit_timestamp", kind: "message", T: () => Timestamp },
      {
        no: 4,
        name: "consensus_commit_digest",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 5,
        name: "sub_dag_index",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 6,
        name: "consensus_determined_version_assignments",
        kind: "message",
        T: () => ConsensusDeterminedVersionAssignments
      },
      {
        no: 7,
        name: "additional_state_digest",
        kind: "scalar",
        opt: true,
        T: 9
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 round */
        2:
          message.round = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.Timestamp commit_timestamp */
        3:
          message.commitTimestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.commitTimestamp
          );
          break;
        case /* optional string consensus_commit_digest */
        4:
          message.consensusCommitDigest = reader.string();
          break;
        case /* optional uint64 sub_dag_index */
        5:
          message.subDagIndex = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.ConsensusDeterminedVersionAssignments consensus_determined_version_assignments */
        6:
          message.consensusDeterminedVersionAssignments = ConsensusDeterminedVersionAssignments.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.consensusDeterminedVersionAssignments
          );
          break;
        case /* optional string additional_state_digest */
        7:
          message.additionalStateDigest = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, WireType.Varint).uint64(message.epoch);
    if (message.round !== void 0) writer.tag(2, WireType.Varint).uint64(message.round);
    if (message.commitTimestamp)
      Timestamp.internalBinaryWrite(
        message.commitTimestamp,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.consensusCommitDigest !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.consensusCommitDigest);
    if (message.subDagIndex !== void 0)
      writer.tag(5, WireType.Varint).uint64(message.subDagIndex);
    if (message.consensusDeterminedVersionAssignments)
      ConsensusDeterminedVersionAssignments.internalBinaryWrite(
        message.consensusDeterminedVersionAssignments,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.additionalStateDigest !== void 0)
      writer.tag(7, WireType.LengthDelimited).string(message.additionalStateDigest);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ConsensusCommitPrologue = new ConsensusCommitPrologue$Type();
class VersionAssignment$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.VersionAssignment", [
      {
        no: 1,
        name: "object_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "start_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string object_id */
        1:
          message.objectId = reader.string();
          break;
        case /* optional uint64 start_version */
        2:
          message.startVersion = reader.uint64().toBigInt();
          break;
        case /* optional uint64 version */
        3:
          message.version = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.objectId !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.objectId);
    if (message.startVersion !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.startVersion);
    if (message.version !== void 0) writer.tag(3, WireType.Varint).uint64(message.version);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VersionAssignment = new VersionAssignment$Type();
class CanceledTransaction$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CanceledTransaction", [
      {
        no: 1,
        name: "digest",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version_assignments",
        kind: "message",
        repeat: 2,
        T: () => VersionAssignment
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.versionAssignments = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string digest */
        1:
          message.digest = reader.string();
          break;
        case /* repeated sui.rpc.v2beta2.VersionAssignment version_assignments */
        2:
          message.versionAssignments.push(
            VersionAssignment.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.digest !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.digest);
    for (let i = 0; i < message.versionAssignments.length; i++)
      VersionAssignment.internalBinaryWrite(
        message.versionAssignments[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CanceledTransaction = new CanceledTransaction$Type();
class ConsensusDeterminedVersionAssignments$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ConsensusDeterminedVersionAssignments", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "canceled_transactions",
        kind: "message",
        repeat: 2,
        T: () => CanceledTransaction
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.canceledTransactions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 version */
        1:
          message.version = reader.int32();
          break;
        case /* repeated sui.rpc.v2beta2.CanceledTransaction canceled_transactions */
        3:
          message.canceledTransactions.push(
            CanceledTransaction.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== void 0) writer.tag(1, WireType.Varint).int32(message.version);
    for (let i = 0; i < message.canceledTransactions.length; i++)
      CanceledTransaction.internalBinaryWrite(
        message.canceledTransactions[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ConsensusDeterminedVersionAssignments = new ConsensusDeterminedVersionAssignments$Type();
class AuthenticatorStateUpdate$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.AuthenticatorStateUpdate", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "round",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "new_active_jwks",
        kind: "message",
        repeat: 2,
        T: () => ActiveJwk
      },
      {
        no: 4,
        name: "authenticator_object_initial_shared_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.newActiveJwks = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 round */
        2:
          message.round = reader.uint64().toBigInt();
          break;
        case /* repeated sui.rpc.v2beta2.ActiveJwk new_active_jwks */
        3:
          message.newActiveJwks.push(
            ActiveJwk.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional uint64 authenticator_object_initial_shared_version */
        4:
          message.authenticatorObjectInitialSharedVersion = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, WireType.Varint).uint64(message.epoch);
    if (message.round !== void 0) writer.tag(2, WireType.Varint).uint64(message.round);
    for (let i = 0; i < message.newActiveJwks.length; i++)
      ActiveJwk.internalBinaryWrite(
        message.newActiveJwks[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.authenticatorObjectInitialSharedVersion !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.authenticatorObjectInitialSharedVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AuthenticatorStateUpdate = new AuthenticatorStateUpdate$Type();
class ActiveJwk$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ActiveJwk", [
      { no: 1, name: "id", kind: "message", T: () => JwkId },
      { no: 2, name: "jwk", kind: "message", T: () => Jwk },
      {
        no: 3,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.JwkId id */
        1:
          message.id = JwkId.internalBinaryRead(reader, reader.uint32(), options, message.id);
          break;
        case /* optional sui.rpc.v2beta2.Jwk jwk */
        2:
          message.jwk = Jwk.internalBinaryRead(reader, reader.uint32(), options, message.jwk);
          break;
        case /* optional uint64 epoch */
        3:
          message.epoch = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id)
      JwkId.internalBinaryWrite(
        message.id,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.jwk)
      Jwk.internalBinaryWrite(
        message.jwk,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.epoch !== void 0) writer.tag(3, WireType.Varint).uint64(message.epoch);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ActiveJwk = new ActiveJwk$Type();
class JwkId$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.JwkId", [
      {
        no: 1,
        name: "iss",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "kid",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string iss */
        1:
          message.iss = reader.string();
          break;
        case /* optional string kid */
        2:
          message.kid = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.iss !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.iss);
    if (message.kid !== void 0) writer.tag(2, WireType.LengthDelimited).string(message.kid);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const JwkId = new JwkId$Type();
class Jwk$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Jwk", [
      {
        no: 1,
        name: "kty",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "e",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "n",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "alg",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string kty */
        1:
          message.kty = reader.string();
          break;
        case /* optional string e */
        2:
          message.e = reader.string();
          break;
        case /* optional string n */
        3:
          message.n = reader.string();
          break;
        case /* optional string alg */
        4:
          message.alg = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kty !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.kty);
    if (message.e !== void 0) writer.tag(2, WireType.LengthDelimited).string(message.e);
    if (message.n !== void 0) writer.tag(3, WireType.LengthDelimited).string(message.n);
    if (message.alg !== void 0) writer.tag(4, WireType.LengthDelimited).string(message.alg);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Jwk = new Jwk$Type();
class EndOfEpochTransaction$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.EndOfEpochTransaction", [
      {
        no: 1,
        name: "transactions",
        kind: "message",
        repeat: 2,
        T: () => EndOfEpochTransactionKind
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transactions = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.EndOfEpochTransactionKind transactions */
        1:
          message.transactions.push(
            EndOfEpochTransactionKind.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transactions.length; i++)
      EndOfEpochTransactionKind.internalBinaryWrite(
        message.transactions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EndOfEpochTransaction = new EndOfEpochTransaction$Type();
class EndOfEpochTransactionKind$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.EndOfEpochTransactionKind", [
      { no: 2, name: "change_epoch", kind: "message", oneof: "kind", T: () => ChangeEpoch },
      {
        no: 3,
        name: "authenticator_state_expire",
        kind: "message",
        oneof: "kind",
        T: () => AuthenticatorStateExpire
      },
      {
        no: 4,
        name: "execution_time_observations",
        kind: "message",
        oneof: "kind",
        T: () => ExecutionTimeObservations
      },
      {
        no: 200,
        name: "authenticator_state_create",
        kind: "message",
        oneof: "kind",
        T: () => Empty
      },
      { no: 201, name: "randomness_state_create", kind: "message", oneof: "kind", T: () => Empty },
      { no: 202, name: "deny_list_state_create", kind: "message", oneof: "kind", T: () => Empty },
      {
        no: 203,
        name: "bridge_state_create",
        kind: "scalar",
        oneof: "kind",
        T: 9
      },
      {
        no: 204,
        name: "bridge_committee_init",
        kind: "scalar",
        oneof: "kind",
        T: 4,
        L: 0
      },
      { no: 205, name: "accumulator_root_create", kind: "message", oneof: "kind", T: () => Empty },
      { no: 206, name: "coin_registry_create", kind: "message", oneof: "kind", T: () => Empty }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.kind = { oneofKind: void 0 };
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.ChangeEpoch change_epoch */
        2:
          message.kind = {
            oneofKind: "changeEpoch",
            changeEpoch: ChangeEpoch.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.changeEpoch
            )
          };
          break;
        case /* sui.rpc.v2beta2.AuthenticatorStateExpire authenticator_state_expire */
        3:
          message.kind = {
            oneofKind: "authenticatorStateExpire",
            authenticatorStateExpire: AuthenticatorStateExpire.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.authenticatorStateExpire
            )
          };
          break;
        case /* sui.rpc.v2beta2.ExecutionTimeObservations execution_time_observations */
        4:
          message.kind = {
            oneofKind: "executionTimeObservations",
            executionTimeObservations: ExecutionTimeObservations.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.executionTimeObservations
            )
          };
          break;
        case /* google.protobuf.Empty authenticator_state_create */
        200:
          message.kind = {
            oneofKind: "authenticatorStateCreate",
            authenticatorStateCreate: Empty.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.authenticatorStateCreate
            )
          };
          break;
        case /* google.protobuf.Empty randomness_state_create */
        201:
          message.kind = {
            oneofKind: "randomnessStateCreate",
            randomnessStateCreate: Empty.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.randomnessStateCreate
            )
          };
          break;
        case /* google.protobuf.Empty deny_list_state_create */
        202:
          message.kind = {
            oneofKind: "denyListStateCreate",
            denyListStateCreate: Empty.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.denyListStateCreate
            )
          };
          break;
        case /* string bridge_state_create */
        203:
          message.kind = {
            oneofKind: "bridgeStateCreate",
            bridgeStateCreate: reader.string()
          };
          break;
        case /* uint64 bridge_committee_init */
        204:
          message.kind = {
            oneofKind: "bridgeCommitteeInit",
            bridgeCommitteeInit: reader.uint64().toBigInt()
          };
          break;
        case /* google.protobuf.Empty accumulator_root_create */
        205:
          message.kind = {
            oneofKind: "accumulatorRootCreate",
            accumulatorRootCreate: Empty.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.accumulatorRootCreate
            )
          };
          break;
        case /* google.protobuf.Empty coin_registry_create */
        206:
          message.kind = {
            oneofKind: "coinRegistryCreate",
            coinRegistryCreate: Empty.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.kind.coinRegistryCreate
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind.oneofKind === "changeEpoch")
      ChangeEpoch.internalBinaryWrite(
        message.kind.changeEpoch,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "authenticatorStateExpire")
      AuthenticatorStateExpire.internalBinaryWrite(
        message.kind.authenticatorStateExpire,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "executionTimeObservations")
      ExecutionTimeObservations.internalBinaryWrite(
        message.kind.executionTimeObservations,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "authenticatorStateCreate")
      Empty.internalBinaryWrite(
        message.kind.authenticatorStateCreate,
        writer.tag(200, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "randomnessStateCreate")
      Empty.internalBinaryWrite(
        message.kind.randomnessStateCreate,
        writer.tag(201, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "denyListStateCreate")
      Empty.internalBinaryWrite(
        message.kind.denyListStateCreate,
        writer.tag(202, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "bridgeStateCreate")
      writer.tag(203, WireType.LengthDelimited).string(message.kind.bridgeStateCreate);
    if (message.kind.oneofKind === "bridgeCommitteeInit")
      writer.tag(204, WireType.Varint).uint64(message.kind.bridgeCommitteeInit);
    if (message.kind.oneofKind === "accumulatorRootCreate")
      Empty.internalBinaryWrite(
        message.kind.accumulatorRootCreate,
        writer.tag(205, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind.oneofKind === "coinRegistryCreate")
      Empty.internalBinaryWrite(
        message.kind.coinRegistryCreate,
        writer.tag(206, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const EndOfEpochTransactionKind = new EndOfEpochTransactionKind$Type();
class AuthenticatorStateExpire$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.AuthenticatorStateExpire", [
      {
        no: 1,
        name: "min_epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "authenticator_object_initial_shared_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 min_epoch */
        1:
          message.minEpoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 authenticator_object_initial_shared_version */
        2:
          message.authenticatorObjectInitialSharedVersion = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.minEpoch !== void 0) writer.tag(1, WireType.Varint).uint64(message.minEpoch);
    if (message.authenticatorObjectInitialSharedVersion !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.authenticatorObjectInitialSharedVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const AuthenticatorStateExpire = new AuthenticatorStateExpire$Type();
class ExecutionTimeObservations$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ExecutionTimeObservations", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "observations",
        kind: "message",
        repeat: 2,
        T: () => ExecutionTimeObservation
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.observations = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int32 version */
        1:
          message.version = reader.int32();
          break;
        case /* repeated sui.rpc.v2beta2.ExecutionTimeObservation observations */
        2:
          message.observations.push(
            ExecutionTimeObservation.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== void 0) writer.tag(1, WireType.Varint).int32(message.version);
    for (let i = 0; i < message.observations.length; i++)
      ExecutionTimeObservation.internalBinaryWrite(
        message.observations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionTimeObservations = new ExecutionTimeObservations$Type();
class ExecutionTimeObservation$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ExecutionTimeObservation", [
      {
        no: 1,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.ExecutionTimeObservation.ExecutionTimeObservationKind",
          ExecutionTimeObservation_ExecutionTimeObservationKind
        ]
      },
      { no: 2, name: "move_entry_point", kind: "message", T: () => MoveCall },
      {
        no: 3,
        name: "validator_observations",
        kind: "message",
        repeat: 2,
        T: () => ValidatorExecutionTimeObservation
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validatorObservations = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.ExecutionTimeObservation.ExecutionTimeObservationKind kind */
        1:
          message.kind = reader.int32();
          break;
        case /* optional sui.rpc.v2beta2.MoveCall move_entry_point */
        2:
          message.moveEntryPoint = MoveCall.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.moveEntryPoint
          );
          break;
        case /* repeated sui.rpc.v2beta2.ValidatorExecutionTimeObservation validator_observations */
        3:
          message.validatorObservations.push(
            ValidatorExecutionTimeObservation.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind !== void 0) writer.tag(1, WireType.Varint).int32(message.kind);
    if (message.moveEntryPoint)
      MoveCall.internalBinaryWrite(
        message.moveEntryPoint,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.validatorObservations.length; i++)
      ValidatorExecutionTimeObservation.internalBinaryWrite(
        message.validatorObservations[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionTimeObservation = new ExecutionTimeObservation$Type();
class ValidatorExecutionTimeObservation$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ValidatorExecutionTimeObservation", [
      {
        no: 1,
        name: "validator",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 2, name: "duration", kind: "message", T: () => Duration }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes validator */
        1:
          message.validator = reader.bytes();
          break;
        case /* optional google.protobuf.Duration duration */
        2:
          message.duration = Duration.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.duration
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.validator !== void 0)
      writer.tag(1, WireType.LengthDelimited).bytes(message.validator);
    if (message.duration)
      Duration.internalBinaryWrite(
        message.duration,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorExecutionTimeObservation = new ValidatorExecutionTimeObservation$Type();
export {
  ActiveJwk,
  AuthenticatorStateExpire,
  AuthenticatorStateUpdate,
  CanceledTransaction,
  ChangeEpoch,
  Command,
  ConsensusCommitPrologue,
  ConsensusDeterminedVersionAssignments,
  EndOfEpochTransaction,
  EndOfEpochTransactionKind,
  ExecutionTimeObservation,
  ExecutionTimeObservation_ExecutionTimeObservationKind,
  ExecutionTimeObservations,
  GasPayment,
  GenesisTransaction,
  Jwk,
  JwkId,
  MakeMoveVector,
  MergeCoins,
  MoveCall,
  ProgrammableTransaction,
  Publish,
  RandomnessStateUpdate,
  SplitCoins,
  SystemPackage,
  Transaction,
  TransactionExpiration,
  TransactionExpiration_TransactionExpirationKind,
  TransactionKind,
  TransferObjects,
  Upgrade,
  ValidatorExecutionTimeObservation,
  VersionAssignment
};
//# sourceMappingURL=transaction.js.map
