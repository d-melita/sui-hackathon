import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Epoch } from "./epoch.js";
import { Checkpoint } from "./checkpoint.js";
import { ExecutedTransaction } from "./executed_transaction.js";
import { Status } from "../../../google/rpc/status.js";
import { Object } from "./object.js";
import { FieldMask } from "../../../google/protobuf/field_mask.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";
class GetServiceInfoRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetServiceInfoRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetServiceInfoRequest = new GetServiceInfoRequest$Type();
class GetServiceInfoResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetServiceInfoResponse", [
      {
        no: 1,
        name: "chain_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "chain",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "checkpoint_height",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 5, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 6,
        name: "lowest_available_checkpoint",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 7,
        name: "lowest_available_checkpoint_objects",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 8,
        name: "server",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string chain_id */
        1:
          message.chainId = reader.string();
          break;
        case /* optional string chain */
        2:
          message.chain = reader.string();
          break;
        case /* optional uint64 epoch */
        3:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 checkpoint_height */
        4:
          message.checkpointHeight = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.Timestamp timestamp */
        5:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp
          );
          break;
        case /* optional uint64 lowest_available_checkpoint */
        6:
          message.lowestAvailableCheckpoint = reader.uint64().toBigInt();
          break;
        case /* optional uint64 lowest_available_checkpoint_objects */
        7:
          message.lowestAvailableCheckpointObjects = reader.uint64().toBigInt();
          break;
        case /* optional string server */
        8:
          message.server = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.chainId !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.chainId);
    if (message.chain !== void 0) writer.tag(2, WireType.LengthDelimited).string(message.chain);
    if (message.epoch !== void 0) writer.tag(3, WireType.Varint).uint64(message.epoch);
    if (message.checkpointHeight !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.checkpointHeight);
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.lowestAvailableCheckpoint !== void 0)
      writer.tag(6, WireType.Varint).uint64(message.lowestAvailableCheckpoint);
    if (message.lowestAvailableCheckpointObjects !== void 0)
      writer.tag(7, WireType.Varint).uint64(message.lowestAvailableCheckpointObjects);
    if (message.server !== void 0)
      writer.tag(8, WireType.LengthDelimited).string(message.server);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetServiceInfoResponse = new GetServiceInfoResponse$Type();
class GetObjectRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetObjectRequest", [
      {
        no: 1,
        name: "object_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 3, name: "read_mask", kind: "message", T: () => FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string object_id */
        1:
          message.objectId = reader.string();
          break;
        case /* optional uint64 version */
        2:
          message.version = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        3:
          message.readMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.objectId !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.objectId);
    if (message.version !== void 0) writer.tag(2, WireType.Varint).uint64(message.version);
    if (message.readMask)
      FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetObjectRequest = new GetObjectRequest$Type();
class GetObjectResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetObjectResponse", [
      { no: 1, name: "object", kind: "message", T: () => Object }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Object object */
        1:
          message.object = Object.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.object
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.object)
      Object.internalBinaryWrite(
        message.object,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetObjectResponse = new GetObjectResponse$Type();
class BatchGetObjectsRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetObjectsRequest", [
      {
        no: 1,
        name: "requests",
        kind: "message",
        repeat: 2,
        T: () => GetObjectRequest
      },
      { no: 2, name: "read_mask", kind: "message", T: () => FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.requests = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.GetObjectRequest requests */
        1:
          message.requests.push(
            GetObjectRequest.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.requests.length; i++)
      GetObjectRequest.internalBinaryWrite(
        message.requests[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.readMask)
      FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetObjectsRequest = new BatchGetObjectsRequest$Type();
class BatchGetObjectsResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetObjectsResponse", [
      {
        no: 1,
        name: "objects",
        kind: "message",
        repeat: 2,
        T: () => GetObjectResult
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.GetObjectResult objects */
        1:
          message.objects.push(
            GetObjectResult.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      GetObjectResult.internalBinaryWrite(
        message.objects[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetObjectsResponse = new BatchGetObjectsResponse$Type();
class GetObjectResult$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetObjectResult", [
      { no: 1, name: "object", kind: "message", oneof: "result", T: () => Object },
      { no: 2, name: "error", kind: "message", oneof: "result", T: () => Status }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.Object object */
        1:
          message.result = {
            oneofKind: "object",
            object: Object.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.object
            )
          };
          break;
        case /* google.rpc.Status error */
        2:
          message.result = {
            oneofKind: "error",
            error: Status.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.error
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result.oneofKind === "object")
      Object.internalBinaryWrite(
        message.result.object,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.result.oneofKind === "error")
      Status.internalBinaryWrite(
        message.result.error,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetObjectResult = new GetObjectResult$Type();
class GetTransactionRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetTransactionRequest", [
      {
        no: 1,
        name: "digest",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "read_mask", kind: "message", T: () => FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string digest */
        1:
          message.digest = reader.string();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.digest !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.digest);
    if (message.readMask)
      FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTransactionRequest = new GetTransactionRequest$Type();
class GetTransactionResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetTransactionResponse", [
      { no: 1, name: "transaction", kind: "message", T: () => ExecutedTransaction }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.ExecutedTransaction transaction */
        1:
          message.transaction = ExecutedTransaction.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.transaction
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      ExecutedTransaction.internalBinaryWrite(
        message.transaction,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTransactionResponse = new GetTransactionResponse$Type();
class BatchGetTransactionsRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetTransactionsRequest", [
      {
        no: 1,
        name: "digests",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      { no: 2, name: "read_mask", kind: "message", T: () => FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.digests = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string digests */
        1:
          message.digests.push(reader.string());
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.digests.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.digests[i]);
    if (message.readMask)
      FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetTransactionsRequest = new BatchGetTransactionsRequest$Type();
class BatchGetTransactionsResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetTransactionsResponse", [
      {
        no: 1,
        name: "transactions",
        kind: "message",
        repeat: 2,
        T: () => GetTransactionResult
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transactions = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.GetTransactionResult transactions */
        1:
          message.transactions.push(
            GetTransactionResult.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transactions.length; i++)
      GetTransactionResult.internalBinaryWrite(
        message.transactions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetTransactionsResponse = new BatchGetTransactionsResponse$Type();
class GetTransactionResult$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetTransactionResult", [
      {
        no: 1,
        name: "transaction",
        kind: "message",
        oneof: "result",
        T: () => ExecutedTransaction
      },
      { no: 2, name: "error", kind: "message", oneof: "result", T: () => Status }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.ExecutedTransaction transaction */
        1:
          message.result = {
            oneofKind: "transaction",
            transaction: ExecutedTransaction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.transaction
            )
          };
          break;
        case /* google.rpc.Status error */
        2:
          message.result = {
            oneofKind: "error",
            error: Status.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.error
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result.oneofKind === "transaction")
      ExecutedTransaction.internalBinaryWrite(
        message.result.transaction,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.result.oneofKind === "error")
      Status.internalBinaryWrite(
        message.result.error,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTransactionResult = new GetTransactionResult$Type();
class GetCheckpointRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetCheckpointRequest", [
      {
        no: 1,
        name: "sequence_number",
        kind: "scalar",
        oneof: "checkpointId",
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "digest",
        kind: "scalar",
        oneof: "checkpointId",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "read_mask", kind: "message", T: () => FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.checkpointId = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 sequence_number */
        1:
          message.checkpointId = {
            oneofKind: "sequenceNumber",
            sequenceNumber: reader.uint64().toBigInt()
          };
          break;
        case /* string digest */
        2:
          message.checkpointId = {
            oneofKind: "digest",
            digest: reader.string()
          };
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        3:
          message.readMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.checkpointId.oneofKind === "sequenceNumber")
      writer.tag(1, WireType.Varint).uint64(message.checkpointId.sequenceNumber);
    if (message.checkpointId.oneofKind === "digest")
      writer.tag(2, WireType.LengthDelimited).string(message.checkpointId.digest);
    if (message.readMask)
      FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCheckpointRequest = new GetCheckpointRequest$Type();
class GetCheckpointResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetCheckpointResponse", [
      { no: 1, name: "checkpoint", kind: "message", T: () => Checkpoint }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Checkpoint checkpoint */
        1:
          message.checkpoint = Checkpoint.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.checkpoint
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.checkpoint)
      Checkpoint.internalBinaryWrite(
        message.checkpoint,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCheckpointResponse = new GetCheckpointResponse$Type();
class GetEpochRequest$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetEpochRequest", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 2, name: "read_mask", kind: "message", T: () => FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, WireType.Varint).uint64(message.epoch);
    if (message.readMask)
      FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetEpochRequest = new GetEpochRequest$Type();
class GetEpochResponse$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetEpochResponse", [
      { no: 1, name: "epoch", kind: "message", T: () => Epoch }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Epoch epoch */
        1:
          message.epoch = Epoch.internalBinaryRead(reader, reader.uint32(), options, message.epoch);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch)
      Epoch.internalBinaryWrite(
        message.epoch,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetEpochResponse = new GetEpochResponse$Type();
const LedgerService = new ServiceType("sui.rpc.v2beta2.LedgerService", [
  { name: "GetServiceInfo", options: {}, I: GetServiceInfoRequest, O: GetServiceInfoResponse },
  { name: "GetObject", options: {}, I: GetObjectRequest, O: GetObjectResponse },
  { name: "BatchGetObjects", options: {}, I: BatchGetObjectsRequest, O: BatchGetObjectsResponse },
  { name: "GetTransaction", options: {}, I: GetTransactionRequest, O: GetTransactionResponse },
  {
    name: "BatchGetTransactions",
    options: {},
    I: BatchGetTransactionsRequest,
    O: BatchGetTransactionsResponse
  },
  { name: "GetCheckpoint", options: {}, I: GetCheckpointRequest, O: GetCheckpointResponse },
  { name: "GetEpoch", options: {}, I: GetEpochRequest, O: GetEpochResponse }
]);
export {
  BatchGetObjectsRequest,
  BatchGetObjectsResponse,
  BatchGetTransactionsRequest,
  BatchGetTransactionsResponse,
  GetCheckpointRequest,
  GetCheckpointResponse,
  GetEpochRequest,
  GetEpochResponse,
  GetObjectRequest,
  GetObjectResponse,
  GetObjectResult,
  GetServiceInfoRequest,
  GetServiceInfoResponse,
  GetTransactionRequest,
  GetTransactionResponse,
  GetTransactionResult,
  LedgerService
};
//# sourceMappingURL=ledger_service.js.map
