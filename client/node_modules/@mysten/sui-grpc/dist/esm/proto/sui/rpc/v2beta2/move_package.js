import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
var DatatypeDescriptor_DatatypeKind = /* @__PURE__ */ ((DatatypeDescriptor_DatatypeKind2) => {
  DatatypeDescriptor_DatatypeKind2[DatatypeDescriptor_DatatypeKind2["DATATYPE_KIND_UNKNOWN"] = 0] = "DATATYPE_KIND_UNKNOWN";
  DatatypeDescriptor_DatatypeKind2[DatatypeDescriptor_DatatypeKind2["STRUCT"] = 1] = "STRUCT";
  DatatypeDescriptor_DatatypeKind2[DatatypeDescriptor_DatatypeKind2["ENUM"] = 2] = "ENUM";
  return DatatypeDescriptor_DatatypeKind2;
})(DatatypeDescriptor_DatatypeKind || {});
var OpenSignatureBody_Type = /* @__PURE__ */ ((OpenSignatureBody_Type2) => {
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["ADDRESS"] = 1] = "ADDRESS";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["BOOL"] = 2] = "BOOL";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["U8"] = 3] = "U8";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["U16"] = 4] = "U16";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["U32"] = 5] = "U32";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["U64"] = 6] = "U64";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["U128"] = 7] = "U128";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["U256"] = 8] = "U256";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["VECTOR"] = 9] = "VECTOR";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["DATATYPE"] = 10] = "DATATYPE";
  OpenSignatureBody_Type2[OpenSignatureBody_Type2["TYPE_PARAMETER"] = 11] = "TYPE_PARAMETER";
  return OpenSignatureBody_Type2;
})(OpenSignatureBody_Type || {});
var FunctionDescriptor_Visibility = /* @__PURE__ */ ((FunctionDescriptor_Visibility2) => {
  FunctionDescriptor_Visibility2[FunctionDescriptor_Visibility2["VISIBILITY_UNKNOWN"] = 0] = "VISIBILITY_UNKNOWN";
  FunctionDescriptor_Visibility2[FunctionDescriptor_Visibility2["PRIVATE"] = 1] = "PRIVATE";
  FunctionDescriptor_Visibility2[FunctionDescriptor_Visibility2["PUBLIC"] = 2] = "PUBLIC";
  FunctionDescriptor_Visibility2[FunctionDescriptor_Visibility2["FRIEND"] = 3] = "FRIEND";
  return FunctionDescriptor_Visibility2;
})(FunctionDescriptor_Visibility || {});
var OpenSignature_Reference = /* @__PURE__ */ ((OpenSignature_Reference2) => {
  OpenSignature_Reference2[OpenSignature_Reference2["REFERENCE_UNKNOWN"] = 0] = "REFERENCE_UNKNOWN";
  OpenSignature_Reference2[OpenSignature_Reference2["IMMUTABLE"] = 1] = "IMMUTABLE";
  OpenSignature_Reference2[OpenSignature_Reference2["MUTABLE"] = 2] = "MUTABLE";
  return OpenSignature_Reference2;
})(OpenSignature_Reference || {});
var Ability = /* @__PURE__ */ ((Ability2) => {
  Ability2[Ability2["ABILITY_UNKNOWN"] = 0] = "ABILITY_UNKNOWN";
  Ability2[Ability2["COPY"] = 1] = "COPY";
  Ability2[Ability2["DROP"] = 2] = "DROP";
  Ability2[Ability2["STORE"] = 3] = "STORE";
  Ability2[Ability2["KEY"] = 4] = "KEY";
  return Ability2;
})(Ability || {});
class Package$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Package", [
      {
        no: 1,
        name: "storage_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "original_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "modules",
        kind: "message",
        repeat: 2,
        T: () => Module
      },
      {
        no: 5,
        name: "type_origins",
        kind: "message",
        repeat: 2,
        T: () => TypeOrigin
      },
      {
        no: 6,
        name: "linkage",
        kind: "message",
        repeat: 2,
        T: () => Linkage
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.modules = [];
    message.typeOrigins = [];
    message.linkage = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string storage_id */
        1:
          message.storageId = reader.string();
          break;
        case /* optional string original_id */
        2:
          message.originalId = reader.string();
          break;
        case /* optional uint64 version */
        3:
          message.version = reader.uint64().toBigInt();
          break;
        case /* repeated sui.rpc.v2beta2.Module modules */
        4:
          message.modules.push(Module.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated sui.rpc.v2beta2.TypeOrigin type_origins */
        5:
          message.typeOrigins.push(TypeOrigin.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated sui.rpc.v2beta2.Linkage linkage */
        6:
          message.linkage.push(Linkage.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.storageId !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.storageId);
    if (message.originalId !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.originalId);
    if (message.version !== void 0) writer.tag(3, WireType.Varint).uint64(message.version);
    for (let i = 0; i < message.modules.length; i++)
      Module.internalBinaryWrite(
        message.modules[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.typeOrigins.length; i++)
      TypeOrigin.internalBinaryWrite(
        message.typeOrigins[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.linkage.length; i++)
      Linkage.internalBinaryWrite(
        message.linkage[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Package = new Package$Type();
class Module$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Module", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contents",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "datatypes",
        kind: "message",
        repeat: 2,
        T: () => DatatypeDescriptor
      },
      {
        no: 4,
        name: "functions",
        kind: "message",
        repeat: 2,
        T: () => FunctionDescriptor
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.datatypes = [];
    message.functions = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */
        1:
          message.name = reader.string();
          break;
        case /* optional bytes contents */
        2:
          message.contents = reader.bytes();
          break;
        case /* repeated sui.rpc.v2beta2.DatatypeDescriptor datatypes */
        3:
          message.datatypes.push(
            DatatypeDescriptor.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* repeated sui.rpc.v2beta2.FunctionDescriptor functions */
        4:
          message.functions.push(
            FunctionDescriptor.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.contents !== void 0)
      writer.tag(2, WireType.LengthDelimited).bytes(message.contents);
    for (let i = 0; i < message.datatypes.length; i++)
      DatatypeDescriptor.internalBinaryWrite(
        message.datatypes[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.functions.length; i++)
      FunctionDescriptor.internalBinaryWrite(
        message.functions[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Module = new Module$Type();
class DatatypeDescriptor$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.DatatypeDescriptor", [
      {
        no: 1,
        name: "type_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "defining_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "module",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "abilities",
        kind: "enum",
        repeat: 1,
        T: () => ["sui.rpc.v2beta2.Ability", Ability]
      },
      {
        no: 6,
        name: "type_parameters",
        kind: "message",
        repeat: 2,
        T: () => TypeParameter
      },
      {
        no: 7,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.DatatypeDescriptor.DatatypeKind",
          DatatypeDescriptor_DatatypeKind
        ]
      },
      {
        no: 8,
        name: "fields",
        kind: "message",
        repeat: 2,
        T: () => FieldDescriptor
      },
      {
        no: 9,
        name: "variants",
        kind: "message",
        repeat: 2,
        T: () => VariantDescriptor
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.abilities = [];
    message.typeParameters = [];
    message.fields = [];
    message.variants = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string type_name */
        1:
          message.typeName = reader.string();
          break;
        case /* optional string defining_id */
        2:
          message.definingId = reader.string();
          break;
        case /* optional string module */
        3:
          message.module = reader.string();
          break;
        case /* optional string name */
        4:
          message.name = reader.string();
          break;
        case /* repeated sui.rpc.v2beta2.Ability abilities */
        5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.abilities.push(reader.int32());
          else message.abilities.push(reader.int32());
          break;
        case /* repeated sui.rpc.v2beta2.TypeParameter type_parameters */
        6:
          message.typeParameters.push(
            TypeParameter.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional sui.rpc.v2beta2.DatatypeDescriptor.DatatypeKind kind */
        7:
          message.kind = reader.int32();
          break;
        case /* repeated sui.rpc.v2beta2.FieldDescriptor fields */
        8:
          message.fields.push(FieldDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated sui.rpc.v2beta2.VariantDescriptor variants */
        9:
          message.variants.push(
            VariantDescriptor.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.typeName !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.typeName);
    if (message.definingId !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.definingId);
    if (message.module !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.module);
    if (message.name !== void 0) writer.tag(4, WireType.LengthDelimited).string(message.name);
    if (message.abilities.length) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.abilities.length; i++) writer.int32(message.abilities[i]);
      writer.join();
    }
    for (let i = 0; i < message.typeParameters.length; i++)
      TypeParameter.internalBinaryWrite(
        message.typeParameters[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.kind !== void 0) writer.tag(7, WireType.Varint).int32(message.kind);
    for (let i = 0; i < message.fields.length; i++)
      FieldDescriptor.internalBinaryWrite(
        message.fields[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.variants.length; i++)
      VariantDescriptor.internalBinaryWrite(
        message.variants[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DatatypeDescriptor = new DatatypeDescriptor$Type();
class TypeParameter$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.TypeParameter", [
      {
        no: 1,
        name: "constraints",
        kind: "enum",
        repeat: 1,
        T: () => ["sui.rpc.v2beta2.Ability", Ability]
      },
      {
        no: 2,
        name: "is_phantom",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.constraints = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.Ability constraints */
        1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.constraints.push(reader.int32());
          else message.constraints.push(reader.int32());
          break;
        case /* optional bool is_phantom */
        2:
          message.isPhantom = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.constraints.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.constraints.length; i++) writer.int32(message.constraints[i]);
      writer.join();
    }
    if (message.isPhantom !== void 0) writer.tag(2, WireType.Varint).bool(message.isPhantom);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TypeParameter = new TypeParameter$Type();
class FieldDescriptor$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.FieldDescriptor", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "position",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      { no: 3, name: "type", kind: "message", T: () => OpenSignatureBody }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */
        1:
          message.name = reader.string();
          break;
        case /* optional uint32 position */
        2:
          message.position = reader.uint32();
          break;
        case /* optional sui.rpc.v2beta2.OpenSignatureBody type */
        3:
          message.type = OpenSignatureBody.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.type
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.position !== void 0) writer.tag(2, WireType.Varint).uint32(message.position);
    if (message.type)
      OpenSignatureBody.internalBinaryWrite(
        message.type,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FieldDescriptor = new FieldDescriptor$Type();
class VariantDescriptor$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.VariantDescriptor", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "position",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "fields",
        kind: "message",
        repeat: 2,
        T: () => FieldDescriptor
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.fields = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */
        1:
          message.name = reader.string();
          break;
        case /* optional uint32 position */
        2:
          message.position = reader.uint32();
          break;
        case /* repeated sui.rpc.v2beta2.FieldDescriptor fields */
        3:
          message.fields.push(FieldDescriptor.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.position !== void 0) writer.tag(2, WireType.Varint).uint32(message.position);
    for (let i = 0; i < message.fields.length; i++)
      FieldDescriptor.internalBinaryWrite(
        message.fields[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const VariantDescriptor = new VariantDescriptor$Type();
class OpenSignatureBody$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.OpenSignatureBody", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.OpenSignatureBody.Type", OpenSignatureBody_Type]
      },
      {
        no: 2,
        name: "type_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "type_parameter_instantiation",
        kind: "message",
        repeat: 2,
        T: () => OpenSignatureBody
      },
      {
        no: 4,
        name: "type_parameter",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.typeParameterInstantiation = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.OpenSignatureBody.Type type */
        1:
          message.type = reader.int32();
          break;
        case /* optional string type_name */
        2:
          message.typeName = reader.string();
          break;
        case /* repeated sui.rpc.v2beta2.OpenSignatureBody type_parameter_instantiation */
        3:
          message.typeParameterInstantiation.push(
            OpenSignatureBody.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional uint32 type_parameter */
        4:
          message.typeParameter = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== void 0) writer.tag(1, WireType.Varint).int32(message.type);
    if (message.typeName !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.typeName);
    for (let i = 0; i < message.typeParameterInstantiation.length; i++)
      OpenSignatureBody.internalBinaryWrite(
        message.typeParameterInstantiation[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.typeParameter !== void 0)
      writer.tag(4, WireType.Varint).uint32(message.typeParameter);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenSignatureBody = new OpenSignatureBody$Type();
class FunctionDescriptor$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.FunctionDescriptor", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "visibility",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.FunctionDescriptor.Visibility", FunctionDescriptor_Visibility]
      },
      {
        no: 6,
        name: "is_entry",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "type_parameters",
        kind: "message",
        repeat: 2,
        T: () => TypeParameter
      },
      {
        no: 8,
        name: "parameters",
        kind: "message",
        repeat: 2,
        T: () => OpenSignature
      },
      {
        no: 9,
        name: "returns",
        kind: "message",
        repeat: 2,
        T: () => OpenSignature
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.typeParameters = [];
    message.parameters = [];
    message.returns = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */
        1:
          message.name = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.FunctionDescriptor.Visibility visibility */
        5:
          message.visibility = reader.int32();
          break;
        case /* optional bool is_entry */
        6:
          message.isEntry = reader.bool();
          break;
        case /* repeated sui.rpc.v2beta2.TypeParameter type_parameters */
        7:
          message.typeParameters.push(
            TypeParameter.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* repeated sui.rpc.v2beta2.OpenSignature parameters */
        8:
          message.parameters.push(
            OpenSignature.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* repeated sui.rpc.v2beta2.OpenSignature returns */
        9:
          message.returns.push(OpenSignature.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.visibility !== void 0) writer.tag(5, WireType.Varint).int32(message.visibility);
    if (message.isEntry !== void 0) writer.tag(6, WireType.Varint).bool(message.isEntry);
    for (let i = 0; i < message.typeParameters.length; i++)
      TypeParameter.internalBinaryWrite(
        message.typeParameters[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.parameters.length; i++)
      OpenSignature.internalBinaryWrite(
        message.parameters[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.returns.length; i++)
      OpenSignature.internalBinaryWrite(
        message.returns[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const FunctionDescriptor = new FunctionDescriptor$Type();
class OpenSignature$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.OpenSignature", [
      {
        no: 1,
        name: "reference",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.OpenSignature.Reference", OpenSignature_Reference]
      },
      { no: 2, name: "body", kind: "message", T: () => OpenSignatureBody }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.OpenSignature.Reference reference */
        1:
          message.reference = reader.int32();
          break;
        case /* optional sui.rpc.v2beta2.OpenSignatureBody body */
        2:
          message.body = OpenSignatureBody.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.body
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.reference !== void 0) writer.tag(1, WireType.Varint).int32(message.reference);
    if (message.body)
      OpenSignatureBody.internalBinaryWrite(
        message.body,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const OpenSignature = new OpenSignature$Type();
class TypeOrigin$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.TypeOrigin", [
      {
        no: 1,
        name: "module_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "datatype_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "package_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string module_name */
        1:
          message.moduleName = reader.string();
          break;
        case /* optional string datatype_name */
        2:
          message.datatypeName = reader.string();
          break;
        case /* optional string package_id */
        3:
          message.packageId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.moduleName !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.moduleName);
    if (message.datatypeName !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.datatypeName);
    if (message.packageId !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.packageId);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TypeOrigin = new TypeOrigin$Type();
class Linkage$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Linkage", [
      {
        no: 1,
        name: "original_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "upgraded_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "upgraded_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string original_id */
        1:
          message.originalId = reader.string();
          break;
        case /* optional string upgraded_id */
        2:
          message.upgradedId = reader.string();
          break;
        case /* optional uint64 upgraded_version */
        3:
          message.upgradedVersion = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.originalId !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.originalId);
    if (message.upgradedId !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.upgradedId);
    if (message.upgradedVersion !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.upgradedVersion);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Linkage = new Linkage$Type();
export {
  Ability,
  DatatypeDescriptor,
  DatatypeDescriptor_DatatypeKind,
  FieldDescriptor,
  FunctionDescriptor,
  FunctionDescriptor_Visibility,
  Linkage,
  Module,
  OpenSignature,
  OpenSignatureBody,
  OpenSignatureBody_Type,
  OpenSignature_Reference,
  Package,
  TypeOrigin,
  TypeParameter,
  VariantDescriptor
};
//# sourceMappingURL=move_package.js.map
