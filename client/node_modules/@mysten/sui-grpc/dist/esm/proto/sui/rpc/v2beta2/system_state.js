import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class SystemState$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SystemState", [
      {
        no: 1,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "protocol_version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 4, name: "validators", kind: "message", T: () => ValidatorSet },
      { no: 5, name: "storage_fund", kind: "message", T: () => StorageFund },
      { no: 6, name: "parameters", kind: "message", T: () => SystemParameters },
      {
        no: 7,
        name: "reference_gas_price",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 8,
        name: "validator_report_records",
        kind: "message",
        repeat: 2,
        T: () => ValidatorReportRecord
      },
      { no: 9, name: "stake_subsidy", kind: "message", T: () => StakeSubsidy },
      {
        no: 10,
        name: "safe_mode",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "safe_mode_storage_rewards",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 12,
        name: "safe_mode_computation_rewards",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 13,
        name: "safe_mode_storage_rebates",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 14,
        name: "safe_mode_non_refundable_storage_fee",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 15,
        name: "epoch_start_timestamp_ms",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 16, name: "extra_fields", kind: "message", T: () => MoveTable }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.validatorReportRecords = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 version */
        1:
          message.version = reader.uint64().toBigInt();
          break;
        case /* optional uint64 epoch */
        2:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 protocol_version */
        3:
          message.protocolVersion = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.ValidatorSet validators */
        4:
          message.validators = ValidatorSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.validators
          );
          break;
        case /* optional sui.rpc.v2beta2.StorageFund storage_fund */
        5:
          message.storageFund = StorageFund.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.storageFund
          );
          break;
        case /* optional sui.rpc.v2beta2.SystemParameters parameters */
        6:
          message.parameters = SystemParameters.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.parameters
          );
          break;
        case /* optional uint64 reference_gas_price */
        7:
          message.referenceGasPrice = reader.uint64().toBigInt();
          break;
        case /* repeated sui.rpc.v2beta2.ValidatorReportRecord validator_report_records */
        8:
          message.validatorReportRecords.push(
            ValidatorReportRecord.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional sui.rpc.v2beta2.StakeSubsidy stake_subsidy */
        9:
          message.stakeSubsidy = StakeSubsidy.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.stakeSubsidy
          );
          break;
        case /* optional bool safe_mode */
        10:
          message.safeMode = reader.bool();
          break;
        case /* optional uint64 safe_mode_storage_rewards */
        11:
          message.safeModeStorageRewards = reader.uint64().toBigInt();
          break;
        case /* optional uint64 safe_mode_computation_rewards */
        12:
          message.safeModeComputationRewards = reader.uint64().toBigInt();
          break;
        case /* optional uint64 safe_mode_storage_rebates */
        13:
          message.safeModeStorageRebates = reader.uint64().toBigInt();
          break;
        case /* optional uint64 safe_mode_non_refundable_storage_fee */
        14:
          message.safeModeNonRefundableStorageFee = reader.uint64().toBigInt();
          break;
        case /* optional uint64 epoch_start_timestamp_ms */
        15:
          message.epochStartTimestampMs = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable extra_fields */
        16:
          message.extraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.extraFields
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.version !== void 0) writer.tag(1, WireType.Varint).uint64(message.version);
    if (message.epoch !== void 0) writer.tag(2, WireType.Varint).uint64(message.epoch);
    if (message.protocolVersion !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.protocolVersion);
    if (message.validators)
      ValidatorSet.internalBinaryWrite(
        message.validators,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.storageFund)
      StorageFund.internalBinaryWrite(
        message.storageFund,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.parameters)
      SystemParameters.internalBinaryWrite(
        message.parameters,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.referenceGasPrice !== void 0)
      writer.tag(7, WireType.Varint).uint64(message.referenceGasPrice);
    for (let i = 0; i < message.validatorReportRecords.length; i++)
      ValidatorReportRecord.internalBinaryWrite(
        message.validatorReportRecords[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.stakeSubsidy)
      StakeSubsidy.internalBinaryWrite(
        message.stakeSubsidy,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.safeMode !== void 0) writer.tag(10, WireType.Varint).bool(message.safeMode);
    if (message.safeModeStorageRewards !== void 0)
      writer.tag(11, WireType.Varint).uint64(message.safeModeStorageRewards);
    if (message.safeModeComputationRewards !== void 0)
      writer.tag(12, WireType.Varint).uint64(message.safeModeComputationRewards);
    if (message.safeModeStorageRebates !== void 0)
      writer.tag(13, WireType.Varint).uint64(message.safeModeStorageRebates);
    if (message.safeModeNonRefundableStorageFee !== void 0)
      writer.tag(14, WireType.Varint).uint64(message.safeModeNonRefundableStorageFee);
    if (message.epochStartTimestampMs !== void 0)
      writer.tag(15, WireType.Varint).uint64(message.epochStartTimestampMs);
    if (message.extraFields)
      MoveTable.internalBinaryWrite(
        message.extraFields,
        writer.tag(16, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SystemState = new SystemState$Type();
class ValidatorReportRecord$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ValidatorReportRecord", [
      {
        no: 1,
        name: "reported",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "reporters",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.reporters = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string reported */
        1:
          message.reported = reader.string();
          break;
        case /* repeated string reporters */
        2:
          message.reporters.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.reported !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.reported);
    for (let i = 0; i < message.reporters.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.reporters[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorReportRecord = new ValidatorReportRecord$Type();
class SystemParameters$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SystemParameters", [
      {
        no: 1,
        name: "epoch_duration_ms",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "stake_subsidy_start_epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "min_validator_count",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "max_validator_count",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 5,
        name: "min_validator_joining_stake",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 6,
        name: "validator_low_stake_threshold",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 7,
        name: "validator_very_low_stake_threshold",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 8,
        name: "validator_low_stake_grace_period",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 9, name: "extra_fields", kind: "message", T: () => MoveTable }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch_duration_ms */
        1:
          message.epochDurationMs = reader.uint64().toBigInt();
          break;
        case /* optional uint64 stake_subsidy_start_epoch */
        2:
          message.stakeSubsidyStartEpoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 min_validator_count */
        3:
          message.minValidatorCount = reader.uint64().toBigInt();
          break;
        case /* optional uint64 max_validator_count */
        4:
          message.maxValidatorCount = reader.uint64().toBigInt();
          break;
        case /* optional uint64 min_validator_joining_stake */
        5:
          message.minValidatorJoiningStake = reader.uint64().toBigInt();
          break;
        case /* optional uint64 validator_low_stake_threshold */
        6:
          message.validatorLowStakeThreshold = reader.uint64().toBigInt();
          break;
        case /* optional uint64 validator_very_low_stake_threshold */
        7:
          message.validatorVeryLowStakeThreshold = reader.uint64().toBigInt();
          break;
        case /* optional uint64 validator_low_stake_grace_period */
        8:
          message.validatorLowStakeGracePeriod = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable extra_fields */
        9:
          message.extraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.extraFields
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epochDurationMs !== void 0)
      writer.tag(1, WireType.Varint).uint64(message.epochDurationMs);
    if (message.stakeSubsidyStartEpoch !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.stakeSubsidyStartEpoch);
    if (message.minValidatorCount !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.minValidatorCount);
    if (message.maxValidatorCount !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.maxValidatorCount);
    if (message.minValidatorJoiningStake !== void 0)
      writer.tag(5, WireType.Varint).uint64(message.minValidatorJoiningStake);
    if (message.validatorLowStakeThreshold !== void 0)
      writer.tag(6, WireType.Varint).uint64(message.validatorLowStakeThreshold);
    if (message.validatorVeryLowStakeThreshold !== void 0)
      writer.tag(7, WireType.Varint).uint64(message.validatorVeryLowStakeThreshold);
    if (message.validatorLowStakeGracePeriod !== void 0)
      writer.tag(8, WireType.Varint).uint64(message.validatorLowStakeGracePeriod);
    if (message.extraFields)
      MoveTable.internalBinaryWrite(
        message.extraFields,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SystemParameters = new SystemParameters$Type();
class MoveTable$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MoveTable", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string id */
        1:
          message.id = reader.string();
          break;
        case /* optional uint64 size */
        2:
          message.size = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.size !== void 0) writer.tag(2, WireType.Varint).uint64(message.size);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MoveTable = new MoveTable$Type();
class StakeSubsidy$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.StakeSubsidy", [
      {
        no: 1,
        name: "balance",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "distribution_counter",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "current_distribution_amount",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "stake_subsidy_period_length",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 5,
        name: "stake_subsidy_decrease_rate",
        kind: "scalar",
        opt: true,
        T: 13
      },
      { no: 6, name: "extra_fields", kind: "message", T: () => MoveTable }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 balance */
        1:
          message.balance = reader.uint64().toBigInt();
          break;
        case /* optional uint64 distribution_counter */
        2:
          message.distributionCounter = reader.uint64().toBigInt();
          break;
        case /* optional uint64 current_distribution_amount */
        3:
          message.currentDistributionAmount = reader.uint64().toBigInt();
          break;
        case /* optional uint64 stake_subsidy_period_length */
        4:
          message.stakeSubsidyPeriodLength = reader.uint64().toBigInt();
          break;
        case /* optional uint32 stake_subsidy_decrease_rate */
        5:
          message.stakeSubsidyDecreaseRate = reader.uint32();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable extra_fields */
        6:
          message.extraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.extraFields
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance !== void 0) writer.tag(1, WireType.Varint).uint64(message.balance);
    if (message.distributionCounter !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.distributionCounter);
    if (message.currentDistributionAmount !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.currentDistributionAmount);
    if (message.stakeSubsidyPeriodLength !== void 0)
      writer.tag(4, WireType.Varint).uint64(message.stakeSubsidyPeriodLength);
    if (message.stakeSubsidyDecreaseRate !== void 0)
      writer.tag(5, WireType.Varint).uint32(message.stakeSubsidyDecreaseRate);
    if (message.extraFields)
      MoveTable.internalBinaryWrite(
        message.extraFields,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakeSubsidy = new StakeSubsidy$Type();
class StorageFund$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.StorageFund", [
      {
        no: 1,
        name: "total_object_storage_rebates",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "non_refundable_balance",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 total_object_storage_rebates */
        1:
          message.totalObjectStorageRebates = reader.uint64().toBigInt();
          break;
        case /* optional uint64 non_refundable_balance */
        2:
          message.nonRefundableBalance = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalObjectStorageRebates !== void 0)
      writer.tag(1, WireType.Varint).uint64(message.totalObjectStorageRebates);
    if (message.nonRefundableBalance !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.nonRefundableBalance);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StorageFund = new StorageFund$Type();
class ValidatorSet$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ValidatorSet", [
      {
        no: 1,
        name: "total_stake",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "active_validators",
        kind: "message",
        repeat: 2,
        T: () => Validator
      },
      { no: 3, name: "pending_active_validators", kind: "message", T: () => MoveTable },
      {
        no: 4,
        name: "pending_removals",
        kind: "scalar",
        repeat: 1,
        T: 4,
        L: 0
      },
      { no: 5, name: "staking_pool_mappings", kind: "message", T: () => MoveTable },
      { no: 6, name: "inactive_validators", kind: "message", T: () => MoveTable },
      { no: 7, name: "validator_candidates", kind: "message", T: () => MoveTable },
      {
        no: 8,
        name: "at_risk_validators",
        kind: "map",
        K: 9,
        V: {
          kind: "scalar",
          T: 4,
          L: 0
          /*LongType.BIGINT*/
        }
      },
      { no: 9, name: "extra_fields", kind: "message", T: () => MoveTable }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.activeValidators = [];
    message.pendingRemovals = [];
    message.atRiskValidators = {};
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 total_stake */
        1:
          message.totalStake = reader.uint64().toBigInt();
          break;
        case /* repeated sui.rpc.v2beta2.Validator active_validators */
        2:
          message.activeValidators.push(
            Validator.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional sui.rpc.v2beta2.MoveTable pending_active_validators */
        3:
          message.pendingActiveValidators = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pendingActiveValidators
          );
          break;
        case /* repeated uint64 pending_removals */
        4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.pendingRemovals.push(reader.uint64().toBigInt());
          else message.pendingRemovals.push(reader.uint64().toBigInt());
          break;
        case /* optional sui.rpc.v2beta2.MoveTable staking_pool_mappings */
        5:
          message.stakingPoolMappings = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.stakingPoolMappings
          );
          break;
        case /* optional sui.rpc.v2beta2.MoveTable inactive_validators */
        6:
          message.inactiveValidators = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.inactiveValidators
          );
          break;
        case /* optional sui.rpc.v2beta2.MoveTable validator_candidates */
        7:
          message.validatorCandidates = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.validatorCandidates
          );
          break;
        case /* map<string, uint64> at_risk_validators */
        8:
          this.binaryReadMap8(message.atRiskValidators, reader, options);
          break;
        case /* optional sui.rpc.v2beta2.MoveTable extra_fields */
        9:
          message.extraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.extraFields
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  binaryReadMap8(map, reader, options) {
    let len = reader.uint32(), end = reader.pos + len, key, val;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.uint64().toBigInt();
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for sui.rpc.v2beta2.ValidatorSet.at_risk_validators"
          );
      }
    }
    map[key ?? ""] = val ?? 0n;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.totalStake !== void 0) writer.tag(1, WireType.Varint).uint64(message.totalStake);
    for (let i = 0; i < message.activeValidators.length; i++)
      Validator.internalBinaryWrite(
        message.activeValidators[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.pendingActiveValidators)
      MoveTable.internalBinaryWrite(
        message.pendingActiveValidators,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.pendingRemovals.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.pendingRemovals.length; i++)
        writer.uint64(message.pendingRemovals[i]);
      writer.join();
    }
    if (message.stakingPoolMappings)
      MoveTable.internalBinaryWrite(
        message.stakingPoolMappings,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.inactiveValidators)
      MoveTable.internalBinaryWrite(
        message.inactiveValidators,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.validatorCandidates)
      MoveTable.internalBinaryWrite(
        message.validatorCandidates,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let k of globalThis.Object.keys(message.atRiskValidators))
      writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.atRiskValidators[k]).join();
    if (message.extraFields)
      MoveTable.internalBinaryWrite(
        message.extraFields,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorSet = new ValidatorSet$Type();
class Validator$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Validator", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "image_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "project_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "protocol_public_key",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 8,
        name: "proof_of_possession",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 10,
        name: "network_public_key",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 12,
        name: "worker_public_key",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 13,
        name: "network_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "p2p_address",
        kind: "scalar",
        jsonName: "p2pAddress",
        opt: true,
        T: 9
      },
      {
        no: 15,
        name: "primary_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "worker_address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 18,
        name: "next_epoch_protocol_public_key",
        kind: "scalar",
        opt: true,
        T: 12
      },
      {
        no: 19,
        name: "next_epoch_proof_of_possession",
        kind: "scalar",
        opt: true,
        T: 12
      },
      {
        no: 21,
        name: "next_epoch_network_public_key",
        kind: "scalar",
        opt: true,
        T: 12
      },
      {
        no: 23,
        name: "next_epoch_worker_public_key",
        kind: "scalar",
        opt: true,
        T: 12
      },
      {
        no: 24,
        name: "next_epoch_network_address",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 25,
        name: "next_epoch_p2p_address",
        kind: "scalar",
        jsonName: "nextEpochP2pAddress",
        opt: true,
        T: 9
      },
      {
        no: 26,
        name: "next_epoch_primary_address",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 27,
        name: "next_epoch_worker_address",
        kind: "scalar",
        opt: true,
        T: 9
      },
      { no: 28, name: "metadata_extra_fields", kind: "message", T: () => MoveTable },
      {
        no: 29,
        name: "voting_power",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 30,
        name: "operation_cap_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 31,
        name: "gas_price",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 32, name: "staking_pool", kind: "message", T: () => StakingPool },
      {
        no: 33,
        name: "commission_rate",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 34,
        name: "next_epoch_stake",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 35,
        name: "next_epoch_gas_price",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 36,
        name: "next_epoch_commission_rate",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 37, name: "extra_fields", kind: "message", T: () => MoveTable }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string name */
        1:
          message.name = reader.string();
          break;
        case /* optional string address */
        2:
          message.address = reader.string();
          break;
        case /* optional string description */
        3:
          message.description = reader.string();
          break;
        case /* optional string image_url */
        4:
          message.imageUrl = reader.string();
          break;
        case /* optional string project_url */
        5:
          message.projectUrl = reader.string();
          break;
        case /* optional bytes protocol_public_key */
        7:
          message.protocolPublicKey = reader.bytes();
          break;
        case /* optional bytes proof_of_possession */
        8:
          message.proofOfPossession = reader.bytes();
          break;
        case /* optional bytes network_public_key */
        10:
          message.networkPublicKey = reader.bytes();
          break;
        case /* optional bytes worker_public_key */
        12:
          message.workerPublicKey = reader.bytes();
          break;
        case /* optional string network_address */
        13:
          message.networkAddress = reader.string();
          break;
        case /* optional string p2p_address */
        14:
          message.p2PAddress = reader.string();
          break;
        case /* optional string primary_address */
        15:
          message.primaryAddress = reader.string();
          break;
        case /* optional string worker_address */
        16:
          message.workerAddress = reader.string();
          break;
        case /* optional bytes next_epoch_protocol_public_key */
        18:
          message.nextEpochProtocolPublicKey = reader.bytes();
          break;
        case /* optional bytes next_epoch_proof_of_possession */
        19:
          message.nextEpochProofOfPossession = reader.bytes();
          break;
        case /* optional bytes next_epoch_network_public_key */
        21:
          message.nextEpochNetworkPublicKey = reader.bytes();
          break;
        case /* optional bytes next_epoch_worker_public_key */
        23:
          message.nextEpochWorkerPublicKey = reader.bytes();
          break;
        case /* optional string next_epoch_network_address */
        24:
          message.nextEpochNetworkAddress = reader.string();
          break;
        case /* optional string next_epoch_p2p_address */
        25:
          message.nextEpochP2PAddress = reader.string();
          break;
        case /* optional string next_epoch_primary_address */
        26:
          message.nextEpochPrimaryAddress = reader.string();
          break;
        case /* optional string next_epoch_worker_address */
        27:
          message.nextEpochWorkerAddress = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable metadata_extra_fields */
        28:
          message.metadataExtraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadataExtraFields
          );
          break;
        case /* optional uint64 voting_power */
        29:
          message.votingPower = reader.uint64().toBigInt();
          break;
        case /* optional string operation_cap_id */
        30:
          message.operationCapId = reader.string();
          break;
        case /* optional uint64 gas_price */
        31:
          message.gasPrice = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.StakingPool staking_pool */
        32:
          message.stakingPool = StakingPool.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.stakingPool
          );
          break;
        case /* optional uint64 commission_rate */
        33:
          message.commissionRate = reader.uint64().toBigInt();
          break;
        case /* optional uint64 next_epoch_stake */
        34:
          message.nextEpochStake = reader.uint64().toBigInt();
          break;
        case /* optional uint64 next_epoch_gas_price */
        35:
          message.nextEpochGasPrice = reader.uint64().toBigInt();
          break;
        case /* optional uint64 next_epoch_commission_rate */
        36:
          message.nextEpochCommissionRate = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable extra_fields */
        37:
          message.extraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.extraFields
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.address !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.description !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    if (message.imageUrl !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.imageUrl);
    if (message.projectUrl !== void 0)
      writer.tag(5, WireType.LengthDelimited).string(message.projectUrl);
    if (message.protocolPublicKey !== void 0)
      writer.tag(7, WireType.LengthDelimited).bytes(message.protocolPublicKey);
    if (message.proofOfPossession !== void 0)
      writer.tag(8, WireType.LengthDelimited).bytes(message.proofOfPossession);
    if (message.networkPublicKey !== void 0)
      writer.tag(10, WireType.LengthDelimited).bytes(message.networkPublicKey);
    if (message.workerPublicKey !== void 0)
      writer.tag(12, WireType.LengthDelimited).bytes(message.workerPublicKey);
    if (message.networkAddress !== void 0)
      writer.tag(13, WireType.LengthDelimited).string(message.networkAddress);
    if (message.p2PAddress !== void 0)
      writer.tag(14, WireType.LengthDelimited).string(message.p2PAddress);
    if (message.primaryAddress !== void 0)
      writer.tag(15, WireType.LengthDelimited).string(message.primaryAddress);
    if (message.workerAddress !== void 0)
      writer.tag(16, WireType.LengthDelimited).string(message.workerAddress);
    if (message.nextEpochProtocolPublicKey !== void 0)
      writer.tag(18, WireType.LengthDelimited).bytes(message.nextEpochProtocolPublicKey);
    if (message.nextEpochProofOfPossession !== void 0)
      writer.tag(19, WireType.LengthDelimited).bytes(message.nextEpochProofOfPossession);
    if (message.nextEpochNetworkPublicKey !== void 0)
      writer.tag(21, WireType.LengthDelimited).bytes(message.nextEpochNetworkPublicKey);
    if (message.nextEpochWorkerPublicKey !== void 0)
      writer.tag(23, WireType.LengthDelimited).bytes(message.nextEpochWorkerPublicKey);
    if (message.nextEpochNetworkAddress !== void 0)
      writer.tag(24, WireType.LengthDelimited).string(message.nextEpochNetworkAddress);
    if (message.nextEpochP2PAddress !== void 0)
      writer.tag(25, WireType.LengthDelimited).string(message.nextEpochP2PAddress);
    if (message.nextEpochPrimaryAddress !== void 0)
      writer.tag(26, WireType.LengthDelimited).string(message.nextEpochPrimaryAddress);
    if (message.nextEpochWorkerAddress !== void 0)
      writer.tag(27, WireType.LengthDelimited).string(message.nextEpochWorkerAddress);
    if (message.metadataExtraFields)
      MoveTable.internalBinaryWrite(
        message.metadataExtraFields,
        writer.tag(28, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.votingPower !== void 0)
      writer.tag(29, WireType.Varint).uint64(message.votingPower);
    if (message.operationCapId !== void 0)
      writer.tag(30, WireType.LengthDelimited).string(message.operationCapId);
    if (message.gasPrice !== void 0) writer.tag(31, WireType.Varint).uint64(message.gasPrice);
    if (message.stakingPool)
      StakingPool.internalBinaryWrite(
        message.stakingPool,
        writer.tag(32, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.commissionRate !== void 0)
      writer.tag(33, WireType.Varint).uint64(message.commissionRate);
    if (message.nextEpochStake !== void 0)
      writer.tag(34, WireType.Varint).uint64(message.nextEpochStake);
    if (message.nextEpochGasPrice !== void 0)
      writer.tag(35, WireType.Varint).uint64(message.nextEpochGasPrice);
    if (message.nextEpochCommissionRate !== void 0)
      writer.tag(36, WireType.Varint).uint64(message.nextEpochCommissionRate);
    if (message.extraFields)
      MoveTable.internalBinaryWrite(
        message.extraFields,
        writer.tag(37, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Validator = new Validator$Type();
class StakingPool$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.StakingPool", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "activation_epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "deactivation_epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "sui_balance",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 5,
        name: "rewards_pool",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 6,
        name: "pool_token_balance",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 7, name: "exchange_rates", kind: "message", T: () => MoveTable },
      {
        no: 8,
        name: "pending_stake",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 9,
        name: "pending_total_sui_withdraw",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 10,
        name: "pending_pool_token_withdraw",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 11, name: "extra_fields", kind: "message", T: () => MoveTable }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string id */
        1:
          message.id = reader.string();
          break;
        case /* optional uint64 activation_epoch */
        2:
          message.activationEpoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 deactivation_epoch */
        3:
          message.deactivationEpoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 sui_balance */
        4:
          message.suiBalance = reader.uint64().toBigInt();
          break;
        case /* optional uint64 rewards_pool */
        5:
          message.rewardsPool = reader.uint64().toBigInt();
          break;
        case /* optional uint64 pool_token_balance */
        6:
          message.poolTokenBalance = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable exchange_rates */
        7:
          message.exchangeRates = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.exchangeRates
          );
          break;
        case /* optional uint64 pending_stake */
        8:
          message.pendingStake = reader.uint64().toBigInt();
          break;
        case /* optional uint64 pending_total_sui_withdraw */
        9:
          message.pendingTotalSuiWithdraw = reader.uint64().toBigInt();
          break;
        case /* optional uint64 pending_pool_token_withdraw */
        10:
          message.pendingPoolTokenWithdraw = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.MoveTable extra_fields */
        11:
          message.extraFields = MoveTable.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.extraFields
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== void 0) writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.activationEpoch !== void 0)
      writer.tag(2, WireType.Varint).uint64(message.activationEpoch);
    if (message.deactivationEpoch !== void 0)
      writer.tag(3, WireType.Varint).uint64(message.deactivationEpoch);
    if (message.suiBalance !== void 0) writer.tag(4, WireType.Varint).uint64(message.suiBalance);
    if (message.rewardsPool !== void 0)
      writer.tag(5, WireType.Varint).uint64(message.rewardsPool);
    if (message.poolTokenBalance !== void 0)
      writer.tag(6, WireType.Varint).uint64(message.poolTokenBalance);
    if (message.exchangeRates)
      MoveTable.internalBinaryWrite(
        message.exchangeRates,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.pendingStake !== void 0)
      writer.tag(8, WireType.Varint).uint64(message.pendingStake);
    if (message.pendingTotalSuiWithdraw !== void 0)
      writer.tag(9, WireType.Varint).uint64(message.pendingTotalSuiWithdraw);
    if (message.pendingPoolTokenWithdraw !== void 0)
      writer.tag(10, WireType.Varint).uint64(message.pendingPoolTokenWithdraw);
    if (message.extraFields)
      MoveTable.internalBinaryWrite(
        message.extraFields,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StakingPool = new StakingPool$Type();
export {
  MoveTable,
  StakeSubsidy,
  StakingPool,
  StorageFund,
  SystemParameters,
  SystemState,
  Validator,
  ValidatorReportRecord,
  ValidatorSet
};
//# sourceMappingURL=system_state.js.map
