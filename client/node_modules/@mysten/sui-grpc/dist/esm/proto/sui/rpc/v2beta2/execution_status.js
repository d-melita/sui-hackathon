import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
var ExecutionError_ExecutionErrorKind = /* @__PURE__ */ ((ExecutionError_ExecutionErrorKind2) => {
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["EXECUTION_ERROR_KIND_UNKNOWN"] = 0] = "EXECUTION_ERROR_KIND_UNKNOWN";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INSUFFICIENT_GAS"] = 1] = "INSUFFICIENT_GAS";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INVALID_GAS_OBJECT"] = 2] = "INVALID_GAS_OBJECT";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INVARIANT_VIOLATION"] = 3] = "INVARIANT_VIOLATION";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["FEATURE_NOT_YET_SUPPORTED"] = 4] = "FEATURE_NOT_YET_SUPPORTED";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["OBJECT_TOO_BIG"] = 5] = "OBJECT_TOO_BIG";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["PACKAGE_TOO_BIG"] = 6] = "PACKAGE_TOO_BIG";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["CIRCULAR_OBJECT_OWNERSHIP"] = 7] = "CIRCULAR_OBJECT_OWNERSHIP";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INSUFFICIENT_COIN_BALANCE"] = 8] = "INSUFFICIENT_COIN_BALANCE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["COIN_BALANCE_OVERFLOW"] = 9] = "COIN_BALANCE_OVERFLOW";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["PUBLISH_ERROR_NON_ZERO_ADDRESS"] = 10] = "PUBLISH_ERROR_NON_ZERO_ADDRESS";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["SUI_MOVE_VERIFICATION_ERROR"] = 11] = "SUI_MOVE_VERIFICATION_ERROR";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["MOVE_PRIMITIVE_RUNTIME_ERROR"] = 12] = "MOVE_PRIMITIVE_RUNTIME_ERROR";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["MOVE_ABORT"] = 13] = "MOVE_ABORT";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["VM_VERIFICATION_OR_DESERIALIZATION_ERROR"] = 14] = "VM_VERIFICATION_OR_DESERIALIZATION_ERROR";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["VM_INVARIANT_VIOLATION"] = 15] = "VM_INVARIANT_VIOLATION";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["FUNCTION_NOT_FOUND"] = 16] = "FUNCTION_NOT_FOUND";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["ARITY_MISMATCH"] = 17] = "ARITY_MISMATCH";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["TYPE_ARITY_MISMATCH"] = 18] = "TYPE_ARITY_MISMATCH";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["NON_ENTRY_FUNCTION_INVOKED"] = 19] = "NON_ENTRY_FUNCTION_INVOKED";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["COMMAND_ARGUMENT_ERROR"] = 20] = "COMMAND_ARGUMENT_ERROR";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["TYPE_ARGUMENT_ERROR"] = 21] = "TYPE_ARGUMENT_ERROR";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["UNUSED_VALUE_WITHOUT_DROP"] = 22] = "UNUSED_VALUE_WITHOUT_DROP";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INVALID_PUBLIC_FUNCTION_RETURN_TYPE"] = 23] = "INVALID_PUBLIC_FUNCTION_RETURN_TYPE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INVALID_TRANSFER_OBJECT"] = 24] = "INVALID_TRANSFER_OBJECT";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["EFFECTS_TOO_LARGE"] = 25] = "EFFECTS_TOO_LARGE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["PUBLISH_UPGRADE_MISSING_DEPENDENCY"] = 26] = "PUBLISH_UPGRADE_MISSING_DEPENDENCY";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE"] = 27] = "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["PACKAGE_UPGRADE_ERROR"] = 28] = "PACKAGE_UPGRADE_ERROR";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["WRITTEN_OBJECTS_TOO_LARGE"] = 29] = "WRITTEN_OBJECTS_TOO_LARGE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["CERTIFICATE_DENIED"] = 30] = "CERTIFICATE_DENIED";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["SUI_MOVE_VERIFICATION_TIMEDOUT"] = 31] = "SUI_MOVE_VERIFICATION_TIMEDOUT";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["SHARED_OBJECT_OPERATION_NOT_ALLOWED"] = 32] = "SHARED_OBJECT_OPERATION_NOT_ALLOWED";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INPUT_OBJECT_DELETED"] = 33] = "INPUT_OBJECT_DELETED";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION"] = 34] = "EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["ADDRESS_DENIED_FOR_COIN"] = 35] = "ADDRESS_DENIED_FOR_COIN";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["COIN_TYPE_GLOBAL_PAUSE"] = 36] = "COIN_TYPE_GLOBAL_PAUSE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE"] = 37] = "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["MOVE_VECTOR_ELEM_TOO_BIG"] = 38] = "MOVE_VECTOR_ELEM_TOO_BIG";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["MOVE_RAW_VALUE_TOO_BIG"] = 39] = "MOVE_RAW_VALUE_TOO_BIG";
  ExecutionError_ExecutionErrorKind2[ExecutionError_ExecutionErrorKind2["INVALID_LINKAGE"] = 40] = "INVALID_LINKAGE";
  return ExecutionError_ExecutionErrorKind2;
})(ExecutionError_ExecutionErrorKind || {});
var CommandArgumentError_CommandArgumentErrorKind = /* @__PURE__ */ ((CommandArgumentError_CommandArgumentErrorKind2) => {
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN"] = 0] = "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["TYPE_MISMATCH"] = 1] = "TYPE_MISMATCH";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_BCS_BYTES"] = 2] = "INVALID_BCS_BYTES";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_USAGE_OF_PURE_ARGUMENT"] = 3] = "INVALID_USAGE_OF_PURE_ARGUMENT";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION"] = 4] = "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INDEX_OUT_OF_BOUNDS"] = 5] = "INDEX_OUT_OF_BOUNDS";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["SECONDARY_INDEX_OUT_OF_BOUNDS"] = 6] = "SECONDARY_INDEX_OUT_OF_BOUNDS";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_RESULT_ARITY"] = 7] = "INVALID_RESULT_ARITY";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_GAS_COIN_USAGE"] = 8] = "INVALID_GAS_COIN_USAGE";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_VALUE_USAGE"] = 9] = "INVALID_VALUE_USAGE";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_OBJECT_BY_VALUE"] = 10] = "INVALID_OBJECT_BY_VALUE";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_OBJECT_BY_MUT_REF"] = 11] = "INVALID_OBJECT_BY_MUT_REF";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["SHARED_OBJECT_OPERATION_NOT_ALLOWED"] = 12] = "SHARED_OBJECT_OPERATION_NOT_ALLOWED";
  CommandArgumentError_CommandArgumentErrorKind2[CommandArgumentError_CommandArgumentErrorKind2["INVALID_ARGUMENT_ARITY"] = 13] = "INVALID_ARGUMENT_ARITY";
  return CommandArgumentError_CommandArgumentErrorKind2;
})(CommandArgumentError_CommandArgumentErrorKind || {});
var PackageUpgradeError_PackageUpgradeErrorKind = /* @__PURE__ */ ((PackageUpgradeError_PackageUpgradeErrorKind2) => {
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN"] = 0] = "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN";
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["UNABLE_TO_FETCH_PACKAGE"] = 1] = "UNABLE_TO_FETCH_PACKAGE";
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["NOT_A_PACKAGE"] = 2] = "NOT_A_PACKAGE";
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["INCOMPATIBLE_UPGRADE"] = 3] = "INCOMPATIBLE_UPGRADE";
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["DIGEST_DOES_NOT_MATCH"] = 4] = "DIGEST_DOES_NOT_MATCH";
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["UNKNOWN_UPGRADE_POLICY"] = 5] = "UNKNOWN_UPGRADE_POLICY";
  PackageUpgradeError_PackageUpgradeErrorKind2[PackageUpgradeError_PackageUpgradeErrorKind2["PACKAGE_ID_DOES_NOT_MATCH"] = 6] = "PACKAGE_ID_DOES_NOT_MATCH";
  return PackageUpgradeError_PackageUpgradeErrorKind2;
})(PackageUpgradeError_PackageUpgradeErrorKind || {});
var TypeArgumentError_TypeArgumentErrorKind = /* @__PURE__ */ ((TypeArgumentError_TypeArgumentErrorKind2) => {
  TypeArgumentError_TypeArgumentErrorKind2[TypeArgumentError_TypeArgumentErrorKind2["TYPE_ARGUMENT_ERROR_KIND_UNKNOWN"] = 0] = "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN";
  TypeArgumentError_TypeArgumentErrorKind2[TypeArgumentError_TypeArgumentErrorKind2["TYPE_NOT_FOUND"] = 1] = "TYPE_NOT_FOUND";
  TypeArgumentError_TypeArgumentErrorKind2[TypeArgumentError_TypeArgumentErrorKind2["CONSTRAINT_NOT_SATISFIED"] = 2] = "CONSTRAINT_NOT_SATISFIED";
  return TypeArgumentError_TypeArgumentErrorKind2;
})(TypeArgumentError_TypeArgumentErrorKind || {});
class ExecutionStatus$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ExecutionStatus", [
      {
        no: 1,
        name: "success",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "error", kind: "message", T: () => ExecutionError }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bool success */
        1:
          message.success = reader.bool();
          break;
        case /* optional sui.rpc.v2beta2.ExecutionError error */
        2:
          message.error = ExecutionError.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.error
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.success !== void 0) writer.tag(1, WireType.Varint).bool(message.success);
    if (message.error)
      ExecutionError.internalBinaryWrite(
        message.error,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionStatus = new ExecutionStatus$Type();
class ExecutionError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ExecutionError", [
      {
        no: 1,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "command",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.ExecutionError.ExecutionErrorKind",
          ExecutionError_ExecutionErrorKind
        ]
      },
      { no: 4, name: "abort", kind: "message", oneof: "errorDetails", T: () => MoveAbort },
      { no: 5, name: "size_error", kind: "message", oneof: "errorDetails", T: () => SizeError },
      {
        no: 6,
        name: "command_argument_error",
        kind: "message",
        oneof: "errorDetails",
        T: () => CommandArgumentError
      },
      {
        no: 7,
        name: "type_argument_error",
        kind: "message",
        oneof: "errorDetails",
        T: () => TypeArgumentError
      },
      {
        no: 8,
        name: "package_upgrade_error",
        kind: "message",
        oneof: "errorDetails",
        T: () => PackageUpgradeError
      },
      { no: 9, name: "index_error", kind: "message", oneof: "errorDetails", T: () => IndexError },
      {
        no: 10,
        name: "object_id",
        kind: "scalar",
        oneof: "errorDetails",
        T: 9
      },
      {
        no: 11,
        name: "coin_deny_list_error",
        kind: "message",
        oneof: "errorDetails",
        T: () => CoinDenyListError
      },
      {
        no: 12,
        name: "congested_objects",
        kind: "message",
        oneof: "errorDetails",
        T: () => CongestedObjects
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.errorDetails = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string description */
        1:
          message.description = reader.string();
          break;
        case /* optional uint64 command */
        2:
          message.command = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.ExecutionError.ExecutionErrorKind kind */
        3:
          message.kind = reader.int32();
          break;
        case /* sui.rpc.v2beta2.MoveAbort abort */
        4:
          message.errorDetails = {
            oneofKind: "abort",
            abort: MoveAbort.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.abort
            )
          };
          break;
        case /* sui.rpc.v2beta2.SizeError size_error */
        5:
          message.errorDetails = {
            oneofKind: "sizeError",
            sizeError: SizeError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.sizeError
            )
          };
          break;
        case /* sui.rpc.v2beta2.CommandArgumentError command_argument_error */
        6:
          message.errorDetails = {
            oneofKind: "commandArgumentError",
            commandArgumentError: CommandArgumentError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.commandArgumentError
            )
          };
          break;
        case /* sui.rpc.v2beta2.TypeArgumentError type_argument_error */
        7:
          message.errorDetails = {
            oneofKind: "typeArgumentError",
            typeArgumentError: TypeArgumentError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.typeArgumentError
            )
          };
          break;
        case /* sui.rpc.v2beta2.PackageUpgradeError package_upgrade_error */
        8:
          message.errorDetails = {
            oneofKind: "packageUpgradeError",
            packageUpgradeError: PackageUpgradeError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.packageUpgradeError
            )
          };
          break;
        case /* sui.rpc.v2beta2.IndexError index_error */
        9:
          message.errorDetails = {
            oneofKind: "indexError",
            indexError: IndexError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.indexError
            )
          };
          break;
        case /* string object_id */
        10:
          message.errorDetails = {
            oneofKind: "objectId",
            objectId: reader.string()
          };
          break;
        case /* sui.rpc.v2beta2.CoinDenyListError coin_deny_list_error */
        11:
          message.errorDetails = {
            oneofKind: "coinDenyListError",
            coinDenyListError: CoinDenyListError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.coinDenyListError
            )
          };
          break;
        case /* sui.rpc.v2beta2.CongestedObjects congested_objects */
        12:
          message.errorDetails = {
            oneofKind: "congestedObjects",
            congestedObjects: CongestedObjects.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.errorDetails.congestedObjects
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.description !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.description);
    if (message.command !== void 0) writer.tag(2, WireType.Varint).uint64(message.command);
    if (message.kind !== void 0) writer.tag(3, WireType.Varint).int32(message.kind);
    if (message.errorDetails.oneofKind === "abort")
      MoveAbort.internalBinaryWrite(
        message.errorDetails.abort,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "sizeError")
      SizeError.internalBinaryWrite(
        message.errorDetails.sizeError,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "commandArgumentError")
      CommandArgumentError.internalBinaryWrite(
        message.errorDetails.commandArgumentError,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "typeArgumentError")
      TypeArgumentError.internalBinaryWrite(
        message.errorDetails.typeArgumentError,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "packageUpgradeError")
      PackageUpgradeError.internalBinaryWrite(
        message.errorDetails.packageUpgradeError,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "indexError")
      IndexError.internalBinaryWrite(
        message.errorDetails.indexError,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "objectId")
      writer.tag(10, WireType.LengthDelimited).string(message.errorDetails.objectId);
    if (message.errorDetails.oneofKind === "coinDenyListError")
      CoinDenyListError.internalBinaryWrite(
        message.errorDetails.coinDenyListError,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.errorDetails.oneofKind === "congestedObjects")
      CongestedObjects.internalBinaryWrite(
        message.errorDetails.congestedObjects,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ExecutionError = new ExecutionError$Type();
class MoveAbort$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MoveAbort", [
      {
        no: 1,
        name: "abort_code",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 2, name: "location", kind: "message", T: () => MoveLocation },
      { no: 3, name: "clever_error", kind: "message", T: () => CleverError }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 abort_code */
        1:
          message.abortCode = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.MoveLocation location */
        2:
          message.location = MoveLocation.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.location
          );
          break;
        case /* optional sui.rpc.v2beta2.CleverError clever_error */
        3:
          message.cleverError = CleverError.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cleverError
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.abortCode !== void 0) writer.tag(1, WireType.Varint).uint64(message.abortCode);
    if (message.location)
      MoveLocation.internalBinaryWrite(
        message.location,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.cleverError)
      CleverError.internalBinaryWrite(
        message.cleverError,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MoveAbort = new MoveAbort$Type();
class MoveLocation$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MoveLocation", [
      {
        no: 1,
        name: "package",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "module",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "function",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 4,
        name: "instruction",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "function_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string package */
        1:
          message.package = reader.string();
          break;
        case /* optional string module */
        2:
          message.module = reader.string();
          break;
        case /* optional uint32 function */
        3:
          message.function = reader.uint32();
          break;
        case /* optional uint32 instruction */
        4:
          message.instruction = reader.uint32();
          break;
        case /* optional string function_name */
        5:
          message.functionName = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.package !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.package);
    if (message.module !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.module);
    if (message.function !== void 0) writer.tag(3, WireType.Varint).uint32(message.function);
    if (message.instruction !== void 0)
      writer.tag(4, WireType.Varint).uint32(message.instruction);
    if (message.functionName !== void 0)
      writer.tag(5, WireType.LengthDelimited).string(message.functionName);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MoveLocation = new MoveLocation$Type();
class CleverError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CleverError", [
      {
        no: 1,
        name: "error_code",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "line_number",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "constant_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "constant_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "rendered",
        kind: "scalar",
        oneof: "value",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "raw",
        kind: "scalar",
        oneof: "value",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.value = { oneofKind: void 0 };
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 error_code */
        1:
          message.errorCode = reader.uint64().toBigInt();
          break;
        case /* optional uint64 line_number */
        2:
          message.lineNumber = reader.uint64().toBigInt();
          break;
        case /* optional string constant_name */
        3:
          message.constantName = reader.string();
          break;
        case /* optional string constant_type */
        4:
          message.constantType = reader.string();
          break;
        case /* string rendered */
        5:
          message.value = {
            oneofKind: "rendered",
            rendered: reader.string()
          };
          break;
        case /* bytes raw */
        6:
          message.value = {
            oneofKind: "raw",
            raw: reader.bytes()
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.errorCode !== void 0) writer.tag(1, WireType.Varint).uint64(message.errorCode);
    if (message.lineNumber !== void 0) writer.tag(2, WireType.Varint).uint64(message.lineNumber);
    if (message.constantName !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.constantName);
    if (message.constantType !== void 0)
      writer.tag(4, WireType.LengthDelimited).string(message.constantType);
    if (message.value.oneofKind === "rendered")
      writer.tag(5, WireType.LengthDelimited).string(message.value.rendered);
    if (message.value.oneofKind === "raw")
      writer.tag(6, WireType.LengthDelimited).bytes(message.value.raw);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CleverError = new CleverError$Type();
class SizeError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SizeError", [
      {
        no: 1,
        name: "size",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "max_size",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 size */
        1:
          message.size = reader.uint64().toBigInt();
          break;
        case /* optional uint64 max_size */
        2:
          message.maxSize = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.size !== void 0) writer.tag(1, WireType.Varint).uint64(message.size);
    if (message.maxSize !== void 0) writer.tag(2, WireType.Varint).uint64(message.maxSize);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SizeError = new SizeError$Type();
class IndexError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.IndexError", [
      {
        no: 1,
        name: "index",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "subresult",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 index */
        1:
          message.index = reader.uint32();
          break;
        case /* optional uint32 subresult */
        2:
          message.subresult = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.index !== void 0) writer.tag(1, WireType.Varint).uint32(message.index);
    if (message.subresult !== void 0) writer.tag(2, WireType.Varint).uint32(message.subresult);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const IndexError = new IndexError$Type();
class CoinDenyListError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CoinDenyListError", [
      {
        no: 1,
        name: "address",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "coin_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string address */
        1:
          message.address = reader.string();
          break;
        case /* optional string coin_type */
        2:
          message.coinType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.address !== void 0)
      writer.tag(1, WireType.LengthDelimited).string(message.address);
    if (message.coinType !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.coinType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CoinDenyListError = new CoinDenyListError$Type();
class CongestedObjects$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CongestedObjects", [
      {
        no: 1,
        name: "objects",
        kind: "scalar",
        repeat: 2,
        T: 9
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string objects */
        1:
          message.objects.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.objects[i]);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CongestedObjects = new CongestedObjects$Type();
class CommandArgumentError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CommandArgumentError", [
      {
        no: 1,
        name: "argument",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.CommandArgumentError.CommandArgumentErrorKind",
          CommandArgumentError_CommandArgumentErrorKind
        ]
      },
      { no: 3, name: "index_error", kind: "message", T: () => IndexError }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 argument */
        1:
          message.argument = reader.uint32();
          break;
        case /* optional sui.rpc.v2beta2.CommandArgumentError.CommandArgumentErrorKind kind */
        2:
          message.kind = reader.int32();
          break;
        case /* optional sui.rpc.v2beta2.IndexError index_error */
        3:
          message.indexError = IndexError.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.indexError
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.argument !== void 0) writer.tag(1, WireType.Varint).uint32(message.argument);
    if (message.kind !== void 0) writer.tag(2, WireType.Varint).int32(message.kind);
    if (message.indexError)
      IndexError.internalBinaryWrite(
        message.indexError,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommandArgumentError = new CommandArgumentError$Type();
class PackageUpgradeError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.PackageUpgradeError", [
      {
        no: 1,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.PackageUpgradeError.PackageUpgradeErrorKind",
          PackageUpgradeError_PackageUpgradeErrorKind
        ]
      },
      {
        no: 2,
        name: "package_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "digest",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "policy",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "ticket_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.PackageUpgradeError.PackageUpgradeErrorKind kind */
        1:
          message.kind = reader.int32();
          break;
        case /* optional string package_id */
        2:
          message.packageId = reader.string();
          break;
        case /* optional string digest */
        3:
          message.digest = reader.string();
          break;
        case /* optional uint32 policy */
        4:
          message.policy = reader.uint32();
          break;
        case /* optional string ticket_id */
        5:
          message.ticketId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind !== void 0) writer.tag(1, WireType.Varint).int32(message.kind);
    if (message.packageId !== void 0)
      writer.tag(2, WireType.LengthDelimited).string(message.packageId);
    if (message.digest !== void 0)
      writer.tag(3, WireType.LengthDelimited).string(message.digest);
    if (message.policy !== void 0) writer.tag(4, WireType.Varint).uint32(message.policy);
    if (message.ticketId !== void 0)
      writer.tag(5, WireType.LengthDelimited).string(message.ticketId);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PackageUpgradeError = new PackageUpgradeError$Type();
class TypeArgumentError$Type extends MessageType {
  constructor() {
    super("sui.rpc.v2beta2.TypeArgumentError", [
      {
        no: 1,
        name: "type_argument",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.TypeArgumentError.TypeArgumentErrorKind",
          TypeArgumentError_TypeArgumentErrorKind
        ]
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint32 type_argument */
        1:
          message.typeArgument = reader.uint32();
          break;
        case /* optional sui.rpc.v2beta2.TypeArgumentError.TypeArgumentErrorKind kind */
        2:
          message.kind = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.typeArgument !== void 0)
      writer.tag(1, WireType.Varint).uint32(message.typeArgument);
    if (message.kind !== void 0) writer.tag(2, WireType.Varint).int32(message.kind);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TypeArgumentError = new TypeArgumentError$Type();
export {
  CleverError,
  CoinDenyListError,
  CommandArgumentError,
  CommandArgumentError_CommandArgumentErrorKind,
  CongestedObjects,
  ExecutionError,
  ExecutionError_ExecutionErrorKind,
  ExecutionStatus,
  IndexError,
  MoveAbort,
  MoveLocation,
  PackageUpgradeError,
  PackageUpgradeError_PackageUpgradeErrorKind,
  SizeError,
  TypeArgumentError,
  TypeArgumentError_TypeArgumentErrorKind
};
//# sourceMappingURL=execution_status.js.map
