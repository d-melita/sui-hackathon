{
  "version": 3,
  "sources": ["../../../../../src/proto/google/protobuf/field_mask.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BinaryWriteOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryWriter } from '@protobuf-ts/runtime';\nimport { WireType } from '@protobuf-ts/runtime';\nimport type { BinaryReadOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryReader } from '@protobuf-ts/runtime';\nimport { UnknownFieldHandler } from '@protobuf-ts/runtime';\nimport type { PartialMessage } from '@protobuf-ts/runtime';\nimport { reflectionMergePartial } from '@protobuf-ts/runtime';\nimport { typeofJsonValue } from '@protobuf-ts/runtime';\nimport type { JsonValue } from '@protobuf-ts/runtime';\nimport { lowerCamelCase } from '@protobuf-ts/runtime';\nimport type { JsonReadOptions } from '@protobuf-ts/runtime';\nimport type { JsonWriteOptions } from '@protobuf-ts/runtime';\nimport { MessageType } from '@protobuf-ts/runtime';\n/**\n * `FieldMask` represents a set of symbolic field paths, for example:\n *\n *     paths: \"f.a\"\n *     paths: \"f.b.d\"\n *\n * Here `f` represents a field in some root message, `a` and `b`\n * fields in the message found in `f`, and `d` a field found in the\n * message in `f.b`.\n *\n * Field masks are used to specify a subset of fields that should be\n * returned by a get operation or modified by an update operation.\n * Field masks also have a custom JSON encoding (see below).\n *\n * # Field Masks in Projections\n *\n * When used in the context of a projection, a response message or\n * sub-message is filtered by the API to only contain those fields as\n * specified in the mask. For example, if the mask in the previous\n * example is applied to a response message as follows:\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *         x : 2\n *       }\n *       y : 13\n *     }\n *     z: 8\n *\n * The result will not contain specific values for fields x,y and z\n * (their value will be set to the default, and omitted in proto text\n * output):\n *\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *       }\n *     }\n *\n * A repeated field is not allowed except at the last position of a\n * paths string.\n *\n * If a FieldMask object is not present in a get operation, the\n * operation applies to all fields (as if a FieldMask of all fields\n * had been specified).\n *\n * Note that a field mask does not necessarily apply to the\n * top-level response message. In case of a REST get operation, the\n * field mask applies directly to the response, but in case of a REST\n * list operation, the mask instead applies to each individual message\n * in the returned resource list. In case of a REST custom method,\n * other definitions may be used. Where the mask applies will be\n * clearly documented together with its declaration in the API.  In\n * any case, the effect on the returned resource/resources is required\n * behavior for APIs.\n *\n * # Field Masks in Update Operations\n *\n * A field mask in update operations specifies which fields of the\n * targeted resource are going to be updated. The API is required\n * to only change the values of the fields as specified in the mask\n * and leave the others untouched. If a resource is passed in to\n * describe the updated values, the API ignores the values of all\n * fields not covered by the mask.\n *\n * If a repeated field is specified for an update operation, new values will\n * be appended to the existing repeated field in the target resource. Note that\n * a repeated field is only allowed in the last position of a `paths` string.\n *\n * If a sub-message is specified in the last position of the field mask for an\n * update operation, then new value will be merged into the existing sub-message\n * in the target resource.\n *\n * For example, given the target message:\n *\n *     f {\n *       b {\n *         d: 1\n *         x: 2\n *       }\n *       c: [1]\n *     }\n *\n * And an update message:\n *\n *     f {\n *       b {\n *         d: 10\n *       }\n *       c: [2]\n *     }\n *\n * then if the field mask is:\n *\n *  paths: [\"f.b\", \"f.c\"]\n *\n * then the result will be:\n *\n *     f {\n *       b {\n *         d: 10\n *         x: 2\n *       }\n *       c: [1, 2]\n *     }\n *\n * An implementation may provide options to override this default behavior for\n * repeated and message fields.\n *\n * In order to reset a field's value to the default, the field must\n * be in the mask and set to the default value in the provided resource.\n * Hence, in order to reset all fields of a resource, provide a default\n * instance of the resource and set all fields in the mask, or do\n * not provide a mask as described below.\n *\n * If a field mask is not present on update, the operation applies to\n * all fields (as if a field mask of all fields has been specified).\n * Note that in the presence of schema evolution, this may mean that\n * fields the client does not know and has therefore not filled into\n * the request will be reset to their default. If this is unwanted\n * behavior, a specific service may require a client to always specify\n * a field mask, producing an error if not.\n *\n * As with get operations, the location of the resource which\n * describes the updated values in the request message depends on the\n * operation kind. In any case, the effect of the field mask is\n * required to be honored by the API.\n *\n * ## Considerations for HTTP REST\n *\n * The HTTP kind of an update operation which uses a field mask must\n * be set to PATCH instead of PUT in order to satisfy HTTP semantics\n * (PUT must only be used for full updates).\n *\n * # JSON Encoding of Field Masks\n *\n * In JSON, a field mask is encoded as a single string where paths are\n * separated by a comma. Fields name in each path are converted\n * to/from lower-camel naming conventions.\n *\n * As an example, consider the following message declarations:\n *\n *     message Profile {\n *       User user = 1;\n *       Photo photo = 2;\n *     }\n *     message User {\n *       string display_name = 1;\n *       string address = 2;\n *     }\n *\n * In proto a field mask for `Profile` may look as such:\n *\n *     mask {\n *       paths: \"user.display_name\"\n *       paths: \"photo\"\n *     }\n *\n * In JSON, the same mask is represented as below:\n *\n *     {\n *       mask: \"user.displayName,photo\"\n *     }\n *\n * # Field Masks and Oneof Fields\n *\n * Field masks treat fields in oneofs just as regular fields. Consider the\n * following message:\n *\n *     message SampleMessage {\n *       oneof test_oneof {\n *         string name = 4;\n *         SubMessage sub_message = 9;\n *       }\n *     }\n *\n * The field mask can be:\n *\n *     mask {\n *       paths: \"name\"\n *     }\n *\n * Or:\n *\n *     mask {\n *       paths: \"sub_message\"\n *     }\n *\n * Note that oneof type names (\"test_oneof\" in this case) cannot be used in\n * paths.\n *\n * ## Field Mask Verification\n *\n * The implementation of any API method which has a FieldMask type field in the\n * request should verify the included field paths, and return an\n * `INVALID_ARGUMENT` error if any path is unmappable.\n *\n * @generated from protobuf message google.protobuf.FieldMask\n */\nexport interface FieldMask {\n\t/**\n\t * The set of field mask paths.\n\t *\n\t * @generated from protobuf field: repeated string paths = 1\n\t */\n\tpaths: string[];\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass FieldMask$Type extends MessageType<FieldMask> {\n\tconstructor() {\n\t\tsuper('google.protobuf.FieldMask', [\n\t\t\t{\n\t\t\t\tno: 1,\n\t\t\t\tname: 'paths',\n\t\t\t\tkind: 'scalar',\n\t\t\t\trepeat: 2 /*RepeatType.UNPACKED*/,\n\t\t\t\tT: 9 /*ScalarType.STRING*/,\n\t\t\t},\n\t\t]);\n\t}\n\t/**\n\t * Encode `FieldMask` to JSON object.\n\t */\n\tinternalJsonWrite(message: FieldMask, options: JsonWriteOptions): JsonValue {\n\t\tconst invalidFieldMaskJsonRegex = /[A-Z]|(_([.0-9_]|$))/g;\n\t\treturn message.paths\n\t\t\t.map((p) => {\n\t\t\t\tif (invalidFieldMaskJsonRegex.test(p))\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Unable to encode FieldMask to JSON. lowerCamelCase of path name \"' +\n\t\t\t\t\t\t\tp +\n\t\t\t\t\t\t\t'\" is irreversible.',\n\t\t\t\t\t);\n\t\t\t\treturn lowerCamelCase(p);\n\t\t\t})\n\t\t\t.join(',');\n\t}\n\t/**\n\t * Decode `FieldMask` from JSON object.\n\t */\n\tinternalJsonRead(json: JsonValue, options: JsonReadOptions, target?: FieldMask): FieldMask {\n\t\tif (typeof json !== 'string')\n\t\t\tthrow new Error(\n\t\t\t\t'Unable to parse FieldMask from JSON ' + typeofJsonValue(json) + '. Expected string.',\n\t\t\t);\n\t\tif (!target) target = this.create();\n\t\tif (json === '') return target;\n\t\tlet camelToSnake = (str: string) => {\n\t\t\tif (str.includes('_'))\n\t\t\t\tthrow new Error('Unable to parse FieldMask from JSON. Path names must be lowerCamelCase.');\n\t\t\tlet sc = str.replace(/[A-Z]/g, (letter) => '_' + letter.toLowerCase());\n\t\t\treturn sc;\n\t\t};\n\t\ttarget.paths = json.split(',').map(camelToSnake);\n\t\treturn target;\n\t}\n\tcreate(value?: PartialMessage<FieldMask>): FieldMask {\n\t\tconst message = globalThis.Object.create(this.messagePrototype!);\n\t\tmessage.paths = [];\n\t\tif (value !== undefined) reflectionMergePartial<FieldMask>(this, message, value);\n\t\treturn message;\n\t}\n\tinternalBinaryRead(\n\t\treader: IBinaryReader,\n\t\tlength: number,\n\t\toptions: BinaryReadOptions,\n\t\ttarget?: FieldMask,\n\t): FieldMask {\n\t\tlet message = target ?? this.create(),\n\t\t\tend = reader.pos + length;\n\t\twhile (reader.pos < end) {\n\t\t\tlet [fieldNo, wireType] = reader.tag();\n\t\t\tswitch (fieldNo) {\n\t\t\t\tcase /* repeated string paths */ 1:\n\t\t\t\t\tmessage.paths.push(reader.string());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlet u = options.readUnknownField;\n\t\t\t\t\tif (u === 'throw')\n\t\t\t\t\t\tthrow new globalThis.Error(\n\t\t\t\t\t\t\t`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,\n\t\t\t\t\t\t);\n\t\t\t\t\tlet d = reader.skip(wireType);\n\t\t\t\t\tif (u !== false)\n\t\t\t\t\t\t(u === true ? UnknownFieldHandler.onRead : u)(\n\t\t\t\t\t\t\tthis.typeName,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tfieldNo,\n\t\t\t\t\t\t\twireType,\n\t\t\t\t\t\t\td,\n\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}\n\tinternalBinaryWrite(\n\t\tmessage: FieldMask,\n\t\twriter: IBinaryWriter,\n\t\toptions: BinaryWriteOptions,\n\t): IBinaryWriter {\n\t\t/* repeated string paths = 1; */\n\t\tfor (let i = 0; i < message.paths.length; i++)\n\t\t\twriter.tag(1, WireType.LengthDelimited).string(message.paths[i]);\n\t\tlet u = options.writeUnknownFields;\n\t\tif (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n\t\treturn writer;\n\t}\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.FieldMask\n */\nexport const FieldMask = new FieldMask$Type();\n"],
  "mappings": "AAIA,SAAS,gBAAgB;AAGzB,SAAS,2BAA2B;AAEpC,SAAS,8BAA8B;AACvC,SAAS,uBAAuB;AAEhC,SAAS,sBAAsB;AAG/B,SAAS,mBAAmB;AAqN5B,MAAM,uBAAuB,YAAuB;AAAA,EACnD,cAAc;AACb,UAAM,6BAA6B;AAAA,MAClC;AAAA,QACC,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,GAAG;AAAA,MACJ;AAAA,IACD,CAAC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,SAAoB,SAAsC;AAC3E,UAAM,4BAA4B;AAClC,WAAO,QAAQ,MACb,IAAI,CAAC,MAAM;AACX,UAAI,0BAA0B,KAAK,CAAC;AACnC,cAAM,IAAI;AAAA,UACT,sEACC,IACA;AAAA,QACF;AACD,aAAO,eAAe,CAAC;AAAA,IACxB,CAAC,EACA,KAAK,GAAG;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,iBAAiB,MAAiB,SAA0B,QAA+B;AAC1F,QAAI,OAAO,SAAS;AACnB,YAAM,IAAI;AAAA,QACT,yCAAyC,gBAAgB,IAAI,IAAI;AAAA,MAClE;AACD,QAAI,CAAC,OAAQ,UAAS,KAAK,OAAO;AAClC,QAAI,SAAS,GAAI,QAAO;AACxB,QAAI,eAAe,CAAC,QAAgB;AACnC,UAAI,IAAI,SAAS,GAAG;AACnB,cAAM,IAAI,MAAM,yEAAyE;AAC1F,UAAI,KAAK,IAAI,QAAQ,UAAU,CAAC,WAAW,MAAM,OAAO,YAAY,CAAC;AACrE,aAAO;AAAA,IACR;AACA,WAAO,QAAQ,KAAK,MAAM,GAAG,EAAE,IAAI,YAAY;AAC/C,WAAO;AAAA,EACR;AAAA,EACA,OAAO,OAA8C;AACpD,UAAM,UAAU,WAAW,OAAO,OAAO,KAAK,gBAAiB;AAC/D,YAAQ,QAAQ,CAAC;AACjB,QAAI,UAAU,OAAW,wBAAkC,MAAM,SAAS,KAAK;AAC/E,WAAO;AAAA,EACR;AAAA,EACA,mBACC,QACA,QACA,SACA,QACY;AACZ,QAAI,UAAU,UAAU,KAAK,OAAO,GACnC,MAAM,OAAO,MAAM;AACpB,WAAO,OAAO,MAAM,KAAK;AACxB,UAAI,CAAC,SAAS,QAAQ,IAAI,OAAO,IAAI;AACrC,cAAQ,SAAS;AAAA,QAChB;AAAA,QAAiC;AAChC,kBAAQ,MAAM,KAAK,OAAO,OAAO,CAAC;AAClC;AAAA,QACD;AACC,cAAI,IAAI,QAAQ;AAChB,cAAI,MAAM;AACT,kBAAM,IAAI,WAAW;AAAA,cACpB,iBAAiB,OAAO,eAAe,QAAQ,SAAS,KAAK,QAAQ;AAAA,YACtE;AACD,cAAI,IAAI,OAAO,KAAK,QAAQ;AAC5B,cAAI,MAAM;AACT,aAAC,MAAM,OAAO,oBAAoB,SAAS;AAAA,cAC1C,KAAK;AAAA,cACL;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACD;AAAA,MACH;AAAA,IACD;AACA,WAAO;AAAA,EACR;AAAA,EACA,oBACC,SACA,QACA,SACgB;AAEhB,aAAS,IAAI,GAAG,IAAI,QAAQ,MAAM,QAAQ;AACzC,aAAO,IAAI,GAAG,SAAS,eAAe,EAAE,OAAO,QAAQ,MAAM,CAAC,CAAC;AAChE,QAAI,IAAI,QAAQ;AAChB,QAAI,MAAM,MAAO,EAAC,KAAK,OAAO,oBAAoB,UAAU,GAAG,KAAK,UAAU,SAAS,MAAM;AAC7F,WAAO;AAAA,EACR;AACD;AAIO,MAAM,YAAY,IAAI,eAAe;",
  "names": []
}
