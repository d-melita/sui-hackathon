{
  "version": 3,
  "sources": ["../../../../../src/proto/google/protobuf/any.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BinaryWriteOptions } from '@protobuf-ts/runtime';\nimport type { IBinaryWriter } from '@protobuf-ts/runtime';\nimport { WireType } from '@protobuf-ts/runtime';\nimport type { IBinaryReader } from '@protobuf-ts/runtime';\nimport { UnknownFieldHandler } from '@protobuf-ts/runtime';\nimport type { PartialMessage } from '@protobuf-ts/runtime';\nimport { reflectionMergePartial } from '@protobuf-ts/runtime';\nimport { isJsonObject } from '@protobuf-ts/runtime';\nimport { typeofJsonValue } from '@protobuf-ts/runtime';\nimport type { JsonValue } from '@protobuf-ts/runtime';\nimport { jsonWriteOptions } from '@protobuf-ts/runtime';\nimport type { JsonReadOptions } from '@protobuf-ts/runtime';\nimport type { JsonWriteOptions } from '@protobuf-ts/runtime';\nimport type { BinaryReadOptions } from '@protobuf-ts/runtime';\nimport type { IMessageType } from '@protobuf-ts/runtime';\nimport { MessageType } from '@protobuf-ts/runtime';\n/**\n * `Any` contains an arbitrary serialized protocol buffer message along with a\n * URL that describes the type of the serialized message.\n *\n * Protobuf library provides support to pack/unpack Any values in the form\n * of utility functions or additional generated methods of the Any type.\n *\n * Example 1: Pack and unpack a message in C++.\n *\n *     Foo foo = ...;\n *     Any any;\n *     any.PackFrom(foo);\n *     ...\n *     if (any.UnpackTo(&foo)) {\n *       ...\n *     }\n *\n * Example 2: Pack and unpack a message in Java.\n *\n *     Foo foo = ...;\n *     Any any = Any.pack(foo);\n *     ...\n *     if (any.is(Foo.class)) {\n *       foo = any.unpack(Foo.class);\n *     }\n *     // or ...\n *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n *       foo = any.unpack(Foo.getDefaultInstance());\n *     }\n *\n *  Example 3: Pack and unpack a message in Python.\n *\n *     foo = Foo(...)\n *     any = Any()\n *     any.Pack(foo)\n *     ...\n *     if any.Is(Foo.DESCRIPTOR):\n *       any.Unpack(foo)\n *       ...\n *\n *  Example 4: Pack and unpack a message in Go\n *\n *      foo := &pb.Foo{...}\n *      any, err := anypb.New(foo)\n *      if err != nil {\n *        ...\n *      }\n *      ...\n *      foo := &pb.Foo{}\n *      if err := any.UnmarshalTo(foo); err != nil {\n *        ...\n *      }\n *\n * The pack methods provided by protobuf library will by default use\n * 'type.googleapis.com/full.type.name' as the type URL and the unpack\n * methods only use the fully qualified type name after the last '/'\n * in the type URL, for example \"foo.bar.com/x/y.z\" will yield type\n * name \"y.z\".\n *\n * JSON\n * ====\n * The JSON representation of an `Any` value uses the regular\n * representation of the deserialized, embedded message, with an\n * additional field `@type` which contains the type URL. Example:\n *\n *     package google.profile;\n *     message Person {\n *       string first_name = 1;\n *       string last_name = 2;\n *     }\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.profile.Person\",\n *       \"firstName\": <string>,\n *       \"lastName\": <string>\n *     }\n *\n * If the embedded message type is well-known and has a custom JSON\n * representation, that representation will be embedded adding a field\n * `value` which holds the custom JSON in addition to the `@type`\n * field. Example (for message [google.protobuf.Duration][]):\n *\n *     {\n *       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n *       \"value\": \"1.212s\"\n *     }\n *\n *\n * @generated from protobuf message google.protobuf.Any\n */\nexport interface Any {\n\t/**\n\t * A URL/resource name that uniquely identifies the type of the serialized\n\t * protocol buffer message. This string must contain at least\n\t * one \"/\" character. The last segment of the URL's path must represent\n\t * the fully qualified name of the type (as in\n\t * `path/google.protobuf.Duration`). The name should be in a canonical form\n\t * (e.g., leading \".\" is not accepted).\n\t *\n\t * In practice, teams usually precompile into the binary all types that they\n\t * expect it to use in the context of Any. However, for URLs which use the\n\t * scheme `http`, `https`, or no scheme, one can optionally set up a type\n\t * server that maps type URLs to message definitions as follows:\n\t *\n\t * * If no scheme is provided, `https` is assumed.\n\t * * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n\t *   value in binary format, or produce an error.\n\t * * Applications are allowed to cache lookup results based on the\n\t *   URL, or have them precompiled into a binary to avoid any\n\t *   lookup. Therefore, binary compatibility needs to be preserved\n\t *   on changes to types. (Use versioned type names to manage\n\t *   breaking changes.)\n\t *\n\t * Note: this functionality is not currently available in the official\n\t * protobuf release, and it is not used for type URLs beginning with\n\t * type.googleapis.com. As of May 2023, there are no widely used type server\n\t * implementations and no plans to implement one.\n\t *\n\t * Schemes other than `http`, `https` (or the empty scheme) might be\n\t * used with implementation specific semantics.\n\t *\n\t *\n\t * @generated from protobuf field: string type_url = 1\n\t */\n\ttypeUrl: string;\n\t/**\n\t * Must be a valid serialized protocol buffer of the above specified type.\n\t *\n\t * @generated from protobuf field: bytes value = 2\n\t */\n\tvalue: Uint8Array;\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass Any$Type extends MessageType<Any> {\n\tconstructor() {\n\t\tsuper('google.protobuf.Any', [\n\t\t\t{ no: 1, name: 'type_url', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },\n\t\t\t{ no: 2, name: 'value', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },\n\t\t]);\n\t}\n\t/**\n\t * Pack the message into a new `Any`.\n\t *\n\t * Uses 'type.googleapis.com/full.type.name' as the type URL.\n\t */\n\tpack<T extends object>(message: T, type: IMessageType<T>): Any {\n\t\treturn {\n\t\t\ttypeUrl: this.typeNameToUrl(type.typeName),\n\t\t\tvalue: type.toBinary(message),\n\t\t};\n\t}\n\t/**\n\t * Unpack the message from the `Any`.\n\t */\n\tunpack<T extends object>(\n\t\tany: Any,\n\t\ttype: IMessageType<T>,\n\t\toptions?: Partial<BinaryReadOptions>,\n\t): T {\n\t\tif (!this.contains(any, type))\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot unpack google.protobuf.Any with typeUrl '\" +\n\t\t\t\t\tany.typeUrl +\n\t\t\t\t\t\"' as \" +\n\t\t\t\t\ttype.typeName +\n\t\t\t\t\t'.',\n\t\t\t);\n\t\treturn type.fromBinary(any.value, options);\n\t}\n\t/**\n\t * Does the given `Any` contain a packed message of the given type?\n\t */\n\tcontains(any: Any, type: IMessageType<any> | string): boolean {\n\t\tif (!any.typeUrl.length) return false;\n\t\tlet wants = typeof type == 'string' ? type : type.typeName;\n\t\tlet has = this.typeUrlToName(any.typeUrl);\n\t\treturn wants === has;\n\t}\n\t/**\n\t * Convert the message to canonical JSON value.\n\t *\n\t * You have to provide the `typeRegistry` option so that the\n\t * packed message can be converted to JSON.\n\t *\n\t * The `typeRegistry` option is also required to read\n\t * `google.protobuf.Any` from JSON format.\n\t */\n\tinternalJsonWrite(any: Any, options: JsonWriteOptions): JsonValue {\n\t\tif (any.typeUrl === '') return {};\n\t\tlet typeName = this.typeUrlToName(any.typeUrl);\n\t\tlet opt = jsonWriteOptions(options);\n\t\tlet type = opt.typeRegistry?.find((t) => t.typeName === typeName);\n\t\tif (!type)\n\t\t\tthrow new globalThis.Error(\n\t\t\t\t\"Unable to convert google.protobuf.Any with typeUrl '\" +\n\t\t\t\t\tany.typeUrl +\n\t\t\t\t\t\"' to JSON. The specified type \" +\n\t\t\t\t\ttypeName +\n\t\t\t\t\t' is not available in the type registry.',\n\t\t\t);\n\t\tlet value = type.fromBinary(any.value, { readUnknownField: false });\n\t\tlet json = type.internalJsonWrite(value, opt);\n\t\tif (typeName.startsWith('google.protobuf.') || !isJsonObject(json)) json = { value: json };\n\t\tjson['@type'] = any.typeUrl;\n\t\treturn json;\n\t}\n\tinternalJsonRead(json: JsonValue, options: JsonReadOptions, target?: Any): Any {\n\t\tif (!isJsonObject(json))\n\t\t\tthrow new globalThis.Error(\n\t\t\t\t'Unable to parse google.protobuf.Any from JSON ' + typeofJsonValue(json) + '.',\n\t\t\t);\n\t\tif (typeof json['@type'] != 'string' || json['@type'] == '') return this.create();\n\t\tlet typeName = this.typeUrlToName(json['@type']);\n\t\tlet type = options?.typeRegistry?.find((t) => t.typeName == typeName);\n\t\tif (!type)\n\t\t\tthrow new globalThis.Error(\n\t\t\t\t'Unable to parse google.protobuf.Any from JSON. The specified type ' +\n\t\t\t\t\ttypeName +\n\t\t\t\t\t' is not available in the type registry.',\n\t\t\t);\n\t\tlet value;\n\t\tif (typeName.startsWith('google.protobuf.') && json.hasOwnProperty('value'))\n\t\t\tvalue = type.fromJson(json['value'], options);\n\t\telse {\n\t\t\tlet copy = Object.assign({}, json);\n\t\t\tdelete copy['@type'];\n\t\t\tvalue = type.fromJson(copy, options);\n\t\t}\n\t\tif (target === undefined) target = this.create();\n\t\ttarget.typeUrl = json['@type'];\n\t\ttarget.value = type.toBinary(value);\n\t\treturn target;\n\t}\n\ttypeNameToUrl(name: string): string {\n\t\tif (!name.length) throw new Error('invalid type name: ' + name);\n\t\treturn 'type.googleapis.com/' + name;\n\t}\n\ttypeUrlToName(url: string): string {\n\t\tif (!url.length) throw new Error('invalid type url: ' + url);\n\t\tlet slash = url.lastIndexOf('/');\n\t\tlet name = slash > 0 ? url.substring(slash + 1) : url;\n\t\tif (!name.length) throw new Error('invalid type url: ' + url);\n\t\treturn name;\n\t}\n\tcreate(value?: PartialMessage<Any>): Any {\n\t\tconst message = globalThis.Object.create(this.messagePrototype!);\n\t\tmessage.typeUrl = '';\n\t\tmessage.value = new Uint8Array(0);\n\t\tif (value !== undefined) reflectionMergePartial<Any>(this, message, value);\n\t\treturn message;\n\t}\n\tinternalBinaryRead(\n\t\treader: IBinaryReader,\n\t\tlength: number,\n\t\toptions: BinaryReadOptions,\n\t\ttarget?: Any,\n\t): Any {\n\t\tlet message = target ?? this.create(),\n\t\t\tend = reader.pos + length;\n\t\twhile (reader.pos < end) {\n\t\t\tlet [fieldNo, wireType] = reader.tag();\n\t\t\tswitch (fieldNo) {\n\t\t\t\tcase /* string type_url */ 1:\n\t\t\t\t\tmessage.typeUrl = reader.string();\n\t\t\t\t\tbreak;\n\t\t\t\tcase /* bytes value */ 2:\n\t\t\t\t\tmessage.value = reader.bytes();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlet u = options.readUnknownField;\n\t\t\t\t\tif (u === 'throw')\n\t\t\t\t\t\tthrow new globalThis.Error(\n\t\t\t\t\t\t\t`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,\n\t\t\t\t\t\t);\n\t\t\t\t\tlet d = reader.skip(wireType);\n\t\t\t\t\tif (u !== false)\n\t\t\t\t\t\t(u === true ? UnknownFieldHandler.onRead : u)(\n\t\t\t\t\t\t\tthis.typeName,\n\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\tfieldNo,\n\t\t\t\t\t\t\twireType,\n\t\t\t\t\t\t\td,\n\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}\n\tinternalBinaryWrite(\n\t\tmessage: Any,\n\t\twriter: IBinaryWriter,\n\t\toptions: BinaryWriteOptions,\n\t): IBinaryWriter {\n\t\t/* string type_url = 1; */\n\t\tif (message.typeUrl !== '') writer.tag(1, WireType.LengthDelimited).string(message.typeUrl);\n\t\t/* bytes value = 2; */\n\t\tif (message.value.length) writer.tag(2, WireType.LengthDelimited).bytes(message.value);\n\t\tlet u = options.writeUnknownFields;\n\t\tif (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n\t\treturn writer;\n\t}\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Any\n */\nexport const Any = new Any$Type();\n"],
  "mappings": "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",
  "names": ["import_runtime"]
}
