"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var signature_exports = {};
__export(signature_exports, {
  CircomG1: () => CircomG1,
  CircomG2: () => CircomG2,
  MultisigAggregatedSignature: () => MultisigAggregatedSignature,
  MultisigCommittee: () => MultisigCommittee,
  MultisigMember: () => MultisigMember,
  MultisigMemberPublicKey: () => MultisigMemberPublicKey,
  MultisigMemberSignature: () => MultisigMemberSignature,
  PasskeyAuthenticator: () => PasskeyAuthenticator,
  SimpleSignature: () => SimpleSignature,
  UserSignature: () => UserSignature,
  ValidatorAggregatedSignature: () => ValidatorAggregatedSignature,
  ValidatorCommittee: () => ValidatorCommittee,
  ValidatorCommitteeMember: () => ValidatorCommitteeMember,
  ZkLoginAuthenticator: () => ZkLoginAuthenticator,
  ZkLoginClaim: () => ZkLoginClaim,
  ZkLoginInputs: () => ZkLoginInputs,
  ZkLoginProof: () => ZkLoginProof,
  ZkLoginPublicIdentifier: () => ZkLoginPublicIdentifier
});
module.exports = __toCommonJS(signature_exports);
var import_runtime = require("@protobuf-ts/runtime");
var import_runtime2 = require("@protobuf-ts/runtime");
var import_runtime3 = require("@protobuf-ts/runtime");
var import_runtime4 = require("@protobuf-ts/runtime");
var import_signature_scheme = require("./signature_scheme.js");
var import_bcs = require("./bcs.js");
class UserSignature$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.UserSignature", [
      { no: 1, name: "bcs", kind: "message", T: () => import_bcs.Bcs },
      {
        no: 2,
        name: "scheme",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.SignatureScheme", import_signature_scheme.SignatureScheme]
      },
      { no: 3, name: "simple", kind: "message", oneof: "signature", T: () => SimpleSignature },
      {
        no: 4,
        name: "multisig",
        kind: "message",
        oneof: "signature",
        T: () => MultisigAggregatedSignature
      },
      {
        no: 5,
        name: "zklogin",
        kind: "message",
        oneof: "signature",
        T: () => ZkLoginAuthenticator
      },
      {
        no: 6,
        name: "passkey",
        kind: "message",
        oneof: "signature",
        T: () => PasskeyAuthenticator
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signature = { oneofKind: void 0 };
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Bcs bcs */
        1:
          message.bcs = import_bcs.Bcs.internalBinaryRead(reader, reader.uint32(), options, message.bcs);
          break;
        case /* optional sui.rpc.v2beta2.SignatureScheme scheme */
        2:
          message.scheme = reader.int32();
          break;
        case /* sui.rpc.v2beta2.SimpleSignature simple */
        3:
          message.signature = {
            oneofKind: "simple",
            simple: SimpleSignature.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.signature.simple
            )
          };
          break;
        case /* sui.rpc.v2beta2.MultisigAggregatedSignature multisig */
        4:
          message.signature = {
            oneofKind: "multisig",
            multisig: MultisigAggregatedSignature.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.signature.multisig
            )
          };
          break;
        case /* sui.rpc.v2beta2.ZkLoginAuthenticator zklogin */
        5:
          message.signature = {
            oneofKind: "zklogin",
            zklogin: ZkLoginAuthenticator.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.signature.zklogin
            )
          };
          break;
        case /* sui.rpc.v2beta2.PasskeyAuthenticator passkey */
        6:
          message.signature = {
            oneofKind: "passkey",
            passkey: PasskeyAuthenticator.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.signature.passkey
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.bcs)
      import_bcs.Bcs.internalBinaryWrite(
        message.bcs,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.scheme !== void 0) writer.tag(2, import_runtime.WireType.Varint).int32(message.scheme);
    if (message.signature.oneofKind === "simple")
      SimpleSignature.internalBinaryWrite(
        message.signature.simple,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.signature.oneofKind === "multisig")
      MultisigAggregatedSignature.internalBinaryWrite(
        message.signature.multisig,
        writer.tag(4, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.signature.oneofKind === "zklogin")
      ZkLoginAuthenticator.internalBinaryWrite(
        message.signature.zklogin,
        writer.tag(5, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.signature.oneofKind === "passkey")
      PasskeyAuthenticator.internalBinaryWrite(
        message.signature.passkey,
        writer.tag(6, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const UserSignature = new UserSignature$Type();
class SimpleSignature$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SimpleSignature", [
      {
        no: 1,
        name: "scheme",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.SignatureScheme", import_signature_scheme.SignatureScheme]
      },
      {
        no: 2,
        name: "signature",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "public_key",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.SignatureScheme scheme */
        1:
          message.scheme = reader.int32();
          break;
        case /* optional bytes signature */
        2:
          message.signature = reader.bytes();
          break;
        case /* optional bytes public_key */
        3:
          message.publicKey = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.scheme !== void 0) writer.tag(1, import_runtime.WireType.Varint).int32(message.scheme);
    if (message.signature !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.signature);
    if (message.publicKey !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).bytes(message.publicKey);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SimpleSignature = new SimpleSignature$Type();
class ZkLoginPublicIdentifier$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ZkLoginPublicIdentifier", [
      {
        no: 1,
        name: "iss",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address_seed",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string iss */
        1:
          message.iss = reader.string();
          break;
        case /* optional string address_seed */
        2:
          message.addressSeed = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.iss !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.iss);
    if (message.addressSeed !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.addressSeed);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ZkLoginPublicIdentifier = new ZkLoginPublicIdentifier$Type();
class MultisigMemberPublicKey$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MultisigMemberPublicKey", [
      {
        no: 1,
        name: "scheme",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.SignatureScheme", import_signature_scheme.SignatureScheme]
      },
      {
        no: 2,
        name: "public_key",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "zklogin", kind: "message", T: () => ZkLoginPublicIdentifier }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.SignatureScheme scheme */
        1:
          message.scheme = reader.int32();
          break;
        case /* optional bytes public_key */
        2:
          message.publicKey = reader.bytes();
          break;
        case /* optional sui.rpc.v2beta2.ZkLoginPublicIdentifier zklogin */
        3:
          message.zklogin = ZkLoginPublicIdentifier.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.zklogin
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.scheme !== void 0) writer.tag(1, import_runtime.WireType.Varint).int32(message.scheme);
    if (message.publicKey !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.publicKey);
    if (message.zklogin)
      ZkLoginPublicIdentifier.internalBinaryWrite(
        message.zklogin,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MultisigMemberPublicKey = new MultisigMemberPublicKey$Type();
class MultisigMember$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MultisigMember", [
      { no: 1, name: "public_key", kind: "message", T: () => MultisigMemberPublicKey },
      {
        no: 2,
        name: "weight",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.MultisigMemberPublicKey public_key */
        1:
          message.publicKey = MultisigMemberPublicKey.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.publicKey
          );
          break;
        case /* optional uint32 weight */
        2:
          message.weight = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.publicKey)
      MultisigMemberPublicKey.internalBinaryWrite(
        message.publicKey,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.weight !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.weight);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MultisigMember = new MultisigMember$Type();
class MultisigCommittee$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MultisigCommittee", [
      {
        no: 1,
        name: "members",
        kind: "message",
        repeat: 2,
        T: () => MultisigMember
      },
      {
        no: 2,
        name: "threshold",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.members = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.MultisigMember members */
        1:
          message.members.push(MultisigMember.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional uint32 threshold */
        2:
          message.threshold = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.members.length; i++)
      MultisigMember.internalBinaryWrite(
        message.members[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.threshold !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.threshold);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MultisigCommittee = new MultisigCommittee$Type();
class MultisigAggregatedSignature$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MultisigAggregatedSignature", [
      {
        no: 1,
        name: "signatures",
        kind: "message",
        repeat: 2,
        T: () => MultisigMemberSignature
      },
      {
        no: 2,
        name: "bitmap",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "legacy_bitmap",
        kind: "scalar",
        repeat: 1,
        T: 13
      },
      { no: 4, name: "committee", kind: "message", T: () => MultisigCommittee }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.signatures = [];
    message.legacyBitmap = [];
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.MultisigMemberSignature signatures */
        1:
          message.signatures.push(
            MultisigMemberSignature.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional uint32 bitmap */
        2:
          message.bitmap = reader.uint32();
          break;
        case /* repeated uint32 legacy_bitmap */
        3:
          if (wireType === import_runtime.WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.legacyBitmap.push(reader.uint32());
          else message.legacyBitmap.push(reader.uint32());
          break;
        case /* optional sui.rpc.v2beta2.MultisigCommittee committee */
        4:
          message.committee = MultisigCommittee.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.committee
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.signatures.length; i++)
      MultisigMemberSignature.internalBinaryWrite(
        message.signatures[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.bitmap !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.bitmap);
    if (message.legacyBitmap.length) {
      writer.tag(3, import_runtime.WireType.LengthDelimited).fork();
      for (let i = 0; i < message.legacyBitmap.length; i++) writer.uint32(message.legacyBitmap[i]);
      writer.join();
    }
    if (message.committee)
      MultisigCommittee.internalBinaryWrite(
        message.committee,
        writer.tag(4, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MultisigAggregatedSignature = new MultisigAggregatedSignature$Type();
class MultisigMemberSignature$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.MultisigMemberSignature", [
      {
        no: 1,
        name: "scheme",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.SignatureScheme", import_signature_scheme.SignatureScheme]
      },
      {
        no: 2,
        name: "signature",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 3, name: "zklogin", kind: "message", T: () => ZkLoginAuthenticator },
      { no: 4, name: "passkey", kind: "message", T: () => PasskeyAuthenticator }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.SignatureScheme scheme */
        1:
          message.scheme = reader.int32();
          break;
        case /* optional bytes signature */
        2:
          message.signature = reader.bytes();
          break;
        case /* optional sui.rpc.v2beta2.ZkLoginAuthenticator zklogin */
        3:
          message.zklogin = ZkLoginAuthenticator.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.zklogin
          );
          break;
        case /* optional sui.rpc.v2beta2.PasskeyAuthenticator passkey */
        4:
          message.passkey = PasskeyAuthenticator.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.passkey
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.scheme !== void 0) writer.tag(1, import_runtime.WireType.Varint).int32(message.scheme);
    if (message.signature !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.signature);
    if (message.zklogin)
      ZkLoginAuthenticator.internalBinaryWrite(
        message.zklogin,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.passkey)
      PasskeyAuthenticator.internalBinaryWrite(
        message.passkey,
        writer.tag(4, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MultisigMemberSignature = new MultisigMemberSignature$Type();
class ZkLoginAuthenticator$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ZkLoginAuthenticator", [
      { no: 1, name: "inputs", kind: "message", T: () => ZkLoginInputs },
      {
        no: 2,
        name: "max_epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 3, name: "signature", kind: "message", T: () => SimpleSignature }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.ZkLoginInputs inputs */
        1:
          message.inputs = ZkLoginInputs.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.inputs
          );
          break;
        case /* optional uint64 max_epoch */
        2:
          message.maxEpoch = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.SimpleSignature signature */
        3:
          message.signature = SimpleSignature.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.signature
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.inputs)
      ZkLoginInputs.internalBinaryWrite(
        message.inputs,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.maxEpoch !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint64(message.maxEpoch);
    if (message.signature)
      SimpleSignature.internalBinaryWrite(
        message.signature,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ZkLoginAuthenticator = new ZkLoginAuthenticator$Type();
class ZkLoginInputs$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ZkLoginInputs", [
      { no: 1, name: "proof_points", kind: "message", T: () => ZkLoginProof },
      { no: 2, name: "iss_base64_details", kind: "message", T: () => ZkLoginClaim },
      {
        no: 3,
        name: "header_base64",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "address_seed",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.ZkLoginProof proof_points */
        1:
          message.proofPoints = ZkLoginProof.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.proofPoints
          );
          break;
        case /* optional sui.rpc.v2beta2.ZkLoginClaim iss_base64_details */
        2:
          message.issBase64Details = ZkLoginClaim.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.issBase64Details
          );
          break;
        case /* optional string header_base64 */
        3:
          message.headerBase64 = reader.string();
          break;
        case /* optional string address_seed */
        4:
          message.addressSeed = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.proofPoints)
      ZkLoginProof.internalBinaryWrite(
        message.proofPoints,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.issBase64Details)
      ZkLoginClaim.internalBinaryWrite(
        message.issBase64Details,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.headerBase64 !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).string(message.headerBase64);
    if (message.addressSeed !== void 0)
      writer.tag(4, import_runtime.WireType.LengthDelimited).string(message.addressSeed);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ZkLoginInputs = new ZkLoginInputs$Type();
class ZkLoginProof$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ZkLoginProof", [
      { no: 1, name: "a", kind: "message", T: () => CircomG1 },
      { no: 2, name: "b", kind: "message", T: () => CircomG2 },
      { no: 3, name: "c", kind: "message", T: () => CircomG1 }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.CircomG1 a */
        1:
          message.a = CircomG1.internalBinaryRead(reader, reader.uint32(), options, message.a);
          break;
        case /* optional sui.rpc.v2beta2.CircomG2 b */
        2:
          message.b = CircomG2.internalBinaryRead(reader, reader.uint32(), options, message.b);
          break;
        case /* optional sui.rpc.v2beta2.CircomG1 c */
        3:
          message.c = CircomG1.internalBinaryRead(reader, reader.uint32(), options, message.c);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.a)
      CircomG1.internalBinaryWrite(
        message.a,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.b)
      CircomG2.internalBinaryWrite(
        message.b,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.c)
      CircomG1.internalBinaryWrite(
        message.c,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ZkLoginProof = new ZkLoginProof$Type();
class ZkLoginClaim$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ZkLoginClaim", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "index_mod_4",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string value */
        1:
          message.value = reader.string();
          break;
        case /* optional uint32 index_mod_4 */
        2:
          message.indexMod4 = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.value);
    if (message.indexMod4 !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.indexMod4);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ZkLoginClaim = new ZkLoginClaim$Type();
class CircomG1$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CircomG1", [
      {
        no: 1,
        name: "e0",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "e1",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "e2",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string e0 */
        1:
          message.e0 = reader.string();
          break;
        case /* optional string e1 */
        2:
          message.e1 = reader.string();
          break;
        case /* optional string e2 */
        3:
          message.e2 = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.e0 !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.e0);
    if (message.e1 !== void 0) writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.e1);
    if (message.e2 !== void 0) writer.tag(3, import_runtime.WireType.LengthDelimited).string(message.e2);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CircomG1 = new CircomG1$Type();
class CircomG2$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CircomG2", [
      {
        no: 1,
        name: "e00",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "e01",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "e10",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "e11",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "e20",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "e21",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string e00 */
        1:
          message.e00 = reader.string();
          break;
        case /* optional string e01 */
        2:
          message.e01 = reader.string();
          break;
        case /* optional string e10 */
        3:
          message.e10 = reader.string();
          break;
        case /* optional string e11 */
        4:
          message.e11 = reader.string();
          break;
        case /* optional string e20 */
        5:
          message.e20 = reader.string();
          break;
        case /* optional string e21 */
        6:
          message.e21 = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.e00 !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.e00);
    if (message.e01 !== void 0) writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.e01);
    if (message.e10 !== void 0) writer.tag(3, import_runtime.WireType.LengthDelimited).string(message.e10);
    if (message.e11 !== void 0) writer.tag(4, import_runtime.WireType.LengthDelimited).string(message.e11);
    if (message.e20 !== void 0) writer.tag(5, import_runtime.WireType.LengthDelimited).string(message.e20);
    if (message.e21 !== void 0) writer.tag(6, import_runtime.WireType.LengthDelimited).string(message.e21);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CircomG2 = new CircomG2$Type();
class PasskeyAuthenticator$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.PasskeyAuthenticator", [
      {
        no: 1,
        name: "authenticator_data",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "client_data_json",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "signature", kind: "message", T: () => SimpleSignature }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes authenticator_data */
        1:
          message.authenticatorData = reader.bytes();
          break;
        case /* optional string client_data_json */
        2:
          message.clientDataJson = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.SimpleSignature signature */
        3:
          message.signature = SimpleSignature.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.signature
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.authenticatorData !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).bytes(message.authenticatorData);
    if (message.clientDataJson !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.clientDataJson);
    if (message.signature)
      SimpleSignature.internalBinaryWrite(
        message.signature,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const PasskeyAuthenticator = new PasskeyAuthenticator$Type();
class ValidatorCommittee$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ValidatorCommittee", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "members",
        kind: "message",
        repeat: 2,
        T: () => ValidatorCommitteeMember
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.members = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* repeated sui.rpc.v2beta2.ValidatorCommitteeMember members */
        2:
          message.members.push(
            ValidatorCommitteeMember.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, import_runtime.WireType.Varint).uint64(message.epoch);
    for (let i = 0; i < message.members.length; i++)
      ValidatorCommitteeMember.internalBinaryWrite(
        message.members[i],
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorCommittee = new ValidatorCommittee$Type();
class ValidatorCommitteeMember$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ValidatorCommitteeMember", [
      {
        no: 1,
        name: "public_key",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 2,
        name: "weight",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional bytes public_key */
        1:
          message.publicKey = reader.bytes();
          break;
        case /* optional uint64 weight */
        2:
          message.weight = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.publicKey !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).bytes(message.publicKey);
    if (message.weight !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint64(message.weight);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorCommitteeMember = new ValidatorCommitteeMember$Type();
class ValidatorAggregatedSignature$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ValidatorAggregatedSignature", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "signature",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "bitmap",
        kind: "scalar",
        repeat: 1,
        T: 13
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.bitmap = [];
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional bytes signature */
        2:
          message.signature = reader.bytes();
          break;
        case /* repeated uint32 bitmap */
        3:
          if (wireType === import_runtime.WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.bitmap.push(reader.uint32());
          else message.bitmap.push(reader.uint32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, import_runtime.WireType.Varint).uint64(message.epoch);
    if (message.signature !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.signature);
    if (message.bitmap.length) {
      writer.tag(3, import_runtime.WireType.LengthDelimited).fork();
      for (let i = 0; i < message.bitmap.length; i++) writer.uint32(message.bitmap[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ValidatorAggregatedSignature = new ValidatorAggregatedSignature$Type();
//# sourceMappingURL=signature.js.map
