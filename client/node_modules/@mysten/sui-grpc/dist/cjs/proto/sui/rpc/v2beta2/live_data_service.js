"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var live_data_service_exports = {};
__export(live_data_service_exports, {
  Balance: () => Balance,
  CoinMetadata: () => CoinMetadata,
  CoinTreasury: () => CoinTreasury,
  CoinTreasury_SupplyState: () => CoinTreasury_SupplyState,
  CommandOutput: () => CommandOutput,
  CommandResult: () => CommandResult,
  DynamicField: () => DynamicField,
  DynamicField_DynamicFieldKind: () => DynamicField_DynamicFieldKind,
  GetBalanceRequest: () => GetBalanceRequest,
  GetBalanceResponse: () => GetBalanceResponse,
  GetCoinInfoRequest: () => GetCoinInfoRequest,
  GetCoinInfoResponse: () => GetCoinInfoResponse,
  ListBalancesRequest: () => ListBalancesRequest,
  ListBalancesResponse: () => ListBalancesResponse,
  ListDynamicFieldsRequest: () => ListDynamicFieldsRequest,
  ListDynamicFieldsResponse: () => ListDynamicFieldsResponse,
  ListOwnedObjectsRequest: () => ListOwnedObjectsRequest,
  ListOwnedObjectsResponse: () => ListOwnedObjectsResponse,
  LiveDataService: () => LiveDataService,
  RegulatedCoinMetadata: () => RegulatedCoinMetadata,
  SimulateTransactionRequest: () => SimulateTransactionRequest,
  SimulateTransactionRequest_TransactionChecks: () => SimulateTransactionRequest_TransactionChecks,
  SimulateTransactionResponse: () => SimulateTransactionResponse
});
module.exports = __toCommonJS(live_data_service_exports);
var import_runtime_rpc = require("@protobuf-ts/runtime-rpc");
var import_runtime = require("@protobuf-ts/runtime");
var import_runtime2 = require("@protobuf-ts/runtime");
var import_runtime3 = require("@protobuf-ts/runtime");
var import_runtime4 = require("@protobuf-ts/runtime");
var import_struct = require("../../../google/protobuf/struct.js");
var import_bcs = require("./bcs.js");
var import_argument = require("./argument.js");
var import_executed_transaction = require("./executed_transaction.js");
var import_transaction = require("./transaction.js");
var import_object = require("./object.js");
var import_field_mask = require("../../../google/protobuf/field_mask.js");
var CoinTreasury_SupplyState = /* @__PURE__ */ ((CoinTreasury_SupplyState2) => {
  CoinTreasury_SupplyState2[CoinTreasury_SupplyState2["SUPPLY_STATE_UNKNOWN"] = 0] = "SUPPLY_STATE_UNKNOWN";
  CoinTreasury_SupplyState2[CoinTreasury_SupplyState2["FIXED"] = 1] = "FIXED";
  return CoinTreasury_SupplyState2;
})(CoinTreasury_SupplyState || {});
var DynamicField_DynamicFieldKind = /* @__PURE__ */ ((DynamicField_DynamicFieldKind2) => {
  DynamicField_DynamicFieldKind2[DynamicField_DynamicFieldKind2["DYNAMIC_FIELD_KIND_UNKNOWN"] = 0] = "DYNAMIC_FIELD_KIND_UNKNOWN";
  DynamicField_DynamicFieldKind2[DynamicField_DynamicFieldKind2["FIELD"] = 1] = "FIELD";
  DynamicField_DynamicFieldKind2[DynamicField_DynamicFieldKind2["OBJECT"] = 2] = "OBJECT";
  return DynamicField_DynamicFieldKind2;
})(DynamicField_DynamicFieldKind || {});
var SimulateTransactionRequest_TransactionChecks = /* @__PURE__ */ ((SimulateTransactionRequest_TransactionChecks2) => {
  SimulateTransactionRequest_TransactionChecks2[SimulateTransactionRequest_TransactionChecks2["ENABLED"] = 0] = "ENABLED";
  SimulateTransactionRequest_TransactionChecks2[SimulateTransactionRequest_TransactionChecks2["DISABLED"] = 1] = "DISABLED";
  return SimulateTransactionRequest_TransactionChecks2;
})(SimulateTransactionRequest_TransactionChecks || {});
class GetCoinInfoRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetCoinInfoRequest", [
      {
        no: 1,
        name: "coin_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string coin_type */
        1:
          message.coinType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.coinType !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.coinType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCoinInfoRequest = new GetCoinInfoRequest$Type();
class GetCoinInfoResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetCoinInfoResponse", [
      {
        no: 1,
        name: "coin_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "metadata", kind: "message", T: () => CoinMetadata },
      { no: 3, name: "treasury", kind: "message", T: () => CoinTreasury },
      { no: 4, name: "regulated_metadata", kind: "message", T: () => RegulatedCoinMetadata }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string coin_type */
        1:
          message.coinType = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.CoinMetadata metadata */
        2:
          message.metadata = CoinMetadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata
          );
          break;
        case /* optional sui.rpc.v2beta2.CoinTreasury treasury */
        3:
          message.treasury = CoinTreasury.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.treasury
          );
          break;
        case /* optional sui.rpc.v2beta2.RegulatedCoinMetadata regulated_metadata */
        4:
          message.regulatedMetadata = RegulatedCoinMetadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.regulatedMetadata
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.coinType !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.coinType);
    if (message.metadata)
      CoinMetadata.internalBinaryWrite(
        message.metadata,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.treasury)
      CoinTreasury.internalBinaryWrite(
        message.treasury,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.regulatedMetadata)
      RegulatedCoinMetadata.internalBinaryWrite(
        message.regulatedMetadata,
        writer.tag(4, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCoinInfoResponse = new GetCoinInfoResponse$Type();
class CoinMetadata$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CoinMetadata", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "decimals",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "symbol",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "icon_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "metadata_cap_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string id */
        1:
          message.id = reader.string();
          break;
        case /* optional uint32 decimals */
        2:
          message.decimals = reader.uint32();
          break;
        case /* optional string name */
        3:
          message.name = reader.string();
          break;
        case /* optional string symbol */
        4:
          message.symbol = reader.string();
          break;
        case /* optional string description */
        5:
          message.description = reader.string();
          break;
        case /* optional string icon_url */
        6:
          message.iconUrl = reader.string();
          break;
        case /* optional string metadata_cap_id */
        7:
          message.metadataCapId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.id);
    if (message.decimals !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.decimals);
    if (message.name !== void 0) writer.tag(3, import_runtime.WireType.LengthDelimited).string(message.name);
    if (message.symbol !== void 0)
      writer.tag(4, import_runtime.WireType.LengthDelimited).string(message.symbol);
    if (message.description !== void 0)
      writer.tag(5, import_runtime.WireType.LengthDelimited).string(message.description);
    if (message.iconUrl !== void 0)
      writer.tag(6, import_runtime.WireType.LengthDelimited).string(message.iconUrl);
    if (message.metadataCapId !== void 0)
      writer.tag(7, import_runtime.WireType.LengthDelimited).string(message.metadataCapId);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CoinMetadata = new CoinMetadata$Type();
class CoinTreasury$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CoinTreasury", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "total_supply",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 3,
        name: "supply_state",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.CoinTreasury.SupplyState", CoinTreasury_SupplyState]
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string id */
        1:
          message.id = reader.string();
          break;
        case /* optional uint64 total_supply */
        2:
          message.totalSupply = reader.uint64().toBigInt();
          break;
        case /* optional sui.rpc.v2beta2.CoinTreasury.SupplyState supply_state */
        3:
          message.supplyState = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.id);
    if (message.totalSupply !== void 0)
      writer.tag(2, import_runtime.WireType.Varint).uint64(message.totalSupply);
    if (message.supplyState !== void 0)
      writer.tag(3, import_runtime.WireType.Varint).int32(message.supplyState);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CoinTreasury = new CoinTreasury$Type();
class RegulatedCoinMetadata$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.RegulatedCoinMetadata", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "coin_metadata_object",
        kind: "scalar",
        opt: true,
        T: 9
      },
      {
        no: 3,
        name: "deny_cap_object",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string id */
        1:
          message.id = reader.string();
          break;
        case /* optional string coin_metadata_object */
        2:
          message.coinMetadataObject = reader.string();
          break;
        case /* optional string deny_cap_object */
        3:
          message.denyCapObject = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.id);
    if (message.coinMetadataObject !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.coinMetadataObject);
    if (message.denyCapObject !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).string(message.denyCapObject);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RegulatedCoinMetadata = new RegulatedCoinMetadata$Type();
class GetBalanceRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetBalanceRequest", [
      {
        no: 1,
        name: "owner",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "coin_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string owner */
        1:
          message.owner = reader.string();
          break;
        case /* optional string coin_type */
        2:
          message.coinType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.owner !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.owner);
    if (message.coinType !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.coinType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBalanceRequest = new GetBalanceRequest$Type();
class GetBalanceResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetBalanceResponse", [
      { no: 1, name: "balance", kind: "message", T: () => Balance }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Balance balance */
        1:
          message.balance = Balance.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.balance
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.balance)
      Balance.internalBinaryWrite(
        message.balance,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetBalanceResponse = new GetBalanceResponse$Type();
class ListBalancesRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ListBalancesRequest", [
      {
        no: 1,
        name: "owner",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "page_size",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "page_token",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string owner */
        1:
          message.owner = reader.string();
          break;
        case /* optional uint32 page_size */
        2:
          message.pageSize = reader.uint32();
          break;
        case /* optional bytes page_token */
        3:
          message.pageToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.owner !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.owner);
    if (message.pageSize !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.pageSize);
    if (message.pageToken !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).bytes(message.pageToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListBalancesRequest = new ListBalancesRequest$Type();
class ListBalancesResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ListBalancesResponse", [
      {
        no: 1,
        name: "balances",
        kind: "message",
        repeat: 2,
        T: () => Balance
      },
      {
        no: 2,
        name: "next_page_token",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.balances = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.Balance balances */
        1:
          message.balances.push(Balance.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional bytes next_page_token */
        2:
          message.nextPageToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.balances.length; i++)
      Balance.internalBinaryWrite(
        message.balances[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.nextPageToken !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListBalancesResponse = new ListBalancesResponse$Type();
class Balance$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.Balance", [
      {
        no: 1,
        name: "coin_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "balance",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string coin_type */
        1:
          message.coinType = reader.string();
          break;
        case /* optional uint64 balance */
        3:
          message.balance = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.coinType !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.coinType);
    if (message.balance !== void 0) writer.tag(3, import_runtime.WireType.Varint).uint64(message.balance);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const Balance = new Balance$Type();
class ListDynamicFieldsRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ListDynamicFieldsRequest", [
      {
        no: 1,
        name: "parent",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "page_size",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "page_token",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string parent */
        1:
          message.parent = reader.string();
          break;
        case /* optional uint32 page_size */
        2:
          message.pageSize = reader.uint32();
          break;
        case /* optional bytes page_token */
        3:
          message.pageToken = reader.bytes();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        4:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.parent !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.parent);
    if (message.pageSize !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.pageSize);
    if (message.pageToken !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).bytes(message.pageToken);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(4, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListDynamicFieldsRequest = new ListDynamicFieldsRequest$Type();
class ListDynamicFieldsResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ListDynamicFieldsResponse", [
      {
        no: 1,
        name: "dynamic_fields",
        kind: "message",
        repeat: 2,
        T: () => DynamicField
      },
      {
        no: 2,
        name: "next_page_token",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.dynamicFields = [];
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.DynamicField dynamic_fields */
        1:
          message.dynamicFields.push(
            DynamicField.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional bytes next_page_token */
        2:
          message.nextPageToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.dynamicFields.length; i++)
      DynamicField.internalBinaryWrite(
        message.dynamicFields[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.nextPageToken !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListDynamicFieldsResponse = new ListDynamicFieldsResponse$Type();
class DynamicField$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.DynamicField", [
      {
        no: 1,
        name: "kind",
        kind: "enum",
        opt: true,
        T: () => ["sui.rpc.v2beta2.DynamicField.DynamicFieldKind", DynamicField_DynamicFieldKind]
      },
      {
        no: 2,
        name: "parent",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "field_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "name_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "name_value",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "value_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "dynamic_object_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "object", kind: "message", T: () => import_object.Object }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.DynamicField.DynamicFieldKind kind */
        1:
          message.kind = reader.int32();
          break;
        case /* optional string parent */
        2:
          message.parent = reader.string();
          break;
        case /* optional string field_id */
        3:
          message.fieldId = reader.string();
          break;
        case /* optional string name_type */
        4:
          message.nameType = reader.string();
          break;
        case /* optional bytes name_value */
        5:
          message.nameValue = reader.bytes();
          break;
        case /* optional string value_type */
        6:
          message.valueType = reader.string();
          break;
        case /* optional string dynamic_object_id */
        7:
          message.dynamicObjectId = reader.string();
          break;
        case /* optional sui.rpc.v2beta2.Object object */
        8:
          message.object = import_object.Object.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.object
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.kind !== void 0) writer.tag(1, import_runtime.WireType.Varint).int32(message.kind);
    if (message.parent !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.parent);
    if (message.fieldId !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).string(message.fieldId);
    if (message.nameType !== void 0)
      writer.tag(4, import_runtime.WireType.LengthDelimited).string(message.nameType);
    if (message.nameValue !== void 0)
      writer.tag(5, import_runtime.WireType.LengthDelimited).bytes(message.nameValue);
    if (message.valueType !== void 0)
      writer.tag(6, import_runtime.WireType.LengthDelimited).string(message.valueType);
    if (message.dynamicObjectId !== void 0)
      writer.tag(7, import_runtime.WireType.LengthDelimited).string(message.dynamicObjectId);
    if (message.object)
      import_object.Object.internalBinaryWrite(
        message.object,
        writer.tag(8, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const DynamicField = new DynamicField$Type();
class SimulateTransactionRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SimulateTransactionRequest", [
      { no: 1, name: "transaction", kind: "message", T: () => import_transaction.Transaction },
      { no: 2, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask },
      {
        no: 3,
        name: "checks",
        kind: "enum",
        opt: true,
        T: () => [
          "sui.rpc.v2beta2.SimulateTransactionRequest.TransactionChecks",
          SimulateTransactionRequest_TransactionChecks
        ]
      },
      {
        no: 4,
        name: "do_gas_selection",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Transaction transaction */
        1:
          message.transaction = import_transaction.Transaction.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.transaction
          );
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        case /* optional sui.rpc.v2beta2.SimulateTransactionRequest.TransactionChecks checks */
        3:
          message.checks = reader.int32();
          break;
        case /* optional bool do_gas_selection */
        4:
          message.doGasSelection = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      import_transaction.Transaction.internalBinaryWrite(
        message.transaction,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.checks !== void 0) writer.tag(3, import_runtime.WireType.Varint).int32(message.checks);
    if (message.doGasSelection !== void 0)
      writer.tag(4, import_runtime.WireType.Varint).bool(message.doGasSelection);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SimulateTransactionRequest = new SimulateTransactionRequest$Type();
class SimulateTransactionResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.SimulateTransactionResponse", [
      { no: 1, name: "transaction", kind: "message", T: () => import_executed_transaction.ExecutedTransaction },
      {
        no: 2,
        name: "outputs",
        kind: "message",
        repeat: 2,
        T: () => CommandResult
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.outputs = [];
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.ExecutedTransaction transaction */
        1:
          message.transaction = import_executed_transaction.ExecutedTransaction.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.transaction
          );
          break;
        case /* repeated sui.rpc.v2beta2.CommandResult outputs */
        2:
          message.outputs.push(CommandResult.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      import_executed_transaction.ExecutedTransaction.internalBinaryWrite(
        message.transaction,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.outputs.length; i++)
      CommandResult.internalBinaryWrite(
        message.outputs[i],
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const SimulateTransactionResponse = new SimulateTransactionResponse$Type();
class CommandResult$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CommandResult", [
      {
        no: 1,
        name: "return_values",
        kind: "message",
        repeat: 2,
        T: () => CommandOutput
      },
      {
        no: 2,
        name: "mutated_by_ref",
        kind: "message",
        repeat: 2,
        T: () => CommandOutput
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.returnValues = [];
    message.mutatedByRef = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.CommandOutput return_values */
        1:
          message.returnValues.push(
            CommandOutput.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* repeated sui.rpc.v2beta2.CommandOutput mutated_by_ref */
        2:
          message.mutatedByRef.push(
            CommandOutput.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.returnValues.length; i++)
      CommandOutput.internalBinaryWrite(
        message.returnValues[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    for (let i = 0; i < message.mutatedByRef.length; i++)
      CommandOutput.internalBinaryWrite(
        message.mutatedByRef[i],
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommandResult = new CommandResult$Type();
class CommandOutput$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.CommandOutput", [
      { no: 1, name: "argument", kind: "message", T: () => import_argument.Argument },
      { no: 2, name: "value", kind: "message", T: () => import_bcs.Bcs },
      { no: 3, name: "json", kind: "message", T: () => import_struct.Value }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Argument argument */
        1:
          message.argument = import_argument.Argument.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.argument
          );
          break;
        case /* optional sui.rpc.v2beta2.Bcs value */
        2:
          message.value = import_bcs.Bcs.internalBinaryRead(reader, reader.uint32(), options, message.value);
          break;
        case /* optional google.protobuf.Value json */
        3:
          message.json = import_struct.Value.internalBinaryRead(reader, reader.uint32(), options, message.json);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.argument)
      import_argument.Argument.internalBinaryWrite(
        message.argument,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.value)
      import_bcs.Bcs.internalBinaryWrite(
        message.value,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.json)
      import_struct.Value.internalBinaryWrite(
        message.json,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CommandOutput = new CommandOutput$Type();
class ListOwnedObjectsRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ListOwnedObjectsRequest", [
      {
        no: 1,
        name: "owner",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "page_size",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "page_token",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask },
      {
        no: 5,
        name: "object_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string owner */
        1:
          message.owner = reader.string();
          break;
        case /* optional uint32 page_size */
        2:
          message.pageSize = reader.uint32();
          break;
        case /* optional bytes page_token */
        3:
          message.pageToken = reader.bytes();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        4:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        case /* optional string object_type */
        5:
          message.objectType = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.owner !== void 0) writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.owner);
    if (message.pageSize !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint32(message.pageSize);
    if (message.pageToken !== void 0)
      writer.tag(3, import_runtime.WireType.LengthDelimited).bytes(message.pageToken);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(4, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.objectType !== void 0)
      writer.tag(5, import_runtime.WireType.LengthDelimited).string(message.objectType);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListOwnedObjectsRequest = new ListOwnedObjectsRequest$Type();
class ListOwnedObjectsResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.ListOwnedObjectsResponse", [
      {
        no: 1,
        name: "objects",
        kind: "message",
        repeat: 2,
        T: () => import_object.Object
      },
      {
        no: 2,
        name: "next_page_token",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.Object objects */
        1:
          message.objects.push(import_object.Object.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional bytes next_page_token */
        2:
          message.nextPageToken = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      import_object.Object.internalBinaryWrite(
        message.objects[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.nextPageToken !== void 0)
      writer.tag(2, import_runtime.WireType.LengthDelimited).bytes(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListOwnedObjectsResponse = new ListOwnedObjectsResponse$Type();
const LiveDataService = new import_runtime_rpc.ServiceType("sui.rpc.v2beta2.LiveDataService", [
  {
    name: "ListDynamicFields",
    options: {},
    I: ListDynamicFieldsRequest,
    O: ListDynamicFieldsResponse
  },
  {
    name: "ListOwnedObjects",
    options: {},
    I: ListOwnedObjectsRequest,
    O: ListOwnedObjectsResponse
  },
  { name: "GetCoinInfo", options: {}, I: GetCoinInfoRequest, O: GetCoinInfoResponse },
  { name: "GetBalance", options: {}, I: GetBalanceRequest, O: GetBalanceResponse },
  { name: "ListBalances", options: {}, I: ListBalancesRequest, O: ListBalancesResponse },
  {
    name: "SimulateTransaction",
    options: {},
    I: SimulateTransactionRequest,
    O: SimulateTransactionResponse
  }
]);
//# sourceMappingURL=live_data_service.js.map
