import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
import { SignatureScheme } from './signature_scheme.js';
import { Bcs } from './bcs.js';
/**
 * A signature from a user.
 *
 * @generated from protobuf message sui.rpc.v2beta2.UserSignature
 */
export interface UserSignature {
    /**
     * This signature serialized as as BCS.
     *
     * When provided as input this will support both the form that is length
     * prefixed as well as not length prefixed.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.Bcs bcs = 1
     */
    bcs?: Bcs;
    /**
     * The signature scheme of this signature.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.SignatureScheme scheme = 2
     */
    scheme?: SignatureScheme;
    /**
     * @generated from protobuf oneof: signature
     */
    signature: {
        oneofKind: 'simple';
        /**
         * Simple signature if scheme is ed25519 | secp256k1 | secp256r1.
         *
         * @generated from protobuf field: sui.rpc.v2beta2.SimpleSignature simple = 3
         */
        simple: SimpleSignature;
    } | {
        oneofKind: 'multisig';
        /**
         * The multisig aggregated signature if scheme is `MULTISIG`.
         *
         * @generated from protobuf field: sui.rpc.v2beta2.MultisigAggregatedSignature multisig = 4
         */
        multisig: MultisigAggregatedSignature;
    } | {
        oneofKind: 'zklogin';
        /**
         * The zklogin authenticator if scheme is `ZKLOGIN`.
         *
         * @generated from protobuf field: sui.rpc.v2beta2.ZkLoginAuthenticator zklogin = 5
         */
        zklogin: ZkLoginAuthenticator;
    } | {
        oneofKind: 'passkey';
        /**
         * The passkey authenticator if scheme is `PASSKEY`.
         *
         * @generated from protobuf field: sui.rpc.v2beta2.PasskeyAuthenticator passkey = 6
         */
        passkey: PasskeyAuthenticator;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Either an ed25519, secp256k1 or secp256r1 signature
 *
 * @generated from protobuf message sui.rpc.v2beta2.SimpleSignature
 */
export interface SimpleSignature {
    /**
     * The signature scheme of this signature.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.SignatureScheme scheme = 1
     */
    scheme?: SignatureScheme;
    /**
     * Signature bytes
     *
     * @generated from protobuf field: optional bytes signature = 2
     */
    signature?: Uint8Array;
    /**
     * Public key bytes
     *
     * @generated from protobuf field: optional bytes public_key = 3
     */
    publicKey?: Uint8Array;
}
/**
 * Public key equivalent for zklogin authenticators.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ZkLoginPublicIdentifier
 */
export interface ZkLoginPublicIdentifier {
    /**
     * @generated from protobuf field: optional string iss = 1
     */
    iss?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string address_seed = 2
     */
    addressSeed?: string;
}
/**
 * Set of valid public keys for multisig committee members.
 *
 * @generated from protobuf message sui.rpc.v2beta2.MultisigMemberPublicKey
 */
export interface MultisigMemberPublicKey {
    /**
     * The signature scheme of this public key.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.SignatureScheme scheme = 1
     */
    scheme?: SignatureScheme;
    /**
     * Public key bytes if scheme is ed25519 | secp256k1 | secp256r1 | passkey.
     *
     * @generated from protobuf field: optional bytes public_key = 2
     */
    publicKey?: Uint8Array;
    /**
     * A zklogin public identifier if scheme is zklogin.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.ZkLoginPublicIdentifier zklogin = 3
     */
    zklogin?: ZkLoginPublicIdentifier;
}
/**
 * A member in a multisig committee.
 *
 * @generated from protobuf message sui.rpc.v2beta2.MultisigMember
 */
export interface MultisigMember {
    /**
     * The public key of the committee member.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.MultisigMemberPublicKey public_key = 1
     */
    publicKey?: MultisigMemberPublicKey;
    /**
     * The weight of this member's signature.
     *
     * @generated from protobuf field: optional uint32 weight = 2
     */
    weight?: number;
}
/**
 * A multisig committee.
 *
 * @generated from protobuf message sui.rpc.v2beta2.MultisigCommittee
 */
export interface MultisigCommittee {
    /**
     * A list of committee members and their corresponding weight.
     *
     * @generated from protobuf field: repeated sui.rpc.v2beta2.MultisigMember members = 1
     */
    members: MultisigMember[];
    /**
     * The threshold of signatures needed to validate a signature from
     * this committee.
     *
     * @generated from protobuf field: optional uint32 threshold = 2
     */
    threshold?: number;
}
/**
 * Aggregated signature from members of a multisig committee.
 *
 * @generated from protobuf message sui.rpc.v2beta2.MultisigAggregatedSignature
 */
export interface MultisigAggregatedSignature {
    /**
     * The plain signatures encoded with signature scheme.
     *
     * The signatures must be in the same order as they are listed in the committee.
     *
     * @generated from protobuf field: repeated sui.rpc.v2beta2.MultisigMemberSignature signatures = 1
     */
    signatures: MultisigMemberSignature[];
    /**
     * Bitmap indicating which committee members contributed to the
     * signature.
     *
     * @generated from protobuf field: optional uint32 bitmap = 2
     */
    bitmap?: number;
    /**
     * If present, means this signature's on-chain format uses the old
     * legacy multisig format.
     *
     * @generated from protobuf field: repeated uint32 legacy_bitmap = 3
     */
    legacyBitmap: number[];
    /**
     * The committee to use to validate this signature.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.MultisigCommittee committee = 4
     */
    committee?: MultisigCommittee;
}
/**
 * A signature from a member of a multisig committee.
 *
 * @generated from protobuf message sui.rpc.v2beta2.MultisigMemberSignature
 */
export interface MultisigMemberSignature {
    /**
     * The signature scheme of this signature.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.SignatureScheme scheme = 1
     */
    scheme?: SignatureScheme;
    /**
     * Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
     *
     * @generated from protobuf field: optional bytes signature = 2
     */
    signature?: Uint8Array;
    /**
     * The zklogin authenticator if scheme is `ZKLOGIN`.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.ZkLoginAuthenticator zklogin = 3
     */
    zklogin?: ZkLoginAuthenticator;
    /**
     * The passkey authenticator if scheme is `PASSKEY`.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.PasskeyAuthenticator passkey = 4
     */
    passkey?: PasskeyAuthenticator;
}
/**
 * A zklogin authenticator.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ZkLoginAuthenticator
 */
export interface ZkLoginAuthenticator {
    /**
     * Zklogin proof and inputs required to perform proof verification.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.ZkLoginInputs inputs = 1
     */
    inputs?: ZkLoginInputs;
    /**
     * Maximum epoch for which the proof is valid.
     *
     * @generated from protobuf field: optional uint64 max_epoch = 2
     */
    maxEpoch?: bigint;
    /**
     * User signature with the public key attested to by the provided proof.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.SimpleSignature signature = 3
     */
    signature?: SimpleSignature;
}
/**
 * A zklogin groth16 proof and the required inputs to perform proof verification.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ZkLoginInputs
 */
export interface ZkLoginInputs {
    /**
     * @generated from protobuf field: optional sui.rpc.v2beta2.ZkLoginProof proof_points = 1
     */
    proofPoints?: ZkLoginProof;
    /**
     * @generated from protobuf field: optional sui.rpc.v2beta2.ZkLoginClaim iss_base64_details = 2
     */
    issBase64Details?: ZkLoginClaim;
    /**
     * @generated from protobuf field: optional string header_base64 = 3
     */
    headerBase64?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string address_seed = 4
     */
    addressSeed?: string;
}
/**
 * A zklogin groth16 proof.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ZkLoginProof
 */
export interface ZkLoginProof {
    /**
     * @generated from protobuf field: optional sui.rpc.v2beta2.CircomG1 a = 1
     */
    a?: CircomG1;
    /**
     * @generated from protobuf field: optional sui.rpc.v2beta2.CircomG2 b = 2
     */
    b?: CircomG2;
    /**
     * @generated from protobuf field: optional sui.rpc.v2beta2.CircomG1 c = 3
     */
    c?: CircomG1;
}
/**
 * A claim of the iss in a zklogin proof.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ZkLoginClaim
 */
export interface ZkLoginClaim {
    /**
     * @generated from protobuf field: optional string value = 1
     */
    value?: string;
    /**
     * @generated from protobuf field: optional uint32 index_mod_4 = 2
     */
    indexMod4?: number;
}
/**
 * A G1 point.
 *
 * @generated from protobuf message sui.rpc.v2beta2.CircomG1
 */
export interface CircomG1 {
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e0 = 1
     */
    e0?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e1 = 2
     */
    e1?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e2 = 3
     */
    e2?: string;
}
/**
 * A G2 point.
 *
 * @generated from protobuf message sui.rpc.v2beta2.CircomG2
 */
export interface CircomG2 {
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e00 = 1
     */
    e00?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e01 = 2
     */
    e01?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e10 = 3
     */
    e10?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e11 = 4
     */
    e11?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e20 = 5
     */
    e20?: string;
    /**
     * base10 encoded Bn254FieldElement
     *
     * @generated from protobuf field: optional string e21 = 6
     */
    e21?: string;
}
/**
 * A passkey authenticator.
 *
 * See
 * [struct.PasskeyAuthenticator](https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs)
 * for more information on the requirements on the shape of the
 * `client_data_json` field.
 *
 * @generated from protobuf message sui.rpc.v2beta2.PasskeyAuthenticator
 */
export interface PasskeyAuthenticator {
    /**
     * Opaque authenticator data for this passkey signature.
     *
     * See [Authenticator Data](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) for
     * more information on this field.
     *
     * @generated from protobuf field: optional bytes authenticator_data = 1
     */
    authenticatorData?: Uint8Array;
    /**
     * Structured, unparsed, JSON for this passkey signature.
     *
     * See [CollectedClientData](https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata)
     * for more information on this field.
     *
     * @generated from protobuf field: optional string client_data_json = 2
     */
    clientDataJson?: string;
    /**
     * A secp256r1 signature.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.SimpleSignature signature = 3
     */
    signature?: SimpleSignature;
}
/**
 * The validator set for a particular epoch.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ValidatorCommittee
 */
export interface ValidatorCommittee {
    /**
     * The epoch where this committee governs.
     *
     * @generated from protobuf field: optional uint64 epoch = 1
     */
    epoch?: bigint;
    /**
     * The committee members.
     *
     * @generated from protobuf field: repeated sui.rpc.v2beta2.ValidatorCommitteeMember members = 2
     */
    members: ValidatorCommitteeMember[];
}
/**
 * A member of a validator committee.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ValidatorCommitteeMember
 */
export interface ValidatorCommitteeMember {
    /**
     * The 96-byte Bls12381 public key for this validator.
     *
     * @generated from protobuf field: optional bytes public_key = 1
     */
    publicKey?: Uint8Array;
    /**
     * voting weight this validator possesses.
     *
     * @generated from protobuf field: optional uint64 weight = 2
     */
    weight?: bigint;
}
/**
 * / An aggregated signature from multiple validators.
 *
 * @generated from protobuf message sui.rpc.v2beta2.ValidatorAggregatedSignature
 */
export interface ValidatorAggregatedSignature {
    /**
     * The epoch when this signature was produced.
     *
     * This can be used to lookup the `ValidatorCommittee` from this epoch
     * to verify this signature.
     *
     * @generated from protobuf field: optional uint64 epoch = 1
     */
    epoch?: bigint;
    /**
     * The 48-byte Bls12381 aggregated signature.
     *
     * @generated from protobuf field: optional bytes signature = 2
     */
    signature?: Uint8Array;
    /**
     * Bitmap indicating which members of the committee contributed to
     * this signature.
     *
     * @generated from protobuf field: repeated uint32 bitmap = 3
     */
    bitmap: number[];
}
declare class UserSignature$Type extends MessageType<UserSignature> {
    constructor();
    create(value?: PartialMessage<UserSignature>): UserSignature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserSignature): UserSignature;
    internalBinaryWrite(message: UserSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.UserSignature
 */
export declare const UserSignature: UserSignature$Type;
declare class SimpleSignature$Type extends MessageType<SimpleSignature> {
    constructor();
    create(value?: PartialMessage<SimpleSignature>): SimpleSignature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleSignature): SimpleSignature;
    internalBinaryWrite(message: SimpleSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.SimpleSignature
 */
export declare const SimpleSignature: SimpleSignature$Type;
declare class ZkLoginPublicIdentifier$Type extends MessageType<ZkLoginPublicIdentifier> {
    constructor();
    create(value?: PartialMessage<ZkLoginPublicIdentifier>): ZkLoginPublicIdentifier;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZkLoginPublicIdentifier): ZkLoginPublicIdentifier;
    internalBinaryWrite(message: ZkLoginPublicIdentifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ZkLoginPublicIdentifier
 */
export declare const ZkLoginPublicIdentifier: ZkLoginPublicIdentifier$Type;
declare class MultisigMemberPublicKey$Type extends MessageType<MultisigMemberPublicKey> {
    constructor();
    create(value?: PartialMessage<MultisigMemberPublicKey>): MultisigMemberPublicKey;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultisigMemberPublicKey): MultisigMemberPublicKey;
    internalBinaryWrite(message: MultisigMemberPublicKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.MultisigMemberPublicKey
 */
export declare const MultisigMemberPublicKey: MultisigMemberPublicKey$Type;
declare class MultisigMember$Type extends MessageType<MultisigMember> {
    constructor();
    create(value?: PartialMessage<MultisigMember>): MultisigMember;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultisigMember): MultisigMember;
    internalBinaryWrite(message: MultisigMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.MultisigMember
 */
export declare const MultisigMember: MultisigMember$Type;
declare class MultisigCommittee$Type extends MessageType<MultisigCommittee> {
    constructor();
    create(value?: PartialMessage<MultisigCommittee>): MultisigCommittee;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultisigCommittee): MultisigCommittee;
    internalBinaryWrite(message: MultisigCommittee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.MultisigCommittee
 */
export declare const MultisigCommittee: MultisigCommittee$Type;
declare class MultisigAggregatedSignature$Type extends MessageType<MultisigAggregatedSignature> {
    constructor();
    create(value?: PartialMessage<MultisigAggregatedSignature>): MultisigAggregatedSignature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultisigAggregatedSignature): MultisigAggregatedSignature;
    internalBinaryWrite(message: MultisigAggregatedSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.MultisigAggregatedSignature
 */
export declare const MultisigAggregatedSignature: MultisigAggregatedSignature$Type;
declare class MultisigMemberSignature$Type extends MessageType<MultisigMemberSignature> {
    constructor();
    create(value?: PartialMessage<MultisigMemberSignature>): MultisigMemberSignature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultisigMemberSignature): MultisigMemberSignature;
    internalBinaryWrite(message: MultisigMemberSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.MultisigMemberSignature
 */
export declare const MultisigMemberSignature: MultisigMemberSignature$Type;
declare class ZkLoginAuthenticator$Type extends MessageType<ZkLoginAuthenticator> {
    constructor();
    create(value?: PartialMessage<ZkLoginAuthenticator>): ZkLoginAuthenticator;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZkLoginAuthenticator): ZkLoginAuthenticator;
    internalBinaryWrite(message: ZkLoginAuthenticator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ZkLoginAuthenticator
 */
export declare const ZkLoginAuthenticator: ZkLoginAuthenticator$Type;
declare class ZkLoginInputs$Type extends MessageType<ZkLoginInputs> {
    constructor();
    create(value?: PartialMessage<ZkLoginInputs>): ZkLoginInputs;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZkLoginInputs): ZkLoginInputs;
    internalBinaryWrite(message: ZkLoginInputs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ZkLoginInputs
 */
export declare const ZkLoginInputs: ZkLoginInputs$Type;
declare class ZkLoginProof$Type extends MessageType<ZkLoginProof> {
    constructor();
    create(value?: PartialMessage<ZkLoginProof>): ZkLoginProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZkLoginProof): ZkLoginProof;
    internalBinaryWrite(message: ZkLoginProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ZkLoginProof
 */
export declare const ZkLoginProof: ZkLoginProof$Type;
declare class ZkLoginClaim$Type extends MessageType<ZkLoginClaim> {
    constructor();
    create(value?: PartialMessage<ZkLoginClaim>): ZkLoginClaim;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZkLoginClaim): ZkLoginClaim;
    internalBinaryWrite(message: ZkLoginClaim, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ZkLoginClaim
 */
export declare const ZkLoginClaim: ZkLoginClaim$Type;
declare class CircomG1$Type extends MessageType<CircomG1> {
    constructor();
    create(value?: PartialMessage<CircomG1>): CircomG1;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CircomG1): CircomG1;
    internalBinaryWrite(message: CircomG1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.CircomG1
 */
export declare const CircomG1: CircomG1$Type;
declare class CircomG2$Type extends MessageType<CircomG2> {
    constructor();
    create(value?: PartialMessage<CircomG2>): CircomG2;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CircomG2): CircomG2;
    internalBinaryWrite(message: CircomG2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.CircomG2
 */
export declare const CircomG2: CircomG2$Type;
declare class PasskeyAuthenticator$Type extends MessageType<PasskeyAuthenticator> {
    constructor();
    create(value?: PartialMessage<PasskeyAuthenticator>): PasskeyAuthenticator;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasskeyAuthenticator): PasskeyAuthenticator;
    internalBinaryWrite(message: PasskeyAuthenticator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.PasskeyAuthenticator
 */
export declare const PasskeyAuthenticator: PasskeyAuthenticator$Type;
declare class ValidatorCommittee$Type extends MessageType<ValidatorCommittee> {
    constructor();
    create(value?: PartialMessage<ValidatorCommittee>): ValidatorCommittee;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorCommittee): ValidatorCommittee;
    internalBinaryWrite(message: ValidatorCommittee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ValidatorCommittee
 */
export declare const ValidatorCommittee: ValidatorCommittee$Type;
declare class ValidatorCommitteeMember$Type extends MessageType<ValidatorCommitteeMember> {
    constructor();
    create(value?: PartialMessage<ValidatorCommitteeMember>): ValidatorCommitteeMember;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorCommitteeMember): ValidatorCommitteeMember;
    internalBinaryWrite(message: ValidatorCommitteeMember, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ValidatorCommitteeMember
 */
export declare const ValidatorCommitteeMember: ValidatorCommitteeMember$Type;
declare class ValidatorAggregatedSignature$Type extends MessageType<ValidatorAggregatedSignature> {
    constructor();
    create(value?: PartialMessage<ValidatorAggregatedSignature>): ValidatorAggregatedSignature;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorAggregatedSignature): ValidatorAggregatedSignature;
    internalBinaryWrite(message: ValidatorAggregatedSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.ValidatorAggregatedSignature
 */
export declare const ValidatorAggregatedSignature: ValidatorAggregatedSignature$Type;
export {};
