import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
import { ExecutedTransaction } from './executed_transaction.js';
import { CheckpointContents } from './checkpoint_contents.js';
import { ValidatorAggregatedSignature } from './signature.js';
import { CheckpointSummary } from './checkpoint_summary.js';
/**
 * @generated from protobuf message sui.rpc.v2beta2.Checkpoint
 */
export interface Checkpoint {
    /**
     * The height of this checkpoint.
     *
     * @generated from protobuf field: optional uint64 sequence_number = 1
     */
    sequenceNumber?: bigint;
    /**
     * The digest of this Checkpoint's CheckpointSummary.
     *
     * @generated from protobuf field: optional string digest = 2
     */
    digest?: string;
    /**
     * The `CheckpointSummary` for this checkpoint.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.CheckpointSummary summary = 3
     */
    summary?: CheckpointSummary;
    /**
     * An aggregated quorum signature from the validator committee that
     * certified this checkpoint.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.ValidatorAggregatedSignature signature = 4
     */
    signature?: ValidatorAggregatedSignature;
    /**
     * The `CheckpointContents` for this checkpoint.
     *
     * @generated from protobuf field: optional sui.rpc.v2beta2.CheckpointContents contents = 5
     */
    contents?: CheckpointContents;
    /**
     * List of transactions included in this checkpoint.
     *
     * @generated from protobuf field: repeated sui.rpc.v2beta2.ExecutedTransaction transactions = 6
     */
    transactions: ExecutedTransaction[];
}
declare class Checkpoint$Type extends MessageType<Checkpoint> {
    constructor();
    create(value?: PartialMessage<Checkpoint>): Checkpoint;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Checkpoint): Checkpoint;
    internalBinaryWrite(message: Checkpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message sui.rpc.v2beta2.Checkpoint
 */
export declare const Checkpoint: Checkpoint$Type;
export {};
