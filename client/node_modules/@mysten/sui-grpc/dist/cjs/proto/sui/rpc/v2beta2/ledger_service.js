"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ledger_service_exports = {};
__export(ledger_service_exports, {
  BatchGetObjectsRequest: () => BatchGetObjectsRequest,
  BatchGetObjectsResponse: () => BatchGetObjectsResponse,
  BatchGetTransactionsRequest: () => BatchGetTransactionsRequest,
  BatchGetTransactionsResponse: () => BatchGetTransactionsResponse,
  GetCheckpointRequest: () => GetCheckpointRequest,
  GetCheckpointResponse: () => GetCheckpointResponse,
  GetEpochRequest: () => GetEpochRequest,
  GetEpochResponse: () => GetEpochResponse,
  GetObjectRequest: () => GetObjectRequest,
  GetObjectResponse: () => GetObjectResponse,
  GetObjectResult: () => GetObjectResult,
  GetServiceInfoRequest: () => GetServiceInfoRequest,
  GetServiceInfoResponse: () => GetServiceInfoResponse,
  GetTransactionRequest: () => GetTransactionRequest,
  GetTransactionResponse: () => GetTransactionResponse,
  GetTransactionResult: () => GetTransactionResult,
  LedgerService: () => LedgerService
});
module.exports = __toCommonJS(ledger_service_exports);
var import_runtime_rpc = require("@protobuf-ts/runtime-rpc");
var import_runtime = require("@protobuf-ts/runtime");
var import_runtime2 = require("@protobuf-ts/runtime");
var import_runtime3 = require("@protobuf-ts/runtime");
var import_runtime4 = require("@protobuf-ts/runtime");
var import_epoch = require("./epoch.js");
var import_checkpoint = require("./checkpoint.js");
var import_executed_transaction = require("./executed_transaction.js");
var import_status = require("../../../google/rpc/status.js");
var import_object = require("./object.js");
var import_field_mask = require("../../../google/protobuf/field_mask.js");
var import_timestamp = require("../../../google/protobuf/timestamp.js");
class GetServiceInfoRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetServiceInfoRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetServiceInfoRequest = new GetServiceInfoRequest$Type();
class GetServiceInfoResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetServiceInfoResponse", [
      {
        no: 1,
        name: "chain_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "chain",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 4,
        name: "checkpoint_height",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 5, name: "timestamp", kind: "message", T: () => import_timestamp.Timestamp },
      {
        no: 6,
        name: "lowest_available_checkpoint",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 7,
        name: "lowest_available_checkpoint_objects",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      {
        no: 8,
        name: "server",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string chain_id */
        1:
          message.chainId = reader.string();
          break;
        case /* optional string chain */
        2:
          message.chain = reader.string();
          break;
        case /* optional uint64 epoch */
        3:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional uint64 checkpoint_height */
        4:
          message.checkpointHeight = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.Timestamp timestamp */
        5:
          message.timestamp = import_timestamp.Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp
          );
          break;
        case /* optional uint64 lowest_available_checkpoint */
        6:
          message.lowestAvailableCheckpoint = reader.uint64().toBigInt();
          break;
        case /* optional uint64 lowest_available_checkpoint_objects */
        7:
          message.lowestAvailableCheckpointObjects = reader.uint64().toBigInt();
          break;
        case /* optional string server */
        8:
          message.server = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.chainId !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.chainId);
    if (message.chain !== void 0) writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.chain);
    if (message.epoch !== void 0) writer.tag(3, import_runtime.WireType.Varint).uint64(message.epoch);
    if (message.checkpointHeight !== void 0)
      writer.tag(4, import_runtime.WireType.Varint).uint64(message.checkpointHeight);
    if (message.timestamp)
      import_timestamp.Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(5, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.lowestAvailableCheckpoint !== void 0)
      writer.tag(6, import_runtime.WireType.Varint).uint64(message.lowestAvailableCheckpoint);
    if (message.lowestAvailableCheckpointObjects !== void 0)
      writer.tag(7, import_runtime.WireType.Varint).uint64(message.lowestAvailableCheckpointObjects);
    if (message.server !== void 0)
      writer.tag(8, import_runtime.WireType.LengthDelimited).string(message.server);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetServiceInfoResponse = new GetServiceInfoResponse$Type();
class GetObjectRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetObjectRequest", [
      {
        no: 1,
        name: "object_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 3, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string object_id */
        1:
          message.objectId = reader.string();
          break;
        case /* optional uint64 version */
        2:
          message.version = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        3:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.objectId !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.objectId);
    if (message.version !== void 0) writer.tag(2, import_runtime.WireType.Varint).uint64(message.version);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetObjectRequest = new GetObjectRequest$Type();
class GetObjectResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetObjectResponse", [
      { no: 1, name: "object", kind: "message", T: () => import_object.Object }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Object object */
        1:
          message.object = import_object.Object.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.object
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.object)
      import_object.Object.internalBinaryWrite(
        message.object,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetObjectResponse = new GetObjectResponse$Type();
class BatchGetObjectsRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetObjectsRequest", [
      {
        no: 1,
        name: "requests",
        kind: "message",
        repeat: 2,
        T: () => GetObjectRequest
      },
      { no: 2, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.requests = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.GetObjectRequest requests */
        1:
          message.requests.push(
            GetObjectRequest.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.requests.length; i++)
      GetObjectRequest.internalBinaryWrite(
        message.requests[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetObjectsRequest = new BatchGetObjectsRequest$Type();
class BatchGetObjectsResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetObjectsResponse", [
      {
        no: 1,
        name: "objects",
        kind: "message",
        repeat: 2,
        T: () => GetObjectResult
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.objects = [];
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.GetObjectResult objects */
        1:
          message.objects.push(
            GetObjectResult.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.objects.length; i++)
      GetObjectResult.internalBinaryWrite(
        message.objects[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetObjectsResponse = new BatchGetObjectsResponse$Type();
class GetObjectResult$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetObjectResult", [
      { no: 1, name: "object", kind: "message", oneof: "result", T: () => import_object.Object },
      { no: 2, name: "error", kind: "message", oneof: "result", T: () => import_status.Status }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = { oneofKind: void 0 };
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.Object object */
        1:
          message.result = {
            oneofKind: "object",
            object: import_object.Object.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.object
            )
          };
          break;
        case /* google.rpc.Status error */
        2:
          message.result = {
            oneofKind: "error",
            error: import_status.Status.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.error
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result.oneofKind === "object")
      import_object.Object.internalBinaryWrite(
        message.result.object,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.result.oneofKind === "error")
      import_status.Status.internalBinaryWrite(
        message.result.error,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetObjectResult = new GetObjectResult$Type();
class GetTransactionRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetTransactionRequest", [
      {
        no: 1,
        name: "digest",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string digest */
        1:
          message.digest = reader.string();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.digest !== void 0)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.digest);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTransactionRequest = new GetTransactionRequest$Type();
class GetTransactionResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetTransactionResponse", [
      { no: 1, name: "transaction", kind: "message", T: () => import_executed_transaction.ExecutedTransaction }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.ExecutedTransaction transaction */
        1:
          message.transaction = import_executed_transaction.ExecutedTransaction.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.transaction
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.transaction)
      import_executed_transaction.ExecutedTransaction.internalBinaryWrite(
        message.transaction,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTransactionResponse = new GetTransactionResponse$Type();
class BatchGetTransactionsRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetTransactionsRequest", [
      {
        no: 1,
        name: "digests",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      { no: 2, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.digests = [];
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string digests */
        1:
          message.digests.push(reader.string());
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.digests.length; i++)
      writer.tag(1, import_runtime.WireType.LengthDelimited).string(message.digests[i]);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetTransactionsRequest = new BatchGetTransactionsRequest$Type();
class BatchGetTransactionsResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.BatchGetTransactionsResponse", [
      {
        no: 1,
        name: "transactions",
        kind: "message",
        repeat: 2,
        T: () => GetTransactionResult
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.transactions = [];
    if (value !== void 0)
      (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated sui.rpc.v2beta2.GetTransactionResult transactions */
        1:
          message.transactions.push(
            GetTransactionResult.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.transactions.length; i++)
      GetTransactionResult.internalBinaryWrite(
        message.transactions[i],
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const BatchGetTransactionsResponse = new BatchGetTransactionsResponse$Type();
class GetTransactionResult$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetTransactionResult", [
      {
        no: 1,
        name: "transaction",
        kind: "message",
        oneof: "result",
        T: () => import_executed_transaction.ExecutedTransaction
      },
      { no: 2, name: "error", kind: "message", oneof: "result", T: () => import_status.Status }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.result = { oneofKind: void 0 };
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sui.rpc.v2beta2.ExecutedTransaction transaction */
        1:
          message.result = {
            oneofKind: "transaction",
            transaction: import_executed_transaction.ExecutedTransaction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.transaction
            )
          };
          break;
        case /* google.rpc.Status error */
        2:
          message.result = {
            oneofKind: "error",
            error: import_status.Status.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.result.error
            )
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.result.oneofKind === "transaction")
      import_executed_transaction.ExecutedTransaction.internalBinaryWrite(
        message.result.transaction,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    if (message.result.oneofKind === "error")
      import_status.Status.internalBinaryWrite(
        message.result.error,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetTransactionResult = new GetTransactionResult$Type();
class GetCheckpointRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetCheckpointRequest", [
      {
        no: 1,
        name: "sequence_number",
        kind: "scalar",
        oneof: "checkpointId",
        T: 4,
        L: 0
      },
      {
        no: 2,
        name: "digest",
        kind: "scalar",
        oneof: "checkpointId",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.checkpointId = { oneofKind: void 0 };
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 sequence_number */
        1:
          message.checkpointId = {
            oneofKind: "sequenceNumber",
            sequenceNumber: reader.uint64().toBigInt()
          };
          break;
        case /* string digest */
        2:
          message.checkpointId = {
            oneofKind: "digest",
            digest: reader.string()
          };
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        3:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.checkpointId.oneofKind === "sequenceNumber")
      writer.tag(1, import_runtime.WireType.Varint).uint64(message.checkpointId.sequenceNumber);
    if (message.checkpointId.oneofKind === "digest")
      writer.tag(2, import_runtime.WireType.LengthDelimited).string(message.checkpointId.digest);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(3, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCheckpointRequest = new GetCheckpointRequest$Type();
class GetCheckpointResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetCheckpointResponse", [
      { no: 1, name: "checkpoint", kind: "message", T: () => import_checkpoint.Checkpoint }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Checkpoint checkpoint */
        1:
          message.checkpoint = import_checkpoint.Checkpoint.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.checkpoint
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.checkpoint)
      import_checkpoint.Checkpoint.internalBinaryWrite(
        message.checkpoint,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetCheckpointResponse = new GetCheckpointResponse$Type();
class GetEpochRequest$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetEpochRequest", [
      {
        no: 1,
        name: "epoch",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 0
      },
      { no: 2, name: "read_mask", kind: "message", T: () => import_field_mask.FieldMask }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional uint64 epoch */
        1:
          message.epoch = reader.uint64().toBigInt();
          break;
        case /* optional google.protobuf.FieldMask read_mask */
        2:
          message.readMask = import_field_mask.FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.readMask
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch !== void 0) writer.tag(1, import_runtime.WireType.Varint).uint64(message.epoch);
    if (message.readMask)
      import_field_mask.FieldMask.internalBinaryWrite(
        message.readMask,
        writer.tag(2, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetEpochRequest = new GetEpochRequest$Type();
class GetEpochResponse$Type extends import_runtime4.MessageType {
  constructor() {
    super("sui.rpc.v2beta2.GetEpochResponse", [
      { no: 1, name: "epoch", kind: "message", T: () => import_epoch.Epoch }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0) (0, import_runtime3.reflectionMergePartial)(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional sui.rpc.v2beta2.Epoch epoch */
        1:
          message.epoch = import_epoch.Epoch.internalBinaryRead(reader, reader.uint32(), options, message.epoch);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? import_runtime2.UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.epoch)
      import_epoch.Epoch.internalBinaryWrite(
        message.epoch,
        writer.tag(1, import_runtime.WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? import_runtime2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetEpochResponse = new GetEpochResponse$Type();
const LedgerService = new import_runtime_rpc.ServiceType("sui.rpc.v2beta2.LedgerService", [
  { name: "GetServiceInfo", options: {}, I: GetServiceInfoRequest, O: GetServiceInfoResponse },
  { name: "GetObject", options: {}, I: GetObjectRequest, O: GetObjectResponse },
  { name: "BatchGetObjects", options: {}, I: BatchGetObjectsRequest, O: BatchGetObjectsResponse },
  { name: "GetTransaction", options: {}, I: GetTransactionRequest, O: GetTransactionResponse },
  {
    name: "BatchGetTransactions",
    options: {},
    I: BatchGetTransactionsRequest,
    O: BatchGetTransactionsResponse
  },
  { name: "GetCheckpoint", options: {}, I: GetCheckpointRequest, O: GetCheckpointResponse },
  { name: "GetEpoch", options: {}, I: GetEpochRequest, O: GetEpochResponse }
]);
//# sourceMappingURL=ledger_service.js.map
