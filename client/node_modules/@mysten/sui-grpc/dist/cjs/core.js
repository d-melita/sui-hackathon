"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var core_exports = {};
__export(core_exports, {
  GrpcCoreClient: () => GrpcCoreClient,
  parseTransactionEffects: () => parseTransactionEffects
});
module.exports = __toCommonJS(core_exports);
var import_experimental = require("@mysten/sui/experimental");
var import_owner = require("./proto/sui/rpc/v2beta2/owner.js");
var import_utils = require("@mysten/utils");
var import_effects = require("./proto/sui/rpc/v2beta2/effects.js");
var import_transactions = require("@mysten/sui/transactions");
var import_bcs = require("@mysten/sui/bcs");
var _client;
class GrpcCoreClient extends import_experimental.Experimental_CoreClient {
  constructor({ client, ...options }) {
    super(options);
    __privateAdd(this, _client);
    __privateSet(this, _client, client);
  }
  async getObjects(options) {
    const batches = (0, import_utils.chunk)(options.objectIds, 50);
    const results = [];
    for (const batch of batches) {
      const response = await __privateGet(this, _client).ledgerService.batchGetObjects({
        requests: batch.map((id) => ({ objectId: id })),
        readMask: {
          paths: ["owner", "object_type", "bcs", "digest", "version", "object_id"]
        }
      });
      results.push(
        ...response.response.objects.map(
          (object) => {
            if (object.result.oneofKind === "error") {
              return new Error(object.result.error.message);
            }
            if (object.result.oneofKind !== "object") {
              return new Error("Unexpected result type");
            }
            return {
              id: object.result.object.objectId,
              version: object.result.object.version?.toString(),
              digest: object.result.object.digest,
              // TODO: bcs content is not returned in all cases
              content: Promise.resolve(object.result.object.bcs?.value),
              owner: mapOwner(object.result.object.owner),
              type: object.result.object.objectType
            };
          }
        )
      );
    }
    return {
      objects: results
    };
  }
  async getOwnedObjects(options) {
    const response = await __privateGet(this, _client).liveDataService.listOwnedObjects({
      owner: options.address,
      objectType: options.type,
      pageToken: options.cursor ? (0, import_utils.fromBase64)(options.cursor) : void 0
    });
    const objects = response.response.objects.map(
      (object) => ({
        id: object.objectId,
        version: object.version?.toString(),
        digest: object.digest,
        // TODO: List owned objects doesn't return content right now
        get content() {
          return Promise.reject(
            new Error("GRPC does not return object contents when listing owned objects")
          );
        },
        owner: mapOwner(object.owner),
        type: object.objectType
      })
    );
    return {
      objects,
      cursor: response.response.nextPageToken ? (0, import_utils.toBase64)(response.response.nextPageToken) : null,
      hasNextPage: response.response.nextPageToken !== void 0
    };
  }
  async getCoins(options) {
    const response = await __privateGet(this, _client).liveDataService.listOwnedObjects({
      owner: options.address,
      objectType: `0x2::coin::Coin<${options.coinType}>`,
      pageToken: options.cursor ? (0, import_utils.fromBase64)(options.cursor) : void 0
    });
    return {
      objects: response.response.objects.map(
        (object) => ({
          id: object.objectId,
          version: object.version?.toString(),
          digest: object.digest,
          // TODO: List owned objects doesn't return content right now
          get content() {
            return Promise.reject(
              new Error("GRPC does not return object contents when listing owned objects")
            );
          },
          owner: mapOwner(object.owner),
          type: object.objectType,
          balance: object.balance?.toString()
        })
      ),
      cursor: response.response.nextPageToken ? (0, import_utils.toBase64)(response.response.nextPageToken) : null,
      hasNextPage: response.response.nextPageToken !== void 0
    };
  }
  async getBalance(_options) {
    throw new Error("Not implemented");
  }
  async getAllBalances(_options) {
    throw new Error("Not implemented");
  }
  async getTransaction(options) {
    const { response } = await __privateGet(this, _client).ledgerService.getTransaction({
      digest: options.digest,
      readMask: {
        paths: ["digest", "transaction", "effects", "signatures"]
      }
    });
    return {
      transaction: parseTransaction(response.transaction)
    };
  }
  async executeTransaction(options) {
    const { response } = await __privateGet(this, _client).transactionExecutionService.executeTransaction({
      transaction: {
        bcs: {
          value: options.transaction
        }
      },
      signatures: options.signatures.map((signature) => ({
        bcs: {
          value: (0, import_utils.fromBase64)(signature)
        },
        signature: {
          oneofKind: void 0
        }
      })),
      readMask: {
        paths: [
          "transaction.digest",
          "transaction.transaction",
          "transaction.effects",
          "transaction.signatures"
        ]
      }
    });
    return {
      transaction: parseTransaction(response.transaction)
    };
  }
  async dryRunTransaction(options) {
    const { response } = await __privateGet(this, _client).liveDataService.simulateTransaction({
      transaction: {
        bcs: {
          value: options.transaction
        }
      },
      readMask: {
        paths: [
          "transaction.digest",
          "transaction.transaction",
          "transaction.effects",
          "transaction.signatures"
        ]
      }
    });
    return {
      transaction: parseTransaction(response.transaction)
    };
  }
  async getReferenceGasPrice() {
    const response = await __privateGet(this, _client).ledgerService.getEpoch({});
    return {
      referenceGasPrice: response.response.epoch?.referenceGasPrice?.toString()
    };
  }
  async getDynamicFields(options) {
    const response = await __privateGet(this, _client).liveDataService.listDynamicFields({
      parent: options.parentId,
      pageToken: options.cursor ? (0, import_utils.fromBase64)(options.cursor) : void 0
    });
    return {
      dynamicFields: response.response.dynamicFields.map((field) => ({
        id: field.fieldId,
        name: {
          type: field.nameType,
          bcs: field.nameValue
        },
        type: field.dynamicObjectId ? `0x2::dynamic_field::Field<0x2::dynamic_object_field::Wrapper<${field.nameType}>,0x2::object::ID>` : `0x2::dynamic_field::Field<${field.nameType},${field.valueType}>`
      })),
      cursor: response.response.nextPageToken ? (0, import_utils.toBase64)(response.response.nextPageToken) : null,
      hasNextPage: response.response.nextPageToken !== void 0
    };
  }
  async verifyZkLoginSignature(options) {
    const { response } = await __privateGet(this, _client).signatureVerificationService.verifySignature({
      message: {
        name: options.intentScope,
        value: (0, import_utils.fromBase64)(options.bytes)
      },
      signature: {
        bcs: {
          value: (0, import_utils.fromBase64)(options.signature)
        },
        signature: {
          oneofKind: void 0
        }
      },
      jwks: []
    });
    return {
      success: response.isValid ?? false,
      errors: response.reason ? [response.reason] : []
    };
  }
  resolveTransactionPlugin() {
    throw new Error("GRPC client does not support transaction resolution yet");
  }
}
_client = new WeakMap();
function mapOwner(owner) {
  if (!owner) {
    return null;
  }
  if (owner.kind === import_owner.Owner_OwnerKind.IMMUTABLE) {
    return {
      $kind: "Immutable",
      Immutable: true
    };
  }
  if (owner.kind === import_owner.Owner_OwnerKind.ADDRESS) {
    return {
      AddressOwner: owner.address,
      $kind: "AddressOwner"
    };
  }
  if (owner.kind === import_owner.Owner_OwnerKind.OBJECT) {
    return {
      $kind: "ObjectOwner",
      ObjectOwner: owner.address
    };
  }
  if (owner.kind === import_owner.Owner_OwnerKind.SHARED) {
    if (owner.address) {
      return {
        $kind: "ConsensusAddressOwner",
        ConsensusAddressOwner: {
          owner: owner.address,
          startVersion: owner.version?.toString()
        }
      };
    }
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: owner.version?.toString()
      }
    };
  }
  throw new Error("Unknown owner kind");
}
function mapIdOperation(operation) {
  if (operation == null) {
    return null;
  }
  switch (operation) {
    case import_effects.ChangedObject_IdOperation.CREATED:
      return "Created";
    case import_effects.ChangedObject_IdOperation.DELETED:
      return "Deleted";
    case import_effects.ChangedObject_IdOperation.NONE:
    case import_effects.ChangedObject_IdOperation.ID_OPERATION_UNKNOWN:
      return "None";
    default:
      operation;
      return "Unknown";
  }
}
function mapInputObjectState(state) {
  if (state == null) {
    return null;
  }
  switch (state) {
    case import_effects.ChangedObject_InputObjectState.EXISTS:
      return "Exists";
    case import_effects.ChangedObject_InputObjectState.DOES_NOT_EXIST:
      return "DoesNotExist";
    case import_effects.ChangedObject_InputObjectState.UNKNOWN:
      return "Unknown";
    default:
      state;
      return "Unknown";
  }
}
function mapOutputObjectState(state) {
  if (state == null) {
    return null;
  }
  switch (state) {
    case import_effects.ChangedObject_OutputObjectState.OBJECT_WRITE:
      return "ObjectWrite";
    case import_effects.ChangedObject_OutputObjectState.PACKAGE_WRITE:
      return "PackageWrite";
    case import_effects.ChangedObject_OutputObjectState.DOES_NOT_EXIST:
      return "DoesNotExist";
    case import_effects.ChangedObject_OutputObjectState.UNKNOWN:
      return "Unknown";
    default:
      state;
      return "Unknown";
  }
}
function mapUnchangedSharedObjectKind(kind) {
  if (kind == null) {
    return null;
  }
  switch (kind) {
    case import_effects.UnchangedSharedObject_UnchangedSharedObjectKind.UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN:
      return "Unknown";
    case import_effects.UnchangedSharedObject_UnchangedSharedObjectKind.READ_ONLY_ROOT:
      return "ReadOnlyRoot";
    case import_effects.UnchangedSharedObject_UnchangedSharedObjectKind.MUTATE_CONSENSUS_STREAM_ENDED:
      return "MutateConsensusStreamEnded";
    case import_effects.UnchangedSharedObject_UnchangedSharedObjectKind.READ_CONSENSUS_STREAM_ENDED:
      return "ReadConsensusStreamEnded";
    case import_effects.UnchangedSharedObject_UnchangedSharedObjectKind.CANCELED:
      return "Cancelled";
    case import_effects.UnchangedSharedObject_UnchangedSharedObjectKind.PER_EPOCH_CONFIG:
      return "PerEpochConfig";
    default:
      kind;
      return "Unknown";
  }
}
function parseTransactionEffects({
  effects
}) {
  if (!effects) {
    return null;
  }
  const changedObjects = effects.changedObjects.map(
    (change) => {
      return {
        id: change.objectId,
        inputState: mapInputObjectState(change.inputState),
        inputVersion: change.inputVersion?.toString() ?? null,
        inputDigest: change.inputDigest ?? null,
        inputOwner: mapOwner(change.inputOwner),
        outputState: mapOutputObjectState(change.outputState),
        outputVersion: change.outputVersion?.toString() ?? null,
        outputDigest: change.outputDigest ?? null,
        outputOwner: mapOwner(change.outputOwner),
        idOperation: mapIdOperation(change.idOperation)
      };
    }
  );
  return {
    bcs: effects.bcs?.value,
    digest: effects.digest,
    version: 2,
    status: effects.status?.success ? {
      success: true,
      error: null
    } : {
      success: false,
      // TODO: parse errors properly
      error: JSON.stringify(effects.status?.error)
    },
    gasUsed: {
      computationCost: effects.gasUsed?.computationCost?.toString(),
      storageCost: effects.gasUsed?.storageCost?.toString(),
      storageRebate: effects.gasUsed?.storageRebate?.toString(),
      nonRefundableStorageFee: effects.gasUsed?.nonRefundableStorageFee?.toString()
    },
    transactionDigest: effects.transactionDigest,
    gasObject: {
      id: effects.gasObject?.objectId,
      inputState: mapInputObjectState(effects.gasObject?.inputState),
      inputVersion: effects.gasObject?.inputVersion?.toString() ?? null,
      inputDigest: effects.gasObject?.inputDigest ?? null,
      inputOwner: mapOwner(effects.gasObject?.inputOwner),
      outputState: mapOutputObjectState(effects.gasObject?.outputState),
      outputVersion: effects.gasObject?.outputVersion?.toString() ?? null,
      outputDigest: effects.gasObject?.outputDigest ?? null,
      outputOwner: mapOwner(effects.gasObject?.outputOwner),
      idOperation: mapIdOperation(effects.gasObject?.idOperation)
    },
    eventsDigest: effects.eventsDigest ?? null,
    dependencies: effects.dependencies,
    lamportVersion: effects.lamportVersion?.toString() ?? null,
    changedObjects,
    unchangedSharedObjects: effects.unchangedSharedObjects.map(
      (object) => {
        return {
          kind: mapUnchangedSharedObjectKind(object.kind),
          // TODO: we are inconsistent about id vs objectId
          objectId: object.objectId,
          version: object.version?.toString() ?? null,
          digest: object.digest ?? null
        };
      }
    ),
    auxiliaryDataDigest: effects.auxiliaryDataDigest ?? null
  };
}
function parseTransaction(transaction) {
  const parsedTx = import_bcs.bcs.SenderSignedData.parse(transaction.transaction?.bcs?.value)[0];
  const bytes = import_bcs.bcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes();
  const data = import_transactions.TransactionDataBuilder.restore({
    version: 2,
    sender: parsedTx.intentMessage.value.V1.sender,
    expiration: parsedTx.intentMessage.value.V1.expiration,
    gasData: parsedTx.intentMessage.value.V1.gasData,
    inputs: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,
    commands: parsedTx.intentMessage.value.V1.kind.ProgrammableTransaction.commands
  });
  const objectTypes = {};
  transaction.inputObjects.forEach((object) => {
    if (object.objectId && object.objectType) {
      objectTypes[object.objectId] = object.objectType;
    }
  });
  transaction.outputObjects.forEach((object) => {
    if (object.objectId && object.objectType) {
      objectTypes[object.objectId] = object.objectType;
    }
  });
  const effects = parseTransactionEffects({
    effects: transaction.effects
  });
  return {
    digest: transaction.digest,
    epoch: transaction.effects?.epoch?.toString() ?? null,
    effects,
    objectTypes: Promise.resolve(objectTypes),
    transaction: {
      ...data,
      bcs: bytes
    },
    signatures: parsedTx.txSignatures
  };
}
//# sourceMappingURL=core.js.map
