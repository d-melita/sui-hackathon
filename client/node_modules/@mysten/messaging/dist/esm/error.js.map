{
  "version": 3,
  "sources": ["../../src/error.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nexport class MessagingClientError extends Error {}\n\nexport class UserError extends MessagingClientError {}\n\nexport class MessagingAPIError extends MessagingClientError {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic requestId?: string,\n\t\tpublic status?: number,\n\t) {\n\t\tsuper(message);\n\t}\n\n\tstatic #generate(error: string, message: string, requestId: string, status?: number) {\n\t\tswitch (error) {\n\t\t\tcase 'NotImplementedFeature':\n\t\t\t\treturn new ApiNotImplementedFeatureError(requestId);\n\t\t\tdefault:\n\t\t\t\treturn new GeneralError(message, requestId, status);\n\t\t}\n\t}\n\n\tstatic async assertResponse(response: Response, requestId: string) {\n\t\tif (response.ok) {\n\t\t\treturn;\n\t\t}\n\t\tlet errorInstance: MessagingAPIError;\n\t\ttry {\n\t\t\tconst text = await response.text();\n\t\t\tconst error = JSON.parse(text)['error'];\n\t\t\tconst message = JSON.parse(text)['message'];\n\t\t\terrorInstance = MessagingAPIError.#generate(error, message, requestId);\n\t\t} catch {\n\t\t\t// If we can't parse the response as JSON or if it doesn't have the expected format,\n\t\t\t// fall back to using the status text\n\t\t\terrorInstance = new GeneralError(response.statusText, requestId, response.status);\n\t\t}\n\t\tthrow errorInstance;\n\t}\n}\n\nexport class ApiNotImplementedFeatureError extends MessagingAPIError {\n\tconstructor(requestId?: string) {\n\t\tsuper('API: Not implemented yet', requestId);\n\t}\n}\n\n/** General server errors that are not specific to the Messaging API (e.g., 404 \"Not Found\") */\nexport class GeneralError extends MessagingAPIError {}\n\n// Errors returned by the SDK\nexport class NotImplementedFeatureError extends UserError {\n\tconstructor() {\n\t\tsuper('SDK: Not implemented yet');\n\t}\n}\n\nexport function toMajorityError(errors: Error[]): Error {\n\tlet maxCount = 0;\n\tlet majorityError = errors[0];\n\tconst counts = new Map<string, number>();\n\tfor (const error of errors) {\n\t\tconst errorName = error.constructor.name;\n\t\tconst newCount = (counts.get(errorName) || 0) + 1;\n\t\tcounts.set(errorName, newCount);\n\n\t\tif (newCount > maxCount) {\n\t\t\tmaxCount = newCount;\n\t\t\tmajorityError = error;\n\t\t}\n\t}\n\n\treturn majorityError;\n}\n"],
  "mappings": ";;;;;;AAAA;AAEO,MAAM,6BAA6B,MAAM;AAAC;AAE1C,MAAM,kBAAkB,qBAAqB;AAAC;AAE9C,MAAM,qBAAN,MAAM,2BAA0B,qBAAqB;AAAA,EAC3D,YACC,SACO,WACA,QACN;AACD,UAAM,OAAO;AAHN;AACA;AAAA,EAGR;AAAA,EAWA,aAAa,eAAe,UAAoB,WAAmB;AAxBpE;AAyBE,QAAI,SAAS,IAAI;AAChB;AAAA,IACD;AACA,QAAI;AACJ,QAAI;AACH,YAAM,OAAO,MAAM,SAAS,KAAK;AACjC,YAAM,QAAQ,KAAK,MAAM,IAAI,EAAE,OAAO;AACtC,YAAM,UAAU,KAAK,MAAM,IAAI,EAAE,SAAS;AAC1C,sBAAgB,yCAAkB,wCAAlB,SAA4B,OAAO,SAAS;AAAA,IAC7D,QAAQ;AAGP,sBAAgB,IAAI,aAAa,SAAS,YAAY,WAAW,SAAS,MAAM;AAAA,IACjF;AACA,UAAM;AAAA,EACP;AACD;AAnCO;AASC,cAAS,SAAC,OAAe,SAAiB,WAAmB,QAAiB;AACpF,UAAQ,OAAO;AAAA,IACd,KAAK;AACJ,aAAO,IAAI,8BAA8B,SAAS;AAAA,IACnD;AACC,aAAO,IAAI,aAAa,SAAS,WAAW,MAAM;AAAA,EACpD;AACD;AAhBM,aAAM,oBAAN;AAAA,IAAM,oBAAN;AAqCA,MAAM,sCAAsC,kBAAkB;AAAA,EACpE,YAAY,WAAoB;AAC/B,UAAM,4BAA4B,SAAS;AAAA,EAC5C;AACD;AAGO,MAAM,qBAAqB,kBAAkB;AAAC;AAG9C,MAAM,mCAAmC,UAAU;AAAA,EACzD,cAAc;AACb,UAAM,0BAA0B;AAAA,EACjC;AACD;AAEO,SAAS,gBAAgB,QAAwB;AACvD,MAAI,WAAW;AACf,MAAI,gBAAgB,OAAO,CAAC;AAC5B,QAAM,SAAS,oBAAI,IAAoB;AACvC,aAAW,SAAS,QAAQ;AAC3B,UAAM,YAAY,MAAM,YAAY;AACpC,UAAM,YAAY,OAAO,IAAI,SAAS,KAAK,KAAK;AAChD,WAAO,IAAI,WAAW,QAAQ;AAE9B,QAAI,WAAW,UAAU;AACxB,iBAAW;AACX,sBAAgB;AAAA,IACjB;AAAA,EACD;AAEA,SAAO;AACR;",
  "names": []
}
