var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _WalrusStorageAdapter_instances, uploadQuilts_fn, downloadQuilts_fn, extractBlobId_fn, extractQuiltsPatchIds_fn;
class WalrusStorageAdapter {
  constructor(_client, config) {
    this._client = _client;
    this.config = config;
    __privateAdd(this, _WalrusStorageAdapter_instances);
  }
  /**
   * Upload data to Walrus storage
   * @param data - Array of data to upload
   * @param _options - Storage options (currently unused)
   * @returns Upload result with blob IDs
   */
  async upload(data, _options) {
    return await __privateMethod(this, _WalrusStorageAdapter_instances, uploadQuilts_fn).call(this, data);
  }
  /**
   * Download data from Walrus storage
   * @param ids - Array of blob IDs to download
   * @returns Array of downloaded data
   */
  async download(ids) {
    if (ids.length === 0) {
      return [];
    }
    return await __privateMethod(this, _WalrusStorageAdapter_instances, downloadQuilts_fn).call(this, ids);
  }
}
_WalrusStorageAdapter_instances = new WeakSet();
uploadQuilts_fn = async function(data) {
  const formData = new FormData();
  for (let i = 0; i < data.length; i++) {
    const identifier = `attachment${i}`;
    const blob = new Blob([new Uint8Array(data[i])]);
    formData.append(identifier, blob);
  }
  const response = await fetch(
    `${this.config.publisher}/v1/quilts?epochs=${this.config.epochs}`,
    {
      method: "PUT",
      body: formData
    }
  );
  if (!response.ok) {
    const errorText = await response.text();
    console.error("Error response body:", errorText);
    throw new Error(
      `Walrus upload failed: ${response.status} ${response.statusText} - ${errorText}`
    );
  }
  const result = await response.json();
  return { ids: __privateMethod(this, _WalrusStorageAdapter_instances, extractQuiltsPatchIds_fn).call(this, result) };
};
downloadQuilts_fn = async function(patchIds) {
  const response = await Promise.all(
    patchIds.map(
      async (id) => await fetch(`${this.config.aggregator}/v1/blobs/by-quilt-patch-id/${id}`)
    )
  );
  const data = await Promise.all(response.map(async (response2) => await response2.arrayBuffer()));
  return data.map((data2) => new Uint8Array(data2));
};
/**
 * Extract blob ID from Walrus response
 * @param response - Walrus API response
 * @returns Extracted blob ID
 */
// @ts-expect-error Method is currently unused but kept for future implementation
extractBlobId_fn = function(response) {
  if (response.newlyCreated?.blobObject?.blobId) {
    return response.newlyCreated.blobObject.blobId;
  }
  if (response.alreadyCertified?.blobId) {
    return response.alreadyCertified.blobId;
  }
  if (response.blobStoreResult?.newlyCreated?.blobObject?.blobId) {
    return response.blobStoreResult.newlyCreated.blobObject.blobId;
  }
  throw new Error("Unable to extract blob ID from response");
};
/**
 * Extract quilt patch IDs from Walrus response
 * @param response - Walrus API response
 * @returns Array of quilt patch IDs
 */
extractQuiltsPatchIds_fn = function(response) {
  if (response.storedQuiltBlobs) {
    return response.storedQuiltBlobs.map((quilt) => quilt.quiltPatchId);
  }
  throw new Error("Unable to extract quilt patch IDs from response");
};
export {
  WalrusStorageAdapter
};
//# sourceMappingURL=walrus.js.map
