{
  "version": 3,
  "sources": ["../../../../src/contracts/sui_stack_messaging/channel.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, MoveTuple, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nimport * as auth from './auth.js';\nimport * as table_vec from './deps/sui/table_vec.js';\nimport * as message from './message.js';\nimport * as encryption_key_history from './encryption_key_history.js';\nconst $moduleName = '@local-pkg/sui-stack-messaging::channel';\nexport const Channel = new MoveStruct({\n\tname: `${$moduleName}::Channel`,\n\tfields: {\n\t\tid: object.UID,\n\t\t/** The version of this object, for handling updgrades. */\n\t\tversion: bcs.u64(),\n\t\t/**\n\t\t * The Authorization struct, gating actions to member permissions. Note: It also,\n\t\t * practically, keeps tracks of the members (MemberCap ID -> Permissions)\n\t\t */\n\t\tauth: auth.Auth,\n\t\t/**\n\t\t * The message history of the channel.\n\t\t *\n\t\t * Using `TableVec` to avoid the object size limit.\n\t\t */\n\t\tmessages: table_vec.TableVec,\n\t\t/**\n\t\t * The total number of messages, for efficiency, so that we don't have to make a\n\t\t * call to messages.length() (Maybe I am overthinking this, need to measure)\n\t\t */\n\t\tmessages_count: bcs.u64(),\n\t\t/**\n\t\t * A duplicate of the last entry of the messages TableVec,\n\t\t *\n\t\t * Utilize this for efficient fetching e.g. list of conversations showing the\n\t\t * latest message and the user who sent it\n\t\t */\n\t\tlast_message: bcs.option(message.Message),\n\t\t/** The timestamp (in milliseconds) when the channel was created. */\n\t\tcreated_at_ms: bcs.u64(),\n\t\t/**\n\t\t * The timestamp (in milliseconds) when the channel was last updated. (e.g. change\n\t\t * in metadata, members, admins, keys)\n\t\t */\n\t\tupdated_at_ms: bcs.u64(),\n\t\t/**\n\t\t * History of Encryption keys\n\t\t *\n\t\t * Holds the latest key, the latest_version, and a TableVec of the historical keys\n\t\t */\n\t\tencryption_key_history: encryption_key_history.EncryptionKeyHistory,\n\t},\n});\nexport const SimpleMessenger = new MoveTuple({\n\tname: `${$moduleName}::SimpleMessenger`,\n\tfields: [bcs.bool()],\n});\nexport interface NewArguments {\n\tconfig: RawTransactionArgument<string | null>;\n}\nexport interface NewOptions {\n\tpackage?: string;\n\targuments: NewArguments | [config: RawTransactionArgument<string | null>];\n}\n/**\n * Create a new `Channel` object with empty Config, Roles, messages. Adds the\n * creator as a member.\n *\n * The flow is: new() -> (optionally set initial config) -> (optionally set initial\n * members) -> share() -> client generate a DEK and encrypt it with Seal using the\n * ChannelID as identity bytes -> add_encrypted_key(CreatorCap)\n */\nexport function _new(options: NewOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000001::option::Option<${packageAddress}::config::Config>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['config', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ShareArguments {\n\tself: RawTransactionArgument<string>;\n\tcreatorCap: RawTransactionArgument<string>;\n}\nexport interface ShareOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ShareArguments\n\t\t| [self: RawTransactionArgument<string>, creatorCap: RawTransactionArgument<string>];\n}\n/**\n * Share the Channel object Note: at this point the client needs to attach an\n * encrypted DEK Otherwise, it is considered in an invalid state, and cannot be\n * interacted with.\n */\nexport function share(options: ShareOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::creator_cap::CreatorCap`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'creatorCap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'share',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddEncryptedKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tnewEncryptionKeyBytes: RawTransactionArgument<number[]>;\n}\nexport interface AddEncryptedKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddEncryptedKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tnewEncryptionKeyBytes: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Add the encrypted Channel Key (a key encrypted with Seal) to the Channel. */\nexport function addEncryptedKey(options: AddEncryptedKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'newEncryptionKeyBytes'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'add_encrypted_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddMembersArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tn: RawTransactionArgument<number | bigint>;\n}\nexport interface AddMembersOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddMembersArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tn: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Add new members to the Channel with the default SimpleMessenger permission */\nexport function addMembers(options: AddMembersOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'u64',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'n', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'add_members',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMembersArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tmembersToRemove: RawTransactionArgument<string[]>;\n}\nexport interface RemoveMembersOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMembersArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tmembersToRemove: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/**\n * Remove members from the Channel TODO: should we enforce a key rotation here, by\n * asking for a new_encryption_key arg?\n */\nexport function removeMembers(options: RemoveMembersOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'vector<0x0000000000000000000000000000000000000000000000000000000000000002::object::ID>',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'membersToRemove', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'remove_members',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SendMessageArguments {\n\tself: RawTransactionArgument<string>;\n\tmemberCap: RawTransactionArgument<string>;\n\tciphertext: RawTransactionArgument<number[]>;\n\tnonce: RawTransactionArgument<number[]>;\n\tattachments: RawTransactionArgument<string[]>;\n}\nexport interface SendMessageOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SendMessageArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tmemberCap: RawTransactionArgument<string>,\n\t\t\t\tciphertext: RawTransactionArgument<number[]>,\n\t\t\t\tnonce: RawTransactionArgument<number[]>,\n\t\t\t\tattachments: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/** Send a new message to the Channel */\nexport function sendMessage(options: SendMessageOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::channel::Channel`,\n\t\t`${packageAddress}::member_cap::MemberCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t`vector<${packageAddress}::attachment::Attachment>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'memberCap', 'ciphertext', 'nonce', 'attachments', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'send_message',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NamespaceArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface NamespaceOptions {\n\tpackage?: string;\n\targuments: NamespaceArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Returns a namespace for the channel to be utilized by seal_policies In this case\n * we use the Channel's UID bytes\n */\nexport function namespace(options: NamespaceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/sui-stack-messaging';\n\tconst argumentsTypes = [`${packageAddress}::channel::Channel`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'channel',\n\t\t\tfunction: 'namespace',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n"],
  "mappings": "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",
  "names": []
}
